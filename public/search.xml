<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>判断推理--类比</title>
      <link href="/2020/05/16%E6%8E%A8%E7%90%86%E5%88%A4%E6%96%AD-%E7%B1%BB%E6%AF%94/"/>
      <url>/2020/05/16%E6%8E%A8%E7%90%86%E5%88%A4%E6%96%AD-%E7%B1%BB%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/05/16推理判断-类比/../../../images/photos/2020/018.jpg" width="70%"></p><p><span class="geyan"> 凡斗者，必自以为是，而以人为非也。（《荀子·荣辱》） </span> <a id="more"></a></p><h2 id="类比推理">类比推理</h2><p><strong>题目要求：</strong></p><p>题干给出一组相关的词，要求通过观察分析，在备选答案中找出一组与之在<strong>逻辑关系</strong>上最为贴近或<strong>相似的词</strong></p><p><strong>常见题型：</strong></p><ol type="1"><li>两词型——A∶B</li><li>三词型——A∶B∶C</li><li>填空型——A 对于（ ）相当于（ ）对于 B ---&gt; <code>代入判断</code></li></ol><h3 id="语义关系">语义关系</h3><h4 id="近义反义关系">近义、反义关系</h4><ol type="1"><li>一级关系<ol type="1"><li>近义关系<ol type="1"><li>开心-高兴</li><li>言不由衷-口是心非</li></ol></li><li>反义关系<ol type="1"><li>勤奋-懒惰</li><li>一丝不苟-粗枝大叶</li></ol></li></ol></li><li>二级关系 <strong>如果一级无法区分</strong><ol type="1"><li>感情色彩<ol type="1"><li>褒义</li><li>贬义</li><li>中性</li></ol></li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例 <span class="number">1</span>（<span class="number">2017</span> 江西）精致∶粗糙</span><br><span class="line">A. 河水∶海水     C. 违背∶遵循</span><br><span class="line">B. 山峰∶深渊     D. 怀疑∶守信 [守信&lt;-&gt;失信]  [怀疑-相信]</span><br></pre></td></tr></table></figure><p><span id="inline-purple"> 解题思路 </span></p><ol type="1"><li>实例为反义词<ol type="1"><li>一般 <strong>形容词、动词</strong> 可以形成近反义词</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例 <span class="number">3</span>（<span class="number">2016</span> 吉林）大义凛然∶卑躬屈膝 D</span><br><span class="line">A. 安分守己∶好高骛远     B. 穷奢极欲∶节衣缩食</span><br><span class="line">C. 得心应手∶百无一能     D. 持之以恒∶虎头蛇尾</span><br></pre></td></tr></table></figure><p><span id="inline-blue"> 解题思路 </span></p><table><thead><tr class="header"><th>成语</th><th>含义</th><th>褒/贬</th><th>近义词</th><th>反义词</th></tr></thead><tbody><tr class="odd"><td>安分守己</td><td>安于本分、规矩老师</td><td>褒</td><td>安分守常、<code>循规蹈矩</code>、奉公守法</td><td>为非作歹、胡作非为</td></tr><tr class="even"><td>好高骛远</td><td>脱离实际追求难以实现的目标</td><td><strong>贬</strong></td><td>不自量力</td><td>脚踏实地 、量力而行</td></tr><tr class="odd"><td>穷奢极欲</td><td>极度奢侈、任意挥霍、纵情享受</td><td><strong>贬</strong></td><td>骄奢淫逸</td><td>节衣缩食 克勤克俭 <code>单食瓢饮</code></td></tr><tr class="even"><td>节衣缩食</td><td>省穿省吃 生活<code>节俭</code></td><td></td><td></td><td></td></tr><tr class="odd"><td>得心应手</td><td>技艺纯熟、应用自如</td><td></td><td>心手相应、挥洒自如</td><td>力不从心</td></tr><tr class="even"><td>百无一能</td><td>什么都不会</td><td>贬</td><td>一无所长</td><td>无所不能</td></tr></tbody></table><ol type="1"><li>持之以恒：用恒心坚持下去 不间断不松懈<ol type="1"><li>褒义词</li><li>近义词： 契而不舍 坚持不懈</li><li>反义词：虎头蛇尾 半途而废 浅尝辄止</li></ol></li><li>虎头蛇尾：有始无终 起初声势很大 后来劲头很小<ol type="1"><li>贬义词：半途而废 浅尝辄止</li><li>近义词：</li></ol></li></ol><p>二级辨析 感情色彩</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例 <span class="number">4</span>（<span class="number">2016</span> 厦门）成败∶呼吸 B</span><br><span class="line">A.拉扯∶拖拽     B.好歹∶始终</span><br><span class="line">C.匆忙∶潇洒     D.推荐∶录用</span><br></pre></td></tr></table></figure><p><span id="inline-blue"> 汇总 </span></p><ol type="1"><li>同反词</li><li>感情</li><li>拆字对比</li></ol><hr><p><img src="/2020/05/16推理判断-类比/05.png" width="50%"></p><blockquote><p>全是语文基础。。。</p></blockquote><p>常识积累：</p><ol type="1"><li>“丝”指<code>弦乐器</code>，“竹”指<code>管乐器</code>，丝竹是中国古代乐器的总称，也借指 <code>音乐</code>。</li><li>“案牍”中“案”指桌子， “牍”指竹简，词语指桌上用来写字的竹简，指代公文, 《陋室铭》：无丝竹之乱耳，无案牍之劳形。</li><li>汗青代指史册, 古代在竹简上书写，采来青色的竹子，用火烤的冒出水后才易书写;</li><li>干戈：“干”指盾牌，“戈”指古代武器，“干戈”泛指武器</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 判断推理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类比 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断推理--逻辑</title>
      <link href="/2020/05/15%E6%8E%A8%E7%90%86%E5%88%A4%E6%96%AD-%E9%80%BB%E8%BE%91/"/>
      <url>/2020/05/15%E6%8E%A8%E7%90%86%E5%88%A4%E6%96%AD-%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/05/15推理判断-逻辑/../../../images/photos/2020/019.jpg" width="80%"></p><p><span class="geyan"> 美好的东西是不会死的。<br> The good things are not dead.<br> --《肖申克的救赎》 </span> <a id="more"></a></p><h2 id="翻译推理">翻译推理</h2><p><span id="inline-purple"> 题型特征 </span></p><ol type="1"><li>题干和选项中出现比较明显的逻辑关联词</li><li>提问方式是“可以推出”“不能推出”等</li></ol><p><span id="inline-bule"> 解题思维 </span></p><ol type="1"><li>先翻译 == （逻辑关系词 翻译为 A =&gt; B )</li><li>再推理 == （根据逻辑公式进行推导）</li></ol><h3 id="前推后">前推后</h3><p>关联词</p><ol type="1"><li>如果。那么/就。</li><li>若。则。</li><li>只要。就。</li><li>所有。都。</li><li>为了。一定/必须。</li><li>。是。的充分条件</li></ol><p><img src="/2020/05/15推理判断-逻辑/04.png" width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/05.png" width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/06.png" titie="串起来" width="80%"></p><h3 id="后推前">后推前</h3><p><img src="/2020/05/15推理判断-逻辑/07.png" width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/08.png" title="答案：B" width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/09.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/10.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/11.png" width="80%"></p><blockquote><p>谁必不可少 就放在箭头后边</p></blockquote><p><img src="/2020/05/15推理判断-逻辑/12.png" width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/13.png" width="80%"></p><h3 id="且-或">且 或</h3><p><img src="/2020/05/15推理判断-逻辑/14.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/15.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/16.png" title="答案：C" width="80%"> <img src="/2020/05/15推理判断-逻辑/17.png" title="答案：C" width="80%"> <img src="/2020/05/15推理判断-逻辑/18.png" width="80%"></p><h3 id="德-摩根定律">德 摩根定律</h3><p><img src="/2020/05/15推理判断-逻辑/19.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/20.png" width="80%"></p><h3 id="推理方式">推理方式</h3><p>提问方式：以下哪项中的推理形式/结构与题干中的推理形式/结构相同？</p><p>照这写就行</p><p><img src="/2020/05/15推理判断-逻辑/22.png" width="80%"></p><hr><p><img src="/2020/05/15推理判断-逻辑/21.png" width="80%"></p><h2 id="组合排列">组合排列</h2><p><span id="inline-purple"> 题型特征 </span></p><ol type="1"><li>题干给出两组以及两组以上对象</li><li>给出几组对象之间的关系</li></ol><h3 id="排除法代入法">排除法、代入法</h3><ol type="1"><li>何时用：题干条件为真，选项信息充分。</li><li>如何用：读一句，排一句</li></ol><p><img src="/2020/05/15推理判断-逻辑/23.png" width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/24.png" width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/25.png" width="80%"></p><h3 id="辅助技巧">辅助技巧</h3><p><img src="/2020/05/15推理判断-逻辑/27.png" width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/26.png" width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/28.png" title="列公式" width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/29.png" titile="好好看" width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/30.png" titile="有点复杂" width="100%"></p><p><img src="/2020/05/15推理判断-逻辑/31.png" titile="还不定项" width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/32.png" titile="还不定项" width="80%"></p><h2 id="日常结论">日常结论</h2><p><span id="inline-purple"> 类似于言语的细节判断 </span></p><p>题干： 言语、无逻辑关联词</p><p>提问：由此可以推出、不能推出</p><p><span id="inline-bule"> 解题思路 </span></p><ol type="1"><li><strong>不选</strong><ol type="1"><li>逻辑错误</li><li>无中生有</li><li>偷换概念</li></ol></li><li><code>慎选</code><ol type="1"><li>比较关系：比。, 越来越。、更</li><li>绝对词：一定、必须、肯定、只要就、只有才</li><li>程度：最、极大、很。</li><li>范围的扩大</li></ol></li><li><span id="inline-purple"> 优选 </span><ol type="1"><li>词汇：可能、有的、有些。</li></ol></li></ol><blockquote><p><strong>警惕</strong>五大坑王：更！最！越！首！极！</p></blockquote><hr><p><img src="/2020/05/15推理判断-逻辑/33.png" titile width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/34.png" titile width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/35.png" titile width="100%"></p><h2 id="逻辑论证">逻辑论证</h2><h3 id="概念">概念</h3><p>消弱题型：反对</p><p>加强题型：赞同</p><p><img src="/2020/05/15推理判断-逻辑/36.png" titile width="80%"> <img src="/2020/05/15推理判断-逻辑/37.png" titile width="80%"> <img src="/2020/05/15推理判断-逻辑/38.png" titile width="80%"> <img src="/2020/05/15推理判断-逻辑/39.png" titile width="80%"> <img src="/2020/05/15推理判断-逻辑/40.png" titile width="80%"> <img src="/2020/05/15推理判断-逻辑/41.png" titile width="80%"> <img src="/2020/05/15推理判断-逻辑/42.png" titile width="80%"> <img src="/2020/05/15推理判断-逻辑/43.png" titile width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/44.png" titile="优选：B" width="80%"></p><h3 id="加强">加强</h3><h4 id="解释原因-举例子">解释原因 &amp; 举例子</h4><p>采用 解释说明 ｜｜ 举例子</p><ol type="1"><li>只有论点</li><li>论点与论据话题不一致</li></ol><p><img src="/2020/05/15推理判断-逻辑/45.png" titile width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/46.png" titile width="80%"></p><h4 id="论点论据搭桥">论点&amp;论据搭桥</h4><ol type="1"><li>论点 论据不一致<ol type="1"><li>去同存异</li></ol></li></ol><p><img src="/2020/05/15推理判断-逻辑/50.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/51.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/52.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/53.png" title="答案：C" width="80%"> <img src="/2020/05/15推理判断-逻辑/54.png" width="80%"></p><h4 id="必要条件">必要条件</h4><p>属于补充论据</p><p><img src="/2020/05/15推理判断-逻辑/55.png" width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/56.png" width="80%"></p><h4 id="总结">总结</h4><p><img src="/2020/05/15推理判断-逻辑/57.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/58.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/59.png" width="80%"></p><ol type="1"><li>示例--解释说明<ol type="1"><li>论点：伐木 &amp; 文明</li><li>解释说明：伐木 与 文明的关系</li></ol></li><li>示例--搭桥<ol type="1"><li>论点：文明。</li><li>论据：伐木。</li><li>搭桥：伐木 与 文明的关系</li></ol></li></ol><h3 id="削弱">削弱</h3><p><img src="/2020/05/15推理判断-逻辑/60.png" width="80%"></p><h4 id="否论点-举反例">否论点 &amp; 举反例</h4><p><img src="/2020/05/15推理判断-逻辑/61.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/62.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/63.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/64.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/65.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/66.png" width="80%"></p><h4 id="拆桥-论点论据">拆桥-论点&amp;论据</h4><p><img src="/2020/05/15推理判断-逻辑/67.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/68.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/69.png" width="80%"></p><p>总结 <img src="/2020/05/15推理判断-逻辑/70.png" width="80%"></p><h4 id="否定论据">否定论据</h4><p><img src="/2020/05/15推理判断-逻辑/71.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/72.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/73.png" width="80%"> <img src="/2020/05/15推理判断-逻辑/74.png" title="B" width="80%"> <img src="/2020/05/15推理判断-逻辑/75.png" title="很好的综合选项" width="80%"></p><p><img src="/2020/05/15推理判断-逻辑/76.png" width="80%"></p><h2 id="易错点">❌易错点❌</h2><p><span id="inline-purple"> 对策 <span></span></span></p><p>选项中出现<strong>对策</strong>类的词汇，并不知道对策是否执行，所以一定要注意，<code>有问题</code>--不选择 如：</p><ol type="1"><li>法律 <strong>应该</strong> 制定 ...</li><li>企业 <strong>应当</strong> 担负 ...</li></ol><p><span id="inline-blue"> 诉诸无知 == 不知道 <span></span></span></p><p>不知道的<strong>论据</strong>，不能当论据了，<code>不选择</code>。如：</p><ol type="1"><li><strong>没有实际数据显示。..</strong></li><li><strong>没有研究表明。...</strong></li><li>我们<code>没注意</code>到。..</li></ol><p><span id="inline-yellow"> 超出范围 <span></span></span></p><p>如果讨论的是 [A, B], 结果来了个论据是 <strong>还有更好的</strong>，超出谈论范围，<strong>不选择</strong></p><p><span id="inline-purple"> 无关选项 <span></span></span></p><p>和<strong>话题、主体</strong>不一致的不选择</p><p><span id="inline-blue"> 类比的选项 <span></span></span></p><p>类比一般比较弱，<strong>慎选</strong> 如：<code>两者类似</code></p>]]></content>
      
      
      <categories>
          
          <category> 判断推理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爱因斯坦--我的世界观</title>
      <link href="/2020/05/15%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F--%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E8%A7%82/"/>
      <url>/2020/05/15%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F--%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E8%A7%82/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/05/15关于人生--我的世界观/../../../images/photos/2020/016.jpg" width="66%"></p><p><span class="geyan"> 世上只有一种英雄主义——就是在认清生活的真相之后依然热爱生活 ——罗曼.罗兰 （作家 诺贝尔奖得主） </span> <a id="more"></a></p><blockquote><p>（之前说“本文是爱因斯坦在1921年诺贝尔奖颁奖典礼上的演说辞”有误，查了资料订正如下：此文最初发表在1930年出版的《论坛和世纪》（Forum and century）84卷，193-194页。当时用的标题是“我的信仰”（What I believe）。这里译自《思想和见解》8-11页和《我的世界观》英译本237-242页，许良英、赵中立、张宜三编译，选自商务印书馆《爱因斯坦文集第三卷》。）</p></blockquote><p>　　我们这些总有一死的人，命运是多么的奇特！我们每个人在这个世界上都只作一个短暂的逗留；目的何在，却无从知道，尽管有时自以为对此若有所感。但是，不必深思，只要从日常生活中就可以明白：人是为别人而生存的──首先是为那样一些人，我们的幸福全部依赖于他们的喜悦和健康；其次是为许多我们所不认识的人，他们的命运通过同情的纽带同我们密切结合在一起。我每天上百次的提醒自己：我的精神生活和物质生活都是以别人（包括生者和死者）的劳动为基础的，我必须尽力以同样的分量来报偿我所领受了的和至今还在领受着的东西。我强烈地向往着俭朴的生活。并且时常发觉自己占用了同胞的过多劳动而难以忍受。我认为阶级的区分是不合理的，它最后所凭借的是以暴力为根据。我也相信，简单淳朴的生活，无论在身体上还是在精神上，对每个人都是有益的。</p><p>　　我完全不相信人类会有那种在哲学意义上的自由。每个人的行为不仅受着外界的强制，而且要适应内在的必然。叔本华说：“人虽然能够做他所想做的，但不能要他所想要的。”这句格言从我青年时代起就给了我真正的启示；在我自己和别人的生活面临困难的时候，它总是使我们得到安慰，并且是宽容的持续不断的源泉。这种体会可以宽大为怀地减轻那种容易使人气馁的责任感，也可以防止我们过于严肃地对待自己和别人；它导致一种特别给幽默以应有地位的人生观。</p><p>　　要追究一个人自己或一切生物生存的意义或目的，从客观的角度来看，我总觉得是愚蠢可笑的。可是每个人都有一些理想，这些理想决定着他的努力和判断的方向。就在这个意义上，我从来不把安逸和享乐看作生活目的本身──我把这种伦理基础叫做“猪栏的理想”。照亮我的道路，是善、美和真。要是没有志同道合者之间的亲切感情，要不是全神贯注于客观世界──那个在艺术和科学工作领域里永远达不到的对象，那么在我看来，生活就会是空虚的。我总觉得，人们所努力追求的庸俗目标──财产、虚荣、奢侈的生活──都是可鄙的。</p><p>　　我有强烈的社会正义感和社会责任感，但我又明显地缺乏与别人和社会直接接触的要求，这两者总是形成古怪的对照。我实在是一个“孤独的旅客”，我未曾全心全意地属于我的国家、我的家庭、我的朋友，甚至我最为接近的亲人；在所有这些关系面前，我总是感觉到有一定距离而且需要保持孤独──而这种感受正与年俱增。人们会清楚地发觉，同别人的相互了解和协调一致是有限度的，但这不值得惋惜。无疑，这样的人在某种程度上会失去他的天真无邪和无忧无虑的心境；但另一方面，他却能够在很大程度上不为别人的意见、习惯和判断所左右，并且能够避免那种把他的内心平衡建立在这样一些不可靠的基础之上的诱惑。</p><p>　　我的政治理想是民主政体。让每一个人都作为个人而受到尊重，而不让任何人成为被崇拜的偶像。我自己一直受到同代人的过分的赞扬和尊敬，这不是由于我自己的过错，也不是由于我自己的功劳，而实在是一种命运的嘲弄。其原因大概在于人们有一种愿望，想理解我以自已微薄的绵力，通过不断的斗争所获得的少数几个观念，而这种愿望有很多人却未能实现。我完全明白，一个组织要实现它的目的，就必须有一个人去思考，去指挥、并且全面担负起责任来。但是被领导的人不应当受到强迫，他们必须能够选择自己的领袖。在我看来，强迫的专制制度很快就会腐化堕落。因为暴力所招引来的总是一些品德低劣的人；而且我相信，天才的暴君总是由无赖来继承的，这是一条千古不易的规律。就是由于这个缘故，我总强烈地反对今天在意大利和俄国所见到的那种制度。像欧洲今天所存在的情况，已使得民主形式受到怀疑，这不能归咎于民主原则本身，而是由于政府的不稳定和选举制度中与个人无关的特征。我相信美国在这方面已经找到了正确的道路。他们选出了一个任期足够长的总统，他有充分的权力来真正履行他的职责。另一方面，在德国政治制度中，为我所看重的是它为救济患病或贫困的人作出了可贵的广泛的规定。在人生的丰富多彩的表演中，我觉得真正可贵的，不是政治上的国家，而是有创造性的、有感情的个人，是人格；只有个人才能创造出高尚的和卓越的东西，而群众本身在思想上总是迟钝的，在感觉上也总是迟钝的。</p><p>　　讲到这里，我想起了群众生活中最坏的一种表现，那就是使我厌恶的军事制度。一个人能够洋洋得意的随着军乐队在四列纵队里行进，单凭这一点就足以使我对他鄙夷不屑。<code>他所以长了一个大脑，只是出于误会；光是骨髓就可满足他的全部需要了</code>。文明的这种罪恶的渊薮，应当尽快加以消灭。任人支配的英雄主义、冷酷无情的暴行，以及在爱国主义名义下的一切可恶的胡闹，所有这些都使我深恶痛绝！在我看来，战争是多么卑鄙、下流！我宁愿被千刀万剐，也不愿参与这种可憎的勾当。尽管如此，我对人类的评价还是十分高的。我相信，要是人民的健康感情没有遭到那些通过学校和报纸而起作用的商业利益和政治利益的蓄意败坏，那么战争这个妖魔早就该绝迹了。</p><p>　　我们能拥有的最美好的体验是探求奥秘的体验。它是坚守在真正艺术和真正科学发源地上的基本感情。谁要是体会不到它，谁要是不再有好奇心，也不再有惊讶的感觉，谁就无异于行尸走肉，他的眼睛便是模糊不清的。就是这种奥秘的体验──虽然掺杂着恐惧──产生了宗教。我们认识到有某种为我们所不能洞察的东西存在，感觉到那种只能以其最原始的形式接近我们的心灵的最深奥的理性和最灿烂的美──正是这种认识和这种情感构成了真正的宗教感情；在这个意义上，而且也只是在这个意义上，我才是一个具有深挚的宗教感情的人。我无法想象存在这样一个上帝，它会对自己的创造物加以赏罚，会具有我们在自己身上所体验到的那种意志。我不能也不愿去想象一个人在肉体死亡以后还会继续活着；让那些脆弱的灵魂，由于恐惧或者由于可笑的唯我论，去拿这种思想当宝贝吧！我自己只求满足于生命永恒的奥秘，满足于觉察现存世界的神奇结构，窥见它的一鳞半爪，并且以诚挚的努力去领悟在自然界中显示出来的那个理性的一部分，倘若真能如此，即使只领悟其极小的一部分，我也就心满意足了。</p><hr><p>The World as I See It</p><p>A. Einstein</p><p>"How strange is the lot of us mortals! Each of us is here for a brief sojourn; for what purpose he knows not, though he sometimes thinks he senses it. But without deeper reflection one knows from daily life that one exists for other people -- first of all for those upon whose smiles and well-being our own happiness is wholly dependent, and then for the many, unknown to us, to whose destinies we are bound by the ties of sympathy. A hundred times every day I remind myself that my inner and outer life are based on the labors of other men, living and dead, and that I must exert myself in order to give in the same measure as I have received and am still receiving...</p><p>"I have never looked upon ease and happiness as ends in themselves -- this critical basis I call the ideal of a pigsty. The ideals that have lighted my way, and time after time have given me new courage to face life cheerfully, have been Kindness, Beauty, and Truth. Without the sense of kinship with men of like mind, without the occupation with the objective world, the eternally unattainable in the field of art and scientific endeavors, life would have seemed empty to me. The trite objects of human efforts -- possessions, outward success, luxury -- have always seemed to me contemptible.</p><p>"My passionate sense of social justice and social responsibility has always contrasted oddly with my pronounced lack of need for direct contact with other human beings and human communities. I am truly a 'lone traveler' and have never belonged to my country, my home, my friends, or even my immediate family, with my whole heart; in the face of all these ties, I have never lost a sense of distance and a need for solitude..."</p><p>"My political ideal is democracy. Let every man be respected as an individual and no man idolized. It is an irony of fate that I myself have been the recipient of excessive admiration and reverence from my fellow-beings, through no fault, and no merit, of my own. The cause of this may well be the desire, unattainable for many, to understand the few ideas to which I have with my feeble powers attained through ceaseless struggle. I am quite aware that for any organization to reach its goals, one man must do the thinking and directing and generally bear the responsibility. But the led must not be coerced, they must be able to choose their leader. In my opinion, an autocratic system of coercion soon degenerates; force attracts men of low morality... The really valuable thing in the pageant of human life seems to me not the political state, but the creative, sentient individual, the personality; it alone creates the noble and the sublime, while the herd as such remains dull in thought and dull in feeling.</p><p>"This topic brings me to that worst outcrop of herd life, the military system, which I abhor... This plague-spot of civilization ought to be abolished with all possible speed. Heroism on command, senseless violence, and all the loathsome nonsense that goes by the name of patriotism -- how passionately I hate them!</p><p>"The most beautiful experience we can have is the mysterious. It is the fundamental emotion that stands at the cradle of true art and true science. Whoever does not know it and can no longer wonder, no longer marvel, is as good as dead, and his eyes are dimmed. It was the experience of mystery -- even if mixed with fear -- that engendered religion. A knowledge of the existence of something we cannot penetrate, our perceptions of the profoundest reason and the most radiant beauty, which only in their most primitive forms are accessible to our minds: it is this knowledge and this emotion that constitute true religiosity. In this sense, and only this sense, I am a deeply religious man... I am satisfied with the mystery of life's eternity and with a knowledge, a sense, of the marvelous structure of existence -- as well as the humble attempt to understand even a tiny portion of the Reason that manifests itself in nature."</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断推理-图形</title>
      <link href="/2020/05/15%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86-%E5%9B%BE%E5%BD%A2/"/>
      <url>/2020/05/15%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86-%E5%9B%BE%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/05/15判断推理-图形/../../../images/photos/2020/017.jpg" width="70%"></p><p><span class="geyan"> 恐惧让你沦为囚犯，希望让你重获自由。<br> Fear can hold you prisoner, hope can set you free.<br> --《肖申克的救赎》 </span> <a id="more"></a></p><p>图形推理四大题型</p><ol type="1"><li>图形推理</li><li>类比推理</li><li>定义判断</li><li>逻辑判断</li></ol><h2 id="第一部分-图形推理">第一部分 图形推理</h2><p><img src="/2020/05/15判断推理-图形/04.png" width="30%"></p><ol type="1"><li>考点<ol type="1"><li>位置规律</li><li>样式规律</li><li>属性规律</li><li>数量规律</li><li>空间重构</li></ol></li><li>快速定位<strong>图形特征</strong></li></ol><h3 id="第一节-位置规律">第一节 位置规律</h3><p><span id="inline-blue"> 特征： 元素组成相同 </span></p><p><span id="inline-purple"> 考点 -- 平移 </span></p><ol type="1"><li><strong>方向</strong><ol type="1"><li>直线： 上下、左右、对角线</li><li>绕圈：顺、逆时针</li></ol></li><li><strong>步数</strong><ol type="1"><li>恒定、递增（等差）</li></ol></li></ol><p><img src="/2020/05/15判断推理-图形/05.png" width="60%"> <img src="/2020/05/15判断推理-图形/06.png" width="60%"> <img src="/2020/05/15判断推理-图形/07.png" width="60%"> <img src="/2020/05/15判断推理-图形/08.png" width="60%"> <img src="/2020/05/15判断推理-图形/09.png" width="60%"></p><p><img src="/2020/05/15判断推理-图形/10.png" width="60%"> <img src="/2020/05/15判断推理-图形/11.png" width="60%"> <img src="/2020/05/15判断推理-图形/12.png" width="60%"></p><p><span id="inline-purple"> 考点 -- 旋转、翻转 </span></p><p><img src="/2020/05/15判断推理-图形/13.png" width="60%"> <img src="/2020/05/15判断推理-图形/14.png" width="60%"></p><p><img src="/2020/05/15判断推理-图形/15.png" width="60%"></p><p><img src="/2020/05/15判断推理-图形/16.png" width="60%"> <img src="/2020/05/15判断推理-图形/17.png" width="60%"></p><h3 id="第二节-样式规律">第二节 样式规律</h3><p><span id="inline-blue"> 特征： 元素组成<strong>相似</strong></span></p><p><img src="/2020/05/15判断推理-图形/18.png" width="60%"></p><p><span id="inline-purple">考点</span></p><ol type="1"><li>遍历</li></ol><p><img src="/2020/05/15判断推理-图形/19.png" width="60%"> <img src="/2020/05/15判断推理-图形/20.png" width="60%"></p>]]></content>
      
      
      <categories>
          
          <category> 判断推理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>言语理解-积累</title>
      <link href="/2020/05/14%E8%A8%80%E8%AF%AD%E7%90%86%E8%A7%A3-%E7%A7%AF%E7%B4%AF4/"/>
      <url>/2020/05/14%E8%A8%80%E8%AF%AD%E7%90%86%E8%A7%A3-%E7%A7%AF%E7%B4%AF4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/05/14言语理解-积累4/../../../images/photos/2020/015.jpg" width="80%"></p><p><span class="geyan"> 君子之学也，入乎耳，着乎心——《荀子·劝学》 </span> <a id="more"></a></p><blockquote><p>很惭愧的是，到现在都分不清楚汉语的语法 知识终究是要还的！</p></blockquote><h2 id="第一部分-语法">第一部分 语法</h2><h3 id="构成方式分类">构成方式分类</h3><p>按词性分类</p><ol type="1"><li><strong>实词</strong><ol type="1"><li><code>名词</code>：<code>表示人或事物名称的词</code><ol type="1"><li>如：学生、猎豹、上午、东南</li></ol></li><li><code>动词</code>：表示动作行为，发展变化，可能意愿及心理活动的词<ol type="1"><li>行为动词：跑、唱、喝、敲、吆喝、盯、踢、闻、听、摸……</li><li>发展动词：生长、枯萎、发芽、结果、产卵……</li><li>心理动词：喜欢、恨、气愤、觉得、思考、厌恶……</li><li>存现动词：消失、显现、有、丢失、幻灭……</li><li>使令动词：使、让、令、禁止、勒令……</li><li>能愿动词：会、愿意、可以、能够、宁可……</li><li>趋向动词：来、去、上、下……</li><li>判断动词：是、为、乃……</li></ol></li><li><code>形容词</code>：表示事物性质、状貌特征的词，<ol type="1"><li>表示形状的：大、高、胖、瘪、细、壮……</li><li>表示性质的：甜、好、香、漂亮、圆滑、机智、单调……</li><li>表示状态的：快、浓、满、多、迅速、悄悄……</li></ol></li><li>数词：表示事物数目的词，有：<ol type="1"><li>汉语语法史</li><li>汉语语法史</li><li>确数词：1、2、3、一、二、三、壹、贰、叁、二分之一、3.45……</li><li>概数：几、一些、左右、以下、余……</li><li>序数：第一、第二、老大、老三、初九、初十……</li></ol></li><li>量词：表示事物或动作的单位，有：<ol type="1"><li>名量词：尺、寸、里、公里、斤、两、辆、角、元……</li><li>动量词：把、次、趟、下、回、声、脚、幢、座……</li><li>时量词：天、年、秒、小时、分（钟）。</li></ol></li><li><code>代词</code>：能代替事物名称的词，有：<ol type="1"><li>人称代词：我、你、它、她们、大家、咱们……</li><li>疑问代词：谁、什么、怎么、哪里、为什么、何以……</li><li>指示代词：这、那、那里、那边，这边……</li></ol></li></ol></li><li><strong>虚词</strong><ol type="1"><li><code>副词</code>， 起修饰或<code>限制动词或形容词</code>作用、表程度或范围的词，有：<ol type="1"><li>程度副词：很、极、非常、太、过分……</li><li>时间副词：已、刚、才、将、要……</li><li>范围副词：都、全、总、只、仅……</li><li>情态副词：正好、果然、刚好、依然、全然、悄然……</li><li>语气副词：准保、确实、不、没有、岂、难道、尤其、甚至、绝对……</li><li>重复副词：又、再、还、仍……</li></ol></li><li><code>介词</code>，用在名词、代词或名词性词组前边，合起来表示方向、对象等的<ol type="1"><li>如：从、往、在、当、把、对、同、为、以、比、跟、被、由于、除了。</li></ol></li><li>连词，连接词。连接短语或句子的词，<ol type="1"><li>如：和、同、跟、不但、并且、只要、而且、与其、尚且。</li></ol></li><li>助词，附着在别的词后面、独立性差、无实义的一种特殊的虚词，有：<ol type="1"><li>结构助词：的、地、得、所……</li><li>时态助词：着、了、过……</li><li>语气助词：呢、吧、吗、哟、哩、呀、啥……</li></ol></li><li>叹词，表示感叹或者呼唤答应的词，<ol type="1"><li>如：啊、哎、哦、噢、哼、呸、呀。</li></ol></li><li>拟声词，模拟事物的声音的词，<ol type="1"><li>如：哗哗、轰隆隆、淅淅沥沥、咚咚、噼里啪啦、哗啦啦、滴答、喔喔、旺旺、喵喵、唧唧、叽叽喳喳、啪啪。</li></ol></li></ol></li></ol><h3 id="文法的语序">文法的语序</h3><p><strong>主谓宾结构</strong>为一种文法的语序，即语法顺序为<code>主语—谓语—宾语</code>的结构。</p><ol type="1"><li>主语<ol type="1"><li>主语表示句子主要说明的<code>人或事物</code>，一般由名词，代词，数词，不定式等充当。</li></ol></li><li>谓语<ol type="1"><li>谓语说明主语的<code>动作、状态或特征</code>。</li></ol></li><li>宾语<ol type="1"><li>宾语<code>表示动作行为</code>的对象，跟在及物动词之后，能作宾语的有名词，代词，数词，动词不定式等。</li></ol></li></ol><p>主语是执行句子的行为或动作的主体，如<code>“我写字”</code>中</p><ol type="1"><li>“我”，就是主语，它做“写”这个动作。</li><li>“写”则是谓语</li><li>而“字”是接受谓语“写”这个动作的对象，它因此被称为宾语，</li></ol><p>又如”花死了”中的”花”就是主语，”死了”即是对主语”花”的陈述，所以是谓语．有的语法书也称主语为“客体”或“受体”。</p><p><img src="/2020/05/14言语理解-积累4/04.jpg"></p><h2 id="第二部分-词汇">第二部分 词汇</h2><p><strong>参考文章</strong></p><p><a href="https://zhuanlan.zhihu.com/p/21367822" target="_blank" rel="noopener">我想这样讲“词性和句子成分”</a> <a href="https://zhuanlan.zhihu.com/p/40365328" target="_blank" rel="noopener">句子的成分：主谓宾定状补分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 公考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 言语理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>言语理解-考点2</title>
      <link href="/2020/05/13%E8%A8%80%E8%AF%AD%E7%90%86%E8%A7%A3-%E8%80%83%E7%82%B93/"/>
      <url>/2020/05/13%E8%A8%80%E8%AF%AD%E7%90%86%E8%A7%A3-%E8%80%83%E7%82%B93/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/05/13言语理解-考点3/../../../images/photos/2020/014.jpg" width="80%"></p><p><span class="geyan"> 虽有戈矛之刺，不如恭俭之利也。故与人善言，暖于布帛；伤人之言，深于矛戟（《荀子·荣辱》） </span> <a id="more"></a></p><h2 id="第一节-逻辑填空">第一节 逻辑填空</h2><p>【题型分类】</p><ol type="1"><li>实词辨析</li><li>成语辨析 ——高频成语</li><li>关联词辨析 ——关联词语</li></ol><p>【做题原则】</p><ol type="1"><li>排除选项<ol type="1"><li>感情色彩：贬义/褒义；<strong>倾向性</strong>（<code>积极/消极</code>）<ol type="1"><li>如果确定了倾向性，对比答案，排除不一致的</li></ol></li><li><strong>语义轻重</strong>：<ol type="1"><li>批评/批判；损坏/破坏；骚动/骚乱；妨碍/妨害；</li></ol></li><li>表达风格：语体风格；文体风格；俗语和正式语需要根据文本来决定</li></ol></li><li>确定答案<ol type="1"><li>搭配范围</li><li>语素差异</li><li>词性功能</li></ol></li></ol><blockquote><p>剩余的就好好补欠的语文词汇吧</p></blockquote><h2 id="第二节-成语解析">第二节 成语解析</h2><blockquote><p>欠的还是要还的。 剩余的就好好补欠的语文词汇吧</p></blockquote><h2 id="第三节-篇章阅读">第三节 篇章阅读</h2><p>【文章载体】</p><ol type="1"><li><p>社会科学类</p></li><li><p>科技说明类</p></li></ol><p>【考查题型】</p><ol type="1"><li>词句理解题<ol type="1"><li>词语理解题</li><li>语句理解题</li></ol></li><li>代词指代题</li><li>细节理解题</li><li>标题填入题</li><li>语句衔接题</li><li>逻辑填空题</li><li>病句解析题</li></ol><p>【做题原则】</p><ol type="1"><li>带着问题选择性阅读原文<ol type="1"><li>先作答能够在文中快速明确定位有效信息的题目<ol type="1"><li>看哪个<strong>明显</strong>，直接能在文段中找到，在就近就可以看到答案的<ol type="1"><li>如：横线、代词、逻辑填空等</li></ol></li><li>综合分析、<strong>通读文章</strong><ol type="1"><li>如：主旨概括题、意图判断题、细节判断题</li></ol></li></ol></li></ol></li><li>关注文章、段落六大要点<ol type="1"><li>文章、段落<code>首尾句</code></li><li>每个段落<strong>首句之间</strong>的关系</li><li>转折、递进、结论、条件等引出主题句和观点</li><li>标点符号引出的语句信息：<ol type="1"><li>分号、顿号 <strong>并列关系</strong></li><li>双引号 <code>反语、援引、强调</code></li><li>问号 <strong>设问、疑问、反问</strong></li><li>破折号、冒号 <strong>解释说明</strong></li></ol></li><li>援引中的<code>正向</code>援引</li><li>略读：人名、数字、英文、术语。</li></ol></li></ol><p>【篇章范例一】</p><p><strong>知识</strong>经济的发展无疑给发展中国家带来赶超发达国家的巨大机遇（如可以借鉴发达国家 的经验，缩短工业化阶段的进程，即发挥后发优势），但同时也使这些国家面临严峻挑战。</p><p><strong>挑战</strong>首先来自“知识”这一生产要素本身。经济学家保罗·罗默指出，知识的生产、应用 和扩散的效率与知识的积累及人力资本正相关。而正是在这两点，发展中国家同发达国家存 在着巨大差距，这种差距虽然使发展中国家在知识的选择和应用方面可以有较大的回旋余地， 但同时使得他们与发达国家在国际分工中因位势的不同形成垂直分工的关系，因而处于不利 地位，甚至随着新的技术壁垒的形成而形成新的“中心—依附”关系，加大贫富差距。例如， 有迹象表明，近 20 年来，在全球的收入分配方面，情况逐渐恶化。从 1960 年到 80 年代末， 世界人均国民生产总值（以购买力平价计算）的基尼系数呈上升趋势，从 1960 年的 0.44 到 1989 年的 0.55。又据统计，世界最富的 20%的人口的所得收入与最穷的 20%的人口的收入 比从 1960 年的 11.1∶1 增加到 1989 年的 17.1∶1。可见，全球增长的好处并没有平均扩散 到所有国家，贫富差距还在加大。正如托夫勒所说：“知识的分配比武器和财富的分配更不 平等。因此知识（尤其是关于知识的知识）的重新分配更加重要。它能改变其他主要权力资 源的分配。”</p><p><strong>挑战</strong>更来自自身准备的不足，因为 。知识经济对于已完成工业化的发达国家而 言是生产力发展的自然结果，顺理成章；对于首先要通过工业化改变二元经济结构的发展中 国家而言，则意味着要不甘落后、抓住机遇，就必须将工业化与知识化两步并作一步走，即 如果说在上一个百年，后发国家还有可能通过加速工业化过程追赶发达国家，那么在当今新 的世纪交替之际，由于科学技术的加速发展以及科技进步转化为经济增长的过程不断加快， 后发国家已经没有了从容实现工业化的可能。发展中国家面临的挑战显然更加严峻。</p><p><strong>中国</strong>正处在从计划经济向社会主义市场经济体制转变的过程中，这使得在应对知识经济 的挑战、加速发展的同时，还必须完成制度的变革，因而任务异常艰巨。</p><p><strong>我们</strong>初步实现了邓小平同志提出的“三步走”战略的前两步目标，正在开始实施第三步战 略。与前两步战略相比，第三步战略不是自己和自己的比较，不是要达到“温饱”“小康”这样 相对明确的指标，而是要“达到中等发达国家水平”。这是一个更加开放的、[a]指标，因而也 是一个更加艰巨的任务。</p><p><strong>目前</strong>，与发达国家相比，我国还没有摆脱传统产业的束缚，经济增长方式仍以外延扩张为主，以消耗稀缺自然资源和污染环境为代价。尽管我们多次强调“经济增长方式的根本转 变”，但是，以高技术为产业支柱，以智力资源为主要的新型经济，还没有成为我国内涵式 经济增长方式的主题，就全国范围而言，以高科技为基础的第三产业就业人员占全国就业人 员总数不到 5%，其产值占国内生产总值不到 15%，以知识密集型为主的服务贸易出口占全 部出口不到 10%。但是，这并不意味着中国不具备发展知识经济的条件。就整体而言，由于 中国东西部经济发展的非均衡性，东部沿海地区某些大城市在某些方面还是具有发展知识经 济的条件的。</p><p><code>1. 知识经济对于发展中国家的挑战主要来自（ ）。</code></p><ol type="1"><li>知识的生产、应用和扩散的效率与知识的积累及人力资本正相关</li><li>发展中国家在知识的积累和人力资本方面落后于发达国家</li><li>发展中国家面临更多的制度问题</li><li>发展中国家自身准备不足</li></ol><p><code>2. 与知识经济比较而言，工业化经济发展最大的弊端是（ ）。</code></p><ol type="1"><li>消耗稀缺的资源、污染环境</li><li>造成了全球贫富差距过大</li><li>形成了技术壁垒</li><li>无法拉开发达与发展中国家的差距</li></ol><p><code>3. 从对待机遇的角度看，发展中国家应当如何应对知识经济的挑战？（ ）</code></p><ol type="1"><li>注意知识的积累</li><li>工业化和知识化并进</li><li>发展新型经济</li><li>快速实现体制改变</li></ol><p><code>4. 下列说法，不符合全文意思的一项是（ ）。</code></p><ol type="1"><li>知识经济是以知识为基础的经济，它的核心在于创新</li><li>知识经济既有正面效应，也有负面效应</li><li>当代经济的发展紧密地依赖知识的生产、传播和应用</li><li>知识在现代经济发展中对其他资源具有强大支配力、控制力、渗透力</li></ol><p><code>5. 下列对我国的现状描述正确的一项是（ ）。</code></p><ol type="1"><li>我国东部广大沿海地区已经具备发展知识经济的某些有利条件</li><li>我国只有西部地区还没有摆脱传统产业的束缚</li><li>我国西部地区没有以高技术为产业支柱的新型经济</li><li>中国部分地区已经初步具备发展知识经济的条件</li></ol><p><code>6. 文中[a]处应填入的词语是（ ）。</code></p><ol type="1"><li>艰巨的</li><li>活跃的</li><li>紧迫的</li><li>动态的</li></ol><p><code>7．下列选项适合作为本文结束语的一项是（)</code></p><ol type="1"><li>知识经济的时代已经来临</li><li>总之，面对知识经济带来的挑战，我们必须认真对待</li><li>总之，我们必须发展知识经济</li><li>知识经济真是让人欢喜，让人忧呀</li></ol><p><code>8．根据上文，下列对基尼系数表述不正确的一项是（)</code></p><ol type="1"><li>基尼系数为 0，则表示收入分配完全平等</li><li>基尼系数是衡量分配平等程度的指标</li><li>基尼系数越高，收入的差距则越悬殊</li><li>基尼系数是最富有人群的收入和最贫困人群收入的比值</li></ol><p><code>9．下列选项中，适合填在文中横线上的一项是（ ）。</code></p><ol type="1"><li>路遥知马力</li><li>磨刀不误砍柴工</li><li>机会只偏爱有准备者</li><li>只有站在巨人的肩上才能看得更远</li></ol><p><span id="inline-purple"> 解题步骤: 先确定问题、先容后难、拆解为小题目 </span></p><ol type="1"><li>先读题目，确定哪些先做后做</li><li>先写可以不通读解决的题目</li><li>读题目的时候，遇到某个问题，就回头再看下题目，再继续读</li></ol><p><strong>答案</strong> 1-5 DABAD 5-9 DBDC</p>]]></content>
      
      
      <categories>
          
          <category> 公考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 言语理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>言语理解-考点1</title>
      <link href="/2020/05/10%E8%A8%80%E8%AF%AD%E7%90%86%E8%A7%A3-%E8%80%83%E7%82%B92/"/>
      <url>/2020/05/10%E8%A8%80%E8%AF%AD%E7%90%86%E8%A7%A3-%E8%80%83%E7%82%B92/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/05/10言语理解-考点2/../../../images/photos/2020/012.jpg" width="80%"> <span class="geyan"> 望时而待之，孰与应时而使之。（《荀子·天论》） </span> <a id="more"></a></p><h2 id="第一节-片段阅读">第一节 片段阅读</h2><h3 id="主旨概括--关联词语">主旨概括--关联词语</h3><blockquote><p>言语理解中的重点 基础、重点</p></blockquote><p>✅<code>标志</code></p><ol type="1"><li>这段话主要讲述（谈论、强调、说明、阐明、阐述、介绍）的是？</li><li>这段文字的主旨、关键词、中心议题、旨在说明什么？</li><li>对这段文字的<code>概括（复述、归纳、总结）</code>最准确的是？</li></ol><p>🚩做题的原则</p><ol type="1"><li>找题眼，文段主题句</li><li>对比选项进行转换，【同意替换、精简压缩】</li><li>通常为对策或核心观点<ol type="1"><li>题眼为问题，找对策</li><li>题眼为观点，归纳核心观点</li></ol></li><li>优选忠于原文的题眼的选项。</li></ol><p>🚩解题技巧</p><ol type="1"><li>宏观--<code>行文脉络</code>--&gt; 文章结构</li><li>微观--<code>关联词</code> --&gt; 逻辑标志</li></ol><p><img src="/2020/05/10言语理解-考点2/04.png" style="zoom: 50%;"></p><h4 id="转折复句">转折复句</h4><p>【典型格式】</p><p>➢ 虽然……但是……</p><p>➢ 其实=事实上=实际上=只是=当然</p><p>【关联词语】 ➢ 虽然=尽管=虽说=固然</p><p>➢ 但是=可是=不过=然而=却</p><p>【总结】</p><p><code>重点在转折之后</code></p><p><img src="/2020/05/10言语理解-考点2/05.png" style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/05.png" style="zoom: 50%;"></p><h4 id="结论复句">结论复句</h4><p>【典型格式】</p><p>因为……所以……</p><p>【关联词语】</p><p>➢ 因为=由于</p><p>➢ 所以=因此=因而=可见=看来=导致=造成=<code>使得</code>=致使=总之=故而=<code>言而总之</code>=综上所述=概而言之=<code>概而论之</code></p><p>【特殊格式】</p><p><code>之所以……是因为。..</code> ===&gt; <code>强调原因</code></p><p>【典型例句】</p><ol type="1"><li>物价上涨关系到每一个消费者的切身利益，影响着相当一部分普通百姓的日常生活，并且可能给低收入家庭带来沉重压力。<code>因此</code>对物价上涨不能掉以轻 心。</li></ol><p>2.《淮南子·人间训》云：“众人皆知利利而病病，唯圣人知病之为利，利之为病 也。”<code>看来</code>古人已经注意到利弊的辩证关系。</p><p><img src="/2020/05/10言语理解-考点2/07.png" title="答案：D" style="zoom: 50%;"></p><p><code>于是</code>的作用</p><ol type="1"><li>结论</li><li>顺城时间、背景；</li></ol><p><img src="/2020/05/10言语理解-考点2/08.png" title="答案：D" style="zoom: 50%;"></p><h4 id="递进复句">递进复句</h4><p>【典型格式】</p><p>不但……而且…… 如：大别山区不但矿产很丰富，而且自然景色很美。</p><p>【关联词语】</p><p>➢ 不但=不仅=不单=不独=不只=不光</p><p>➢ 而且=并=并且=也=还</p><p>➢ 甚至=更=特别=尤其=重要的是=关键的是=核心的是</p><p>【多重递进】</p><p>不但……而且……甚至……</p><p>【典型例句】</p><ol type="1"><li>黄金<code>不只</code>是一种名贵的金属，<code>也是一种不需要翻译的万能语言</code>。</li><li>寿昌<code>不仅</code>学习戏里的唱腔身段，<code>还从母亲那里弄些碎布学剪戏中的人物</code>。</li><li>来这家大型食品超市购物的不仅有当地的家庭主妇，而且有附近街区的居民，<code>甚至京津地区也有驱车前来采购的</code>。</li></ol><p>【总结】</p><ol type="1"><li>递进复句重点在递进之后</li><li>一级递进与二级递进同时出现，<code>二级递进是重点</code></li></ol><p><img src="/2020/05/10言语理解-考点2/09.png" title="答案：C" style="zoom: 50%;"></p><p>这个题目的答案是 C，<code>但是选择了 D，是因为看到了最后一句话</code></p><p>经过对比</p><ol type="1"><li>要说的是雷锋相关，D 项说的是人们</li><li>任何时代，这个过于夸大</li><li>在 C、D 中选择，C 项更合适。</li></ol><p><img src="/2020/05/10言语理解-考点2/10.png" title="自己的思路" style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/11.png" title="答案：D" style="zoom: 50%;"></p><p>✅解题过程</p><ol type="1"><li>确定了主题词--汽车行业，递进-不仅-而且，重点在后边，</li><li>得出结论 汽车行业 &amp; 相关产业 的关系。</li></ol><p>❌错误分析</p><ol type="1"><li>整体找的重点没有错</li><li>递进之后很长，需要概括，不能直接取其中一部分，就要对比选项。</li><li>A B 是部分，C 是背景</li><li>D 是完整的<code>概括递进之后的内容</code></li></ol><h4 id="必要条件复句">必要条件复句</h4><p>【典型格式】</p><p>只有…【<code>重点</code>】…才……</p><p>【关联词语】</p><p>显性：只有=必须=<code>需要</code>=应该=<code>应当</code>=务必=<code>除非</code>=如何=<code>怎样</code>等</p><p>隐性：<code>才</code></p><p>【典型例句】</p><ol type="1"><li>传统相声艺术只有<code>回到群众，回归生活</code>，才能获得新的生命力。</li><li>汽车企业在发展的同时采取新的技术措施，尽量减少对环境的污染，符合社会发展大趋势，<code>才</code>是长久之策。</li></ol><p>【总结】</p><ol type="1"><li>重点是<code>必要条件</code></li><li>主要找 <code>才</code>， 显性/隐性 都在<code>才</code>之前</li></ol><p>【转换格式】</p><p><code>只有 A，才 B</code></p><p>B 必须 A = 不 A 则不 B = A 是 B 的必要条件（必备要素、不可 或缺、必不可少、前提、基础、保证、保障） = <code>B 以 A 为必要条件</code></p><p><img src="/2020/05/10言语理解-考点2/12.png" title="答案：C" style="zoom: 50%;"></p><p>✅解题过程&amp;注意事项⚠️</p><ol type="1"><li>主题词、重点位置找对了，思路也还行。</li><li>根据主题词，可以排除 A D，【可以优化思路--排除】</li><li><code>快速读题</code>有待加强</li></ol><p><img src="/2020/05/10言语理解-考点2/13.png" title="答案：B" style="zoom: 50%;"></p><h4 id="并列复句">并列复句</h4><p>【典型格式】</p><blockquote><p>既……又……</p></blockquote><p><code>申论也可以用</code></p><p>1．表示相关的几种情况<code>并存</code>。</p><p>【关联词语】</p><p>单用：而=又=同样=同时=与此同时=<code>另外</code>=此外=<code>再说</code>=并且=<code>加上</code>等。</p><p>双用：也……也；<code>又……又</code>；既……又；一边……一边；<code>有的……有的</code>；一方面…… 另一方面。</p><p>2．表示两种<code>相反或相对</code>的情况。</p><p>【关联词语】</p><p>不是……而是：不是 A，而是 B =》 A = -B</p><p>有的……有的</p><p>【表现形式】</p><ol type="1"><li>关联词语</li><li>标点符号：顿号、分号、逗号（句式一致）</li><li>表达并列内容的分句关系（隐性并列，藏于句中）</li></ol><p>【总结】</p><ol type="1"><li>重点：没有重点，主旨是 A + B</li><li>没有语序要求，可以调整前后关系</li><li>分句间的并列关系、标点负号的使用。</li></ol><p><img src="/2020/05/10言语理解-考点2/14.png" title="答案：B" style="zoom: 50%;"></p><p>✅解题过程&amp;注意事项⚠️</p><ol type="1"><li>么有找到并列的关键词</li></ol><h3 id="主旨概括--行文脉络">主旨概括--行文脉络</h3><ol type="1"><li>总--分--总<ol type="1"><li>点明观点--阐述原因/举例论证--重申观点 --&gt; <code>重点</code> 首尾句需要结合</li><li>提出问题--分析问题/举例论证--解决问题 --&gt; <code>重点</code> 解决问题</li></ol></li><li>分--总</li><li>总--分</li><li>分--总--分</li></ol><h4 id="总--分--总">总--分--总</h4><p><img src="/2020/05/10言语理解-考点2/15.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/16.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/17.png" title style="zoom: 50%;"></p><h4 id="总--分">总--分</h4><ol type="1"><li>提出观点--解释说明 --&gt; <code>重点</code> 观点</li><li>提出问题--举例论证 --&gt; <code>重点</code> 问题</li></ol><p><img src="/2020/05/10言语理解-考点2/19.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/20.png" title="答案：A" style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/21.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/22.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/24.png" title="答案：D" style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/25.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/26.png" title style="zoom: 50%;"></p><p><span id="inline-blue"> 分论点中的转折不重要 </span></p><h4 id="分--总">分--总</h4><p><img src="/2020/05/10言语理解-考点2/23.png" title="答案：A" style="zoom: 50%;"></p><h4 id="分--总--总">分--总--总</h4><p><img src="/2020/05/10言语理解-考点2/27.png"></p><p><img src="/2020/05/10言语理解-考点2/28.png" title="答案：C" style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/29.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/30.png" title style="zoom: 50%;"></p><h4 id="难度提升">难度提升</h4><blockquote><p>无关键词，需要归纳概括</p></blockquote><p><span id="inline-blue">整体概括法</span> <span id="inline-green"> 关注主体</span> <br> <span id="inline-purple">重现关键词</span> <span id="inline-yellow"> 关注重复出现的词汇</span></p><p><img src="/2020/05/10言语理解-考点2/31.png" title style="zoom: 50%;"></p><blockquote><p>提问方式变化，方法依旧</p></blockquote><ol type="1"><li>关键词语类</li><li>其他提问类</li></ol><p><img src="/2020/05/10言语理解-考点2/32.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/33.png" title style="zoom: 50%;"></p><h3 id="意图判断">意图判断</h3><blockquote><p>意图题基于主旨题</p></blockquote><p><span id="inline-purple">辨别标志</span></p><p>➢ 这段文字意在说明（阐明、强调）的是？</p><p>➢ 通过这段话，作者想表达（说明）的是？</p><p>➢ 通过这段话，我们可以知道？</p><p>➢ 这段话告诉我们？</p><p>➢ 从这段文字中可以推出的是？</p><p>➢ 根据这段文字，可以看出作者的意图是？</p><p><span id="inline-blue">做题原则</span></p><ol type="1"><li>通读原文，把握文段重点</li><li><code>优选</code> 作者的 <code>目的、意图、出发点</code></li><li><code>次选</code> 主旨类型的答案</li><li>排除<code>引申过度</code>、<code>表意肤浅</code>、不符合生活规律、社会主旋律的选贤</li></ol><p><span id="inline-yellow">社会现象类</span></p><h4 id="社会现象类">社会现象类</h4><ol type="1"><li>消极社会问题--针对<code>现象、问题</code>找<code>对策</code></li><li>积极/中性社会问题--总结归纳观点</li></ol><p><img src="/2020/05/10言语理解-考点2/34.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/35.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/36.png" title style="zoom: 50%;"></p><p><span id="inline-green">错误分析</span></p><ol type="1"><li>没有按步骤解题<ol type="1"><li>通读+重点：<code>高房价 生活质量 90后</code></li><li>围绕重点，D项扩大了范围</li><li><strong>意图题选项都得看👀</strong></li></ol></li></ol><p><img src="/2020/05/10言语理解-考点2/37.png" title style="zoom: 50%;"></p><h4 id="故事寓意类">故事寓意类</h4><ol type="1"><li>寓意主体往往在故事<code>3/4</code>处的结尾有所反应，常有<code>于是、后来</code>的词引出故事的高潮；</li><li>寓意选项要与文段关联</li></ol><p><img src="/2020/05/10言语理解-考点2/38.png" title="有趣， 选择：B" style="zoom: 50%;"></p><p>C有点过度了，主要是幽默。</p><p><img src="/2020/05/10言语理解-考点2/39.png" title="有趣， 选择：A" style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/40.png" title="有趣， 选择：D" style="zoom: 50%;"></p><h4 id="排除选项">排除选项</h4><p><img src="/2020/05/10言语理解-考点2/41.png" title style="zoom: 50%;"></p><h4 id="意图判断主旨化两个并非一个标准">意图判断主旨化——两个并非，一个标准</h4><p><img src="/2020/05/10言语理解-考点2/42.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/44.png" title style="zoom: 50%;"></p><h3 id="态度观点">态度观点</h3><p>【辨别标志】</p><p>➢ 作者支持的观点是？</p><p>➢ 作者认为 XXXX 有无道理/是否正确？</p><p>➢ 作者对 XXXX 的态度是？</p><p>➢ 符合作者观点/原意的一项是？</p><p>➢ 下列说法与文章作者态度不符合的是？</p><p>【做题原则】</p><ol type="1"><li>明确观点：提炼引导词 + 抓住关联词<ol type="1"><li>笔者认为、XX认为、我希望等</li></ol></li><li>隐含观点：提炼倾向性<ol type="1"><li>关联词、设问、含有倾向性的词、反问【你怎么能这样】</li></ol></li><li>没有观点：仅为客观陈述<ol type="1"><li>没有任何评价</li></ol></li></ol><p>【杂糅观点的特殊句式】</p><ol type="1"><li>笔者认为A <code>有观点</code>， 至于 B <code>无观点</code> 就见人见智了</li><li>无论A <code>无观点</code> 怎么样，B <code>有观点</code>都怎么样</li></ol><p><img src="/2020/05/10言语理解-考点2/45.png" title="答案 D" style="zoom: 50%;"></p><blockquote><p>这一类题目，仔细分析主旨</p></blockquote><h3 id="细节理解">细节理解</h3><blockquote><p>认真读！ 认真读！</p></blockquote><p>【题目类型】</p><p>➢ 典型的细节理解题</p><p>➢ 主旨化的细节理解题</p><p>【辨别标志】</p><p>➢ 下列说法正确/不正确的一项是？</p><p>➢ 下列表述符合/不符合文意的一项是？</p><p>➢ 下列理解正确/有误的一项是？</p><p>【做题原则】</p><ol type="1"><li>错误选项的特点<ol type="1"><li>无中生有</li><li>曲解文意</li><li>概念混搭</li></ol></li></ol><p><img src="/2020/05/10言语理解-考点2/46.png" title style="zoom: 50%;"></p><h4 id="偷换概念">偷换概念</h4><p>➢ 偷换时态</p><ol type="1"><li>已然性时态：已经、曾经、了、过去、虽然。。。但是<code>【已经发生】</code></li><li>未然性时态：将、要、立即、马上、如果、即使。。也<code>【将要发生】</code></li><li>进行式时态：正、正在、在。。中、现在、着</li></ol><p><img src="/2020/05/10言语理解-考点2/47.png" title style="zoom: 50%;"></p><blockquote><p>任何时态上的偷换，直接就是❌错误！</p></blockquote><p>➢ 偷换数量</p><ol type="1"><li>较多量：较多、许多、大量、大多数、一片、不少等</li><li>较少量：较少、很少、少量、不多</li><li>中间量：某些、一些、部分</li></ol><p><img src="/2020/05/10言语理解-考点2/48.png" title style="zoom: 50%;"></p><p>➢ 偷换逻辑关系</p><ol type="1"><li>充分条件和必要条件的混淆</li><li>因果倒置</li><li>并列混淆为条件或因果关系</li></ol><p><img src="/2020/05/10言语理解-考点2/49.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/50.png" title style="zoom: 50%;"></p><p>➢ 偷换概念/话题</p><p><img src="/2020/05/10言语理解-考点2/51.png" title style="zoom: 50%;"></p><p>➢ 偷换确定性表述与不确定性表述</p><ol type="1"><li>不确定性表达：预测、断言、推测、可能、未必、也许、大概、大约</li><li><strong>科技说明文</strong></li></ol><p><img src="/2020/05/10言语理解-考点2/53.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/54.png" title style="zoom: 50%;"></p><h4 id="主旨化的细节理解题">主旨化的细节理解题</h4><ol type="1"><li>正确表述是对于整个文段的归纳概括</li><li>错误表述是对于原文句子的偷换和曲解</li></ol><p><img src="/2020/05/10言语理解-考点2/55.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/56.png" title style="zoom: 50%;"></p><p><strong>问号</strong></p><ol type="1"><li>设问：有问有答案</li><li>反问：没有回答，但已经回答了</li><li>疑问：提问</li></ol><h4 id="变形的细节理解题">变形的细节理解题</h4><ol type="1"><li>原因考查类：属于原因、不属于原因<ol type="1"><li>了解文段陈述的状况，然后根据<code>“因为、由于” "因此、所以"</code>等词去判断</li></ol></li><li>目的考查类：主要是为了满足、主要作用、其目的是<ol type="1"><li>寻找<code>为了、目的是、其作用为、结果是、</code>等标志词</li></ol></li><li>特点考查类： 最突出的特点、区别主要体现在、差异是<ol type="1"><li>对比陈述主体特征、进行归纳概括</li></ol></li><li>信息推断类：提问方式差异较大<ol type="1"><li>特定语句寻找</li></ol></li></ol><p><img src="/2020/05/10言语理解-考点2/57.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/58.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/59.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/61.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/62.png" title style="zoom: 50%;"></p><h2 id="第二节-语句表达">第二节 语句表达</h2><h3 id="词句理解题">词句理解题</h3><p>【题目类型】</p><ol type="1"><li>词语理解题</li><li>语句理解题<ol type="1"><li>名言警句：短 + 常识判断</li><li>划线语句：小语境</li></ol></li></ol><p>【辨别标志】</p><ol type="1"><li>文中“XXX”如何理解？</li><li>“XXX”指的是？</li></ol><p>【做题原则】</p><ol type="1"><li>定位原文，有效利用<code>冒号、破折号以及关联词</code></li><li>根据<code>上下文、前后句</code>的小语境推测词语含义</li><li>排除<code>字面意思</code></li></ol><p><img src="/2020/05/10言语理解-考点2/63.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/64.png" title style="zoom: 50%;"> <img src="/2020/05/10言语理解-考点2/65.png" title style="zoom: 50%;"> <img src="/2020/05/10言语理解-考点2/66.png" title style="zoom: 50%;"></p><h3 id="词语指代题">词语指代题</h3><p>【辨别标志】</p><p>文中“XXX”<code>指代</code>的是？</p><p>【做题原则】</p><ol type="1"><li>定位原文</li><li><code>就近原则</code>，前后句的<code>主宾</code></li><li>区分类型</li><li>注意提问的提示信息</li></ol><p><img src="/2020/05/10言语理解-考点2/67.png" title="答案：D" style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/68.png" title="答案：D" style="zoom: 50%;"></p><h3 id="语句表达">语句表达</h3><p>【考查能力】</p><p>➢ 规范表达—— 病句辨析题</p><p>➢ 优化表达</p><ol type="1"><li>语句排序题</li><li>语句衔接题</li><li>下文推断题</li></ol><h4 id="语句排序题">语句排序题</h4><p>【辨别标志】</p><p>将以上 6 个句子重新排列，语序正确的是?</p><p>【做题原则】</p><p><img src="/2020/05/10言语理解-考点2/69.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/70.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/71.png" title="答案：B" style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/72.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/73.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/74.png" title style="zoom: 50%;"></p><blockquote><p>寻头不断尾＋差异句判断+紧密度验证</p></blockquote><ol type="1"><li>寻头断尾，AABC，排除BC，<strong>少数服从多数</strong></li><li>在两个AA中，找到第一个不一样的，区分，<strong>时空、关联词、重复词</strong></li></ol><blockquote><p>判断发语词 ＋ 紧密度验证</p></blockquote><ol type="1"><li>援引观点、背景铺垫、设问等常为<strong>发语词</strong></li><li>不适合做发语词<ol type="1"><li>反面论证：否则、不然、如果没有、如果不</li><li>补充类：当然、也、又</li><li>结论类：因此、所以、最终、终于</li><li>指代类表述：这、此</li></ol></li></ol><p><img src="/2020/05/10言语理解-考点2/75.png" title style="zoom: 50%;"> <img src="/2020/05/10言语理解-考点2/76.png" title style="zoom: 50%;"> <img src="/2020/05/10言语理解-考点2/77.png" title style="zoom: 50%;"> <img src="/2020/05/10言语理解-考点2/78.png" title style="zoom: 50%;"></p><p><img src="/2020/05/10言语理解-考点2/79.png" title="好好思索下" style="zoom: 50%;"></p><blockquote><p>解题思路汇总</p></blockquote><ol type="1"><li>对比1&amp;4， 两句话<strong>无法判断</strong>谁做开头</li><li>1的关键词是 【大脑🧠】，4的关键词是【研究】，进而-&gt;整体看<strong>重复词</strong>--大脑</li><li>排除 A B</li><li>1-6 &amp; 1-3 对比，<ol type="1"><li>1-3: <code>太过于紧密</code>，没有喘气的机会，没有解释1的空隙，</li><li>1-6: 紧接1的结尾--环境中有哪些威胁</li><li>6-2: 6的结尾<code>电刺激</code> -&gt; 2中的 回击、逃跑</li></ol></li><li>3中的 <strong>还</strong>， 与 6 <strong>并列</strong></li></ol><p><img src="/2020/05/10言语理解-考点2/80.png" title="好好思索下" style="zoom: 50%;"></p><blockquote><p>解题思路</p></blockquote><ol type="1"><li>对比3-5，都可以做开头</li><li><strong>假设法</strong><ol type="1"><li>假如5开头<ol type="1"><li>5-2: 但是2中的<code>也是</code>，在1中并没有做铺垫，排除D</li><li>5-3: 啰嗦：5: 屈原是。。 3: 屈原是。。排除C</li></ol></li><li>假如3开头<ol type="1"><li>3-2-1-5是相同的</li><li>看 5-4 或是 5-6<ol type="1"><li>5-4: 5的优秀和 <strong>而是</strong>接不上</li><li>5-6: 5的优秀 对应 <strong>学而优则仕</strong></li></ol></li></ol></li></ol></li><li>这道题太麻烦了。。。。</li></ol><p><img src="/2020/05/10言语理解-考点2/81.png" title="好好思索下" style="zoom: 50%;"></p><blockquote><p>解题思路</p></blockquote><ol type="1"><li>四个选项各不相同</li><li>对比选项<ol type="1"><li>3 反面论证的意思 排除B</li><li>5 总，有点像</li><li>6 假设，排除D</li><li>7 最终。。排除A</li></ol></li><li>验证C项</li><li>要求有点高啊。。。。</li></ol><p><img src="/2020/05/10言语理解-考点2/82.png" title="好好思索下" style="zoom: 50%;"></p><blockquote><p>解题思路</p></blockquote><ol type="1"><li>四个选项各不相同</li><li>对比选项<ol type="1"><li>3 这些，排除 A</li><li>5 不确定，保留</li><li>4 不是，排除C</li><li>1 不确定保留</li></ol></li><li>对比 1 - 5<ol type="1"><li>1中的新内涵 与 3中的新内涵 有关联，<strong>1-3 在一块</strong>，就可以选B了</li></ol></li><li>排序有点麻烦。。。</li></ol><h2 id="快速读题">🚩快速读题</h2>]]></content>
      
      
      <categories>
          
          <category> 公考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 言语理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>言语理解-技巧</title>
      <link href="/2020/05/09%E8%A8%80%E8%AF%AD%E7%90%86%E8%A7%A3-%E6%8A%80%E5%B7%A71/"/>
      <url>/2020/05/09%E8%A8%80%E8%AF%AD%E7%90%86%E8%A7%A3-%E6%8A%80%E5%B7%A71/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/05/09言语理解-技巧1/../../../images/photos/2020/011.jpg" width="80%"></p><p><span class="geyan"> 有兼听之明，而无奋矜之容；有兼覆之厚，而无伐德之色。（《荀子·正名》） </span> <a id="more"></a></p><h1 id="言语理解-技巧">言语理解-技巧</h1><blockquote><p>如果你可以把一个复杂的事物通俗的讲出来，就是真的理解了。</p></blockquote><p>鉴于言语理解题量大【30道】&amp; 正确率低【60% ↓】&amp; 没有整体与部分的概念</p><p>必须重来一遍，形成资料分析的那种思维。</p><h2 id="技巧一-分步解题">技巧一 分步解题</h2><p><strong>这个技巧是贯穿全部的重点，是一种思维方式</strong></p><p><img src="/2020/05/09言语理解-技巧1/05.png" style="zoom: 50%;"></p><h2 id="技巧二-压缩替换法">技巧二 压缩替换法</h2><blockquote><p>长句转短句</p></blockquote><ol type="1"><li>长句转换为短句</li><li>依赖于关联词</li></ol><p><img src="/2020/05/09言语理解-技巧1/07.png" style="zoom: 50%;"></p><p><img src="/2020/05/09言语理解-技巧1/06.png" style="zoom: 50%;"></p><h2 id="技巧三-成分分析法">技巧三 成分分析法</h2><blockquote><p>理解长难句</p></blockquote><p>长难句找 <strong>主谓宾</strong>，宾语通常是一个复合结构或小句。</p><blockquote><p>标志词, 每个句子都可以分开找重点</p></blockquote><ol type="1"><li>的----定语（前置）</li><li>地----状语（前置）</li><li>得----补语（后置）</li></ol><p><img src="/2020/05/09言语理解-技巧1/08.png" style="zoom: 50%;"> <img src="/2020/05/09言语理解-技巧1/09.png" title="答案：C" style="zoom: 50%;"> <img src="/2020/05/09言语理解-技巧1/10.png" title="答案：D" style="zoom: 50%;"></p><h2 id="技巧四-背景铺垫法">技巧四 背景铺垫法</h2><p>背景为了引出重点，背景不重要</p><p><img src="/2020/05/09言语理解-技巧1/11.png" title="答案：A" style="zoom: 50%;"> <img src="/2020/05/09言语理解-技巧1/12.png" title style="zoom: 50%;"> <img src="/2020/05/09言语理解-技巧1/13.png" title style="zoom: 50%;"></p><h2 id="技巧五-主体排除法">技巧五 主体排除法</h2><blockquote><p>选项的陈述主体要与原文保持一致</p></blockquote><p>什么是主体？</p><ol type="1"><li>可以是主语</li><li>文章围绕这个东西展开，类似：主题。</li></ol><p>找到主体后，就可以直接排除一些选项。</p><ol type="1"><li>找主体</li><li>排除非主体选项</li><li>对比剩余选项差异</li><li>从题干中找关键词 与 第三步 对比</li></ol><p><img src="/2020/05/09言语理解-技巧1/14.png" title="答案：D" style="zoom: 50%;"> <img src="/2020/05/09言语理解-技巧1/15.png" style="zoom: 50%;"></p><p><img src="/2020/05/09言语理解-技巧1/16.png" title="答案：B" style="zoom: 50%;"></p><p><img src="/2020/05/09言语理解-技巧1/17.png" style="zoom: 50%;"></p><p>视频中排除A B 后，直接根据 <strong>厂家</strong> 二字排除 D。。。</p><p>## 技巧六 指代引导法</p><p>文章中有出现 <strong>宏观指代</strong>【指代上文的宏观内容】，则该句重要，往往承担文段的主要观点。</p><p>🔺并非所有的代词都重要！ <strong>必须是宏观指代</strong></p><p><img src="/2020/05/09言语理解-技巧1/18.png" style="zoom: 50%;"> <img src="/2020/05/09言语理解-技巧1/19.png" style="zoom: 50%;"> <img src="/2020/05/09言语理解-技巧1/20.png" style="zoom: 50%;"></p><h2 id="技巧七-援引观点法">技巧七 援引观点法</h2><blockquote><p>引出来的是重点！</p></blockquote><ol type="1"><li>作用：为了引出之后作者的观点，重点阅读援引之后的语句</li><li>类型<ol type="1"><li>正向援引：正如 XXXX， 因此/所以</li><li>反向援引：一家之言【有人、大多数人、有看法、通常、传统。。】 <strong>然而、但是等</strong></li></ol></li></ol><table><thead><tr class="header"><th></th><th>前半句</th><th>后半句</th></tr></thead><tbody><tr class="odd"><td>正向援引</td><td>正如 XXXX</td><td>因此/所以</td></tr><tr class="even"><td>反向援引</td><td>一家之言 <br> 【有人、大多数人、有看法、通常、传统】</td><td>然而、但是等</td></tr></tbody></table><p>🔺🔺 <img src="/2020/05/09言语理解-技巧1/21.png" style="zoom: 50%;"></p><p><img src="/2020/05/09言语理解-技巧1/22.png" style="zoom: 50%;"></p><p><img src="/2020/05/09言语理解-技巧1/23.png" style="zoom: 50%;"></p><h2 id="技巧八-表达倾向性">技巧八 表达倾向性</h2><ol type="1"><li>注意把握文中的表达倾向性</li><li>类型<ol type="1"><li>积极的倾向性</li><li>消极的倾向性<ol type="1"><li>从表面上看</li><li>看上去</li><li>似乎、好像</li><li>所谓</li><li>遗憾的是</li></ol></li></ol></li></ol><blockquote><p>积极的 =》 上箭头 ⬆️ 消极的 =》 下箭头 ⬇️</p></blockquote><p><img src="/2020/05/09言语理解-技巧1/24.png" style="zoom: 50%;"></p><p><img src="/2020/05/09言语理解-技巧1/25.png" style="zoom: 50%;"></p><h2 id="技巧九-举例论证法">技巧九 举例论证法</h2><ol type="1"><li>作用<ol type="1"><li>为了证明【前后】出现的观点，例子本身不重要，可以忽略或快速浏览</li><li>围绕例子的选项不是主旨题的答案</li></ol></li><li>类型<ol type="1"><li>显性：比如、例如、XX就是一个例证、以XX为例</li><li>隐性：数据、年份、人名、地名、术语。</li></ol></li></ol><p><img src="/2020/05/09言语理解-技巧1/26.png" style="zoom: 50%;"></p><p><img src="/2020/05/09言语理解-技巧1/27.png" style="zoom: 50%;"></p><p><img src="/2020/05/09言语理解-技巧1/28.png" style="zoom: 50%;"></p><h2 id="技巧十-反面论证法">技巧十 反面论证法</h2><ol type="1"><li>作用<ol type="1"><li>为了说明证明观点的权威性与合理性</li></ol></li><li>类型<ol type="1"><li>正 + 反： 不要看反面论证，直接看前面<ol type="1"><li>你今天要带伞，不带伞会淋雨【后半句不需要看】</li></ol></li><li>(正) + 反：通过反面论证退出正面观点<ol type="1"><li>如果不。。那么不。。</li><li>如果没有。。那么没有</li><li>例子<ol type="1"><li>如果不带伞就淋雨 ---&gt; 需要带伞</li></ol></li></ol></li></ol></li></ol><p><img src="/2020/05/09言语理解-技巧1/29.png" style="zoom: 50%;"></p><p><img src="/2020/05/09言语理解-技巧1/30.png" style="zoom: 50%;"></p>]]></content>
      
      
      <categories>
          
          <category> 公考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 言语理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数量关系-技巧</title>
      <link href="/2020/05/09%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB-%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/05/09%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB-%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/05/09数量关系-技巧/../../../images/photos/2020/010.jpg" width="80%"></p><p><span class="geyan"> 凡事行，有益于理者立之，无益于理者废之。（《荀子·儒效》） </span> <a id="more"></a></p><h1 id="数量关系-技巧">数量关系-技巧</h1><h2 id="第一节-解题思维">第一节 解题思维</h2><h3 id="代入排除法">代入排除法</h3><p>适用代入排除法的典型题型</p><ol type="1"><li>多位数： 几个数组成的</li><li>年龄： 选择各个年龄值</li><li>不定方程：</li><li>余数：有总数、有剩余、分东西问题</li></ol><h3 id="方程与不定方程">方程与不定方程</h3><h2 id="第二节">第二节</h2>]]></content>
      
      
      <categories>
          
          <category> 公考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数量关系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资料分析-考点</title>
      <link href="/2020/05/08%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90-%E8%80%83%E7%82%B9/"/>
      <url>/2020/05/08%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90-%E8%80%83%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/05/08资料分析-考点/../../../images/photos/2020/009.jpg" width="80%"></p><p><span class="geyan"> 言而当，知也；默而当，亦知也。（《荀子·非十二子》） </span> <a id="more"></a></p><p>[toc]</p><h1 id="常考点">常考点</h1><h2 id="第一节-增长率常考题型">第一节 增长率常考题型</h2><p>考点识别</p><ol type="1"><li>增长/减少 + %</li></ol><p>常考题型</p><ol type="1"><li>增长率计算</li><li>增长率判断</li><li>增长率大小比较</li><li>特殊增长率</li></ol><p><img src="/2020/05/08资料分析-考点/04.png"></p><p><img src="/2020/05/08资料分析-考点/05.png"></p><h3 id="增长率">增长率</h3><p>如果确定是求增长率，</p><ol type="1"><li>快速找到【基期、现期、增长量】</li><li>列公式</li><li>看选项是否需要注意量级，</li><li>选择直除、截位计算</li></ol><p><strong>遇到百分点，加减操作</strong> 低-》加 高-》减</p><p><img src="/2020/05/08资料分析-考点/06.png"></p><p><strong>解题步骤</strong></p><p><img src="/2020/05/08资料分析-考点/07.png"></p><p><img src="/2020/05/08资料分析-考点/08.png"></p><p>判断量级，画线可以根据选项来划两位、三位</p><p><img src="/2020/05/08资料分析-考点/09.png"></p><h3 id="增长率判断">增长率判断</h3><p>增长率判断、比较，题型：柱状图、条形图</p><ol type="1"><li>时间段内是否达到、超过某个数据</li></ol><p><strong>不需要全部计算完。</strong></p><p>解法</p><ol type="1"><li>确定问题</li><li>基量*比值 + 基量 对比 现量</li></ol><h3 id="增长率大小比较">增长率大小比较</h3><p><strong>变幅 = 变化幅度 = 增长率的绝对值</strong></p><h2 id="第二节-基期量常考题型">第二节 基期量常考题型</h2><p>X: 现期量 r: 增长率</p><p><span class="math display">\[\frac{X}{1+r}\]</span></p><p>考点识别：</p><p><strong>已知“现在”，求“过去”</strong></p><p>常考题型</p><ol type="1"><li>计算基期量</li><li>基期量做差</li><li>基期量比较</li></ol><h3 id="计算基期量">计算基期量</h3><ol type="1"><li>如果减可以化为乘法，</li><li>消百分号</li><li>在消小数点</li><li>因为选项差别小，所以可以仔细算</li></ol><p><img src="/2020/05/08资料分析-考点/10.png"></p><h3 id="基期量做差比较">基期量做差/比较</h3><ol type="1"><li>确定题目是基期量做差</li><li>看选项<ol type="1"><li>两组数：先算现期差</li><li>四个数：分别直除计算</li></ol></li></ol><p><img src="/2020/05/08资料分析-考点/11.png"></p><p>1-增长率化为乘：最好是增长率很小</p><p><img src="/2020/05/08资料分析-考点/12.png"></p><p><img src="/2020/05/08资料分析-考点/13.png"></p><p><img src="/2020/05/08资料分析-考点/14.png"></p><p>注意事项</p><ol type="1"><li>化除为乘，前提：减法 &amp; 增长率很小</li><li>增长倍数可以直接用</li><li>利用分数性质</li></ol><h2 id="第三节-增长量常考题">第三节 增长量常考题</h2><h3 id="公式">🚩公式</h3><p>已知 <strong>现期</strong>&amp;<strong>增长率</strong>， 求增长量。</p><p>X： 现期 r： 增长率 Z: 增长量 n: 增长率转换为 1 / n</p><p><span class="math display">\[Z = \frac{X}{r+1} * r\]</span></p><p>增长率为正数</p><p><span class="math display">\[Z = \frac{X}{n+1}\]</span></p><p>增长率为负数</p><p><span class="math display">\[Z = \frac{X}{n-1}\]</span></p><h3 id="小率">小率</h3><p><code>小于 5%</code></p><h4 id="转换分数--100-除">转换分数--100 除</h4><ol type="1"><li>1% 2% 3%</li><li>可以直接 100 / 2 = 1 / 50</li></ol><p><img src="/2020/05/08资料分析-考点/15.png"></p><h4 id="转换分数--乘-100">转换分数--乘 100</h4><p>将 2.5% 转化为分数：</p><ol type="1"><li>2.5% * 10 = 25% = 1 / 4</li><li>加 0，得 1 / 40</li></ol><p>4.X 5.X 可以乘 2。</p><p>掌握不熟练，可以用上一种方式</p><h3 id="大率">大率</h3><p><code>超过 50%</code></p><h4 id="直除求基期">直除求基期</h4><h3 id="特殊情况">特殊情况</h3><h4 id="分数取中间">分数取中间</h4><ol type="1"><li>某个增长率化接近两个两个分数<ol type="1"><li>选项差别大，取哪个分数都行，如 图 15</li><li>选项值接近，取两个分数中间的，如 图 16</li></ol></li></ol><figure><img src="/2020/05/08资料分析-考点/15.png" alt><figcaption>图 15</figcaption></figure><figure><img src="/2020/05/08资料分析-考点/16.png" alt><figcaption>图 16</figcaption></figure><h4 id="增长量倍数">增长量倍数</h4><blockquote><p>可以分别求增长量，也不慢</p></blockquote><figure><img src="/2020/05/08资料分析-考点/17.png" alt><figcaption>图 17</figcaption></figure><h3 id="增长量大小比较">🚩增长量大小比较</h3><p>识别：大小比较、排序</p><blockquote><p>口诀：大大则大，一大一小看倍数</p></blockquote><figure><img src="/2020/05/08资料分析-考点/18.png" alt><figcaption>图 18</figcaption></figure><blockquote><p>特殊情况：</p></blockquote><ol type="1"><li>【增长率如果大于<code>50%</code>】<ol type="1"><li>大大则大</li><li>【一大一小就不要用口诀！】</li></ol></li><li>不能用口诀，就用直除，图：19</li><li>倍数相近也不可以用口诀。</li></ol><figure><img src="/2020/05/08资料分析-考点/19.png" alt><figcaption>图 19 直除技巧</figcaption></figure><h4 id="绝对值问题">绝对值问题</h4><figure><img src="/2020/05/08资料分析-考点/20.png" alt><figcaption>图 20</figcaption></figure><blockquote><p>增率 10% 以内【负数】，大于 10%，就直除</p></blockquote><figure><img src="/2020/05/08资料分析-考点/21.png" alt><figcaption>图 21</figcaption></figure><h2 id="第四节-比重常考题型">第四节 比重常考题型</h2><blockquote><p>识别：</p></blockquote><ol type="1"><li>A【部分】 <code>占</code> B【整体】 的比重</li><li>A【部分】所<code>占</code>比重</li><li>已知 整体 &amp; 比重，求部分 = 整体 * 比重</li><li>已知 部分 &amp; 比重，求整体 = 部分 / 比重</li></ol><h3 id="基本计算">基本计算</h3><figure><img src="/2020/05/08资料分析-考点/26.png" alt><figcaption>26</figcaption></figure><figure><img src="/2020/05/08资料分析-考点/27.png" alt><figcaption>概念--利润率</figcaption></figure><figure><img src="/2020/05/08资料分析-考点/28.png" alt><figcaption>概念看错</figcaption></figure><figure><img src="/2020/05/08资料分析-考点/29.png" alt><figcaption>看题目 找问题</figcaption></figure><h3 id="图--扇形">图--扇形</h3><ol type="1"><li>计算某一个部分的比重，比重 * 360˚， 扇形的圆心角度</li><li>大小关系，倍数关系</li></ol><blockquote><p>12 点顺时针看图</p></blockquote><h3 id="基期比重">🔺基期比重</h3><blockquote><p>识别：</p></blockquote><p>已知 【现在】求【过去】的比重</p><p><img src="/2020/05/08资料分析-考点/31.png" alt="识别"> <img src="/2020/05/08资料分析-考点/32.png" alt="识别"></p><blockquote><p>公式 一般只需要判断前者，后者只需要判断大于、小于 1</p></blockquote><p><img src="/2020/05/08资料分析-考点/30.png"></p><p><strong>如果不能直接判断后者，就截位直除</strong></p><h4 id="一般计算-进阶">一般计算 &amp;&amp; 进阶</h4><ul><li>一般计算</li></ul><figure><img src="/2020/05/08资料分析-考点/33.png" alt><figcaption>实例</figcaption></figure><ul><li>进阶</li></ul><p>选项特别接近 || （百分数接近&amp;很小），是<code>因为</code>后者在1附近</p><p><img src="/2020/05/08资料分析-考点/35.png" alt="实例"> <img src="/2020/05/08资料分析-考点/34.png" alt="实例--解释"> <img src="/2020/05/08资料分析-考点/36.png" alt="实例--技巧"></p><h4 id="基期变化">🔺🔺基期变化</h4><blockquote><p>现期比重 与 基期比重 做差</p></blockquote><p>识别</p><ol type="1"><li>比重的元素 + 上升、下降</li><li>比重的元素 + 上升、下降 + 百分点</li></ol><p>口诀</p><p><strong>a% &gt; b% =&gt; A/B 上升</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a%: 部分增长率</span><br><span class="line">b%: 整体增长率</span><br></pre></td></tr></table></figure><blockquote><p>部分增长率 &gt; 整体增长率，则比重上升，反之，下降。</p></blockquote><figure><img src="/2020/05/08资料分析-考点/37.png" alt><figcaption>实例--技巧</figcaption></figure><figure><img src="/2020/05/08资料分析-考点/38.png" alt><figcaption>实例--原理</figcaption></figure><figure><img src="/2020/05/08资料分析-考点/39.png" alt><figcaption>实例--读数</figcaption></figure><p>步骤</p><ol type="1"><li>判断 比重变化的方向，a% 大小对比 b%</li><li>选择<ol type="1"><li>时间不够，选【小】的</li><li>百分点 远远 小于 |a% - b%|</li></ol></li></ol><p><img src="/2020/05/08资料分析-考点/40.png"></p><figure><img src="/2020/05/08资料分析-考点/41.png" alt><figcaption>精确计算--没啥用</figcaption></figure><h2 id="第五节-平均数与倍数">第五节 平均数与倍数</h2><h3 id="平均数">平均数</h3><p>识别</p><p>平均数：</p><ol type="1"><li>平均</li><li>均</li><li>每</li><li>单位, 单位面积产量=》面积/单位</li></ol><blockquote><p>后 / 前</p></blockquote><p>每万元GDP的能耗 =》 能耗 / GDP 每单位取水量的耗水 =》 耗水 / 取水量</p><p><img src="/2020/05/08资料分析-考点/43.png"></p><h3 id="倍数">倍数</h3><blockquote><p>倍数： A是（为）B的多少倍 A / B</p></blockquote><p><img src="/2020/05/08资料分析-考点/44.png"></p><p>公式扩展</p><p><img src="/2020/05/08资料分析-考点/45.png"></p><figure><img src="/2020/05/08资料分析-考点/46.png" alt><figcaption>选择B</figcaption></figure><h2 id="蒙题技巧">🔴蒙题技巧 💯</h2><h3 id="出现多的">出现多的</h3><p><img src="/2020/05/08资料分析-考点/25.png"></p><h3 id="选小的">选小的</h3><p>比重变化 <img src="/2020/05/08资料分析-考点/42.png"></p>]]></content>
      
      
      <categories>
          
          <category> 公考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资料分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资料分析-技巧</title>
      <link href="/2020/05/07%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90-%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/05/07%E8%B5%84%E6%96%99%E5%88%86%E6%9E%90-%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/05/07资料分析-技巧/../../../images/photos/2020/008.jpg" width="80%"></p><p><span class="geyan"> 知之而不行，虽敦必困。（《荀子·儒效》） </span> <a id="more"></a></p><h1 id="速算技巧">速算技巧</h1><h2 id="第一节-速算技巧--直除法">第一节 速算技巧--直除法</h2><h3 id="解题步骤">解题步骤</h3><p>画出三要素 1. 时间 ⭕️ 2. 主体 直线 3. 关键字 三角</p><hr><p>增长量 =（ 现 / 1 + 率 ）* 率</p><hr><h3 id="材料阅读与数据查找">材料阅读与数据查找</h3><ol type="1"><li>文字材料<ol type="1"><li>时间、每段首句</li></ol></li><li>表格<ol type="1"><li>标题、横/纵标目、单元</li></ol></li><li>折线图图形<ol type="1"><li>标题、横/纵轴、图例、单位</li></ol></li><li>饼状图<ol type="1"><li>标题、单位、类别【12 点顺时针方向】</li></ol></li></ol><h3 id="常用速算技巧">常用速算技巧</h3><h4 id="直除法">直除法</h4><p>考虑的步骤</p><ol type="1"><li>看选项<ol type="1"><li>首位不同，算第一位</li><li>第二位不一样，算到第二位</li></ol></li><li>截位【需要几位算几位】<ol type="1"><li>根据第一步，决定四舍五入，取前两位/三位</li><li>截【默认截三位】<ol type="1"><li>两位：首位不同</li><li>三位：首位相同，第二位不同</li></ol></li><li>除的时候忽略小数点<ol type="1"><li>选项差 10 倍 100 关系</li></ol></li></ol></li></ol><p>4407 / 1 + 17.7%</p><ul><li>4280</li><li>3744</li><li>2983</li><li>5347</li></ul><p>截两位 <span class="math display">\[ \frac{4407}{12} \]</span></p><p>题：7.84 / 1 + 7.4%</p><p>784 / 107 = 7.3</p><p>1882.5 / 4219.1</p><p>1880 / 422 得到 45 排除 40 如果差别大，就 45</p><p><strong>特殊情况：截位&amp;小数</strong></p><p><img src="/2020/05/07资料分析-技巧/04.png"></p><p><strong>保留所有单位，取相同位数划线</strong></p><p><img src="/2020/05/07资料分析-技巧/05.png"></p><p><strong>左溢一位</strong></p><p><img src="/2020/05/07资料分析-技巧/06.png"></p><p><strong>比值问题</strong></p><p><img src="/2020/05/07资料分析-技巧/07.png"></p><h2 id="第二节-速算技巧--特殊分数化简">第二节 速算技巧--特殊分数化简</h2><p>http://latex.codecogs.com/eqneditor/editor.php</p><h3 id="特殊分数">特殊分数</h3><h4 id="背熟">背熟</h4><blockquote><p>考试可以先默写到草稿纸</p></blockquote><p>前提：背熟 分数转百分数：</p><p><span class="math display">\[\frac{1}{2} - \frac{1}{15}\]</span></p><p><strong>Plan B</strong> 当场计算</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>% = <span class="number">100</span> / <span class="number">14</span> = <span class="number">1</span>/<span class="number">7</span></span><br></pre></td></tr></table></figure><p><img src="/2020/05/07资料分析-技巧/08.png"></p><h4 id="用途一-增长量">用途一 增长量</h4><ol type="1"><li>现 &amp; 率</li></ol><p>X: 现期量 r：增率 Z：增量</p><p><span class="math display">\[Z = \frac{X}{r+1}\]</span></p><p><img src="/2020/05/07资料分析-技巧/09.png"></p><h4 id="用途二-a-b">用途二 A * B</h4><h5 id="比重-部分-整体-比重">比重 【部分 = 整体 * 比重】</h5><h5 id="现期-现-基-率">现期 【现 = 基 * 率】</h5><p><img src="/2020/05/07资料分析-技巧/10.png"></p><h3 id="分数比较">分数比较</h3><h4 id="直除法-1">直除法</h4><p>量级一致，直除计算<strong>首位</strong></p><p><strong>量级一致</strong></p><p><img src="/2020/05/07资料分析-技巧/11.png"></p><p><strong>量级不一致</strong></p><p><img src="/2020/05/07资料分析-技巧/12.png"></p><h4 id="利用分数性质">利用分数性质</h4><p>上边的问题，可以用量级计算，但是特别麻烦。采用分数性质做。</p><h5 id="大小不同">1. 大小不同</h5><p><img src="/2020/05/07资料分析-技巧/13.png"></p><p><img src="/2020/05/07资料分析-技巧/14.png"></p><h5 id="找接近">2. 找接近</h5><p><img src="/2020/05/07资料分析-技巧/15.png"></p><p><strong>分子分母都一倍多点，就直除</strong></p><p><img src="/2020/05/07资料分析-技巧/16.png"></p><h5 id="示例">3. 示例</h5><p><img src="/2020/05/07资料分析-技巧/17.png"></p><h3 id="特殊公式口诀">特殊公式口诀</h3><h4 id="化除为乘">化除为乘</h4><p>⚠️ ： <strong>5%</strong></p><p><img src="/2020/05/07资料分析-技巧/18.png"></p><p><img src="/2020/05/07资料分析-技巧/19.png"></p><h4 id="笑脸公式隔年增长率">🚩笑脸公式【隔年增长率】</h4><p>三个时间 + 两个增长率， 求隔年增长率</p><p><img src="/2020/05/07资料分析-技巧/20.png"></p><p><img src="/2020/05/07资料分析-技巧/21.png"></p><p>🚩⚠️事项</p><ol type="1"><li>乘积部分省略：【 |X%| |Y%| 均小于 10%】</li><li>增长率正负均可以使用</li><li>时间间隔--&gt;隔月也行，三个时间点两个增长率</li></ol><blockquote><p>正负问题，遇到补充</p></blockquote><p><img src="/2020/05/07资料分析-技巧/22.png"></p><p><img src="/2020/05/07资料分析-技巧/23.png"></p><h4 id="合成增长率两部分合成整体">🚩合成增长率【两部分合成整体】</h4><p><strong>整体增长率一定在于两者之间。且偏向于基数【现期量】较大的一方</strong></p><p>如果问 1-3 月的增长率，估算，两者之间。</p><p><img src="/2020/05/07资料分析-技巧/24.png"></p><p>## 第三节 🔴技巧--蒙题</p><figure><img src="/2020/05/07资料分析-技巧/25.png" alt><figcaption>蒙题技巧</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 公考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资料分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React实战系列-布局与组件【1】</title>
      <link href="/2020/04/20React%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97-%E5%B8%83%E5%B1%80%E4%B8%8E%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/04/20React%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97-%E5%B8%83%E5%B1%80%E4%B8%8E%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/04/20React实战系列-布局与组件/../../../images/photos/2020/007.jpg" width="60%"></p><p>民之从事，常于几成而败之。慎终如始，则无败事。--- 《道德经》第64章</p><a id="more"></a><blockquote><p>原本打算做的网易音乐后台要搁浅了 首先我觉得这个并不适合我</p></blockquote><p>原因有以下几个方面：</p><ol type="1"><li>跳跃过大</li><li>自定义模块过多</li></ol><p>虽说跟着一遍做一遍摸索，可以完成，但我觉得太浪费时间，终究没有个流程。</p><blockquote><p>我的目标是：</p></blockquote><ol type="1"><li>掌握数据流管理方案--redux及其配套设施；</li><li>熟悉react、react-router-dom、react-router的应用场景以及注意事项；</li><li>熟练使用antd的组件；</li><li>----完成前端应用-----</li><li>Eggjs + Mysql 提供数据服务</li><li>进一步完善前后端</li></ol><h2 id="开篇">开篇</h2><p>以上的目标打算抽时间逐步完成，这个系列博客，尽量写明白写清楚，也算是职业生涯中的值得回忆的一个成就。 因为是一边学习一边记录，所以采取由浅入深的开发流程。</p><blockquote><p>说明</p></blockquote><p>为了完成目标，确定的目标项目是开源的----<a href="https://github.com/karakal-FET/react-admin" target="_blank" rel="noopener">react-admin</a>；打算在此基础上<strong>进行改写</strong>并完成一个相对完善的后端项目。</p><p>这篇文章说明的文字较多。</p><blockquote><p>原生化</p></blockquote><ol type="1"><li>尽可能的<strong>只用</strong>原生组件，目光始终在完成需求上；</li><li>尽可能用不同的方式完成同样的需求；</li><li>尽可能好的组织代码方式</li></ol><h3 id="技术栈">技术栈</h3><p>大致分为以下几类，还会涉及其余的相关模块等，后续会在相关位置添加链接或单独写文章整理。</p><ol type="1"><li>语言：<ol type="1"><li><a href="https://www.tslang.cn/docs/handbook/basic-types.html" target="_blank" rel="noopener">TS</a>、</li><li><a href="http://lesscss.cn/" target="_blank" rel="noopener">Less</a></li></ol></li><li>React：<ol type="1"><li><a href="https://react.docschina.org/docs/getting-started.html" target="_blank" rel="noopener">React</a></li><li><a href="https://react-guide.github.io/react-router-cn/" target="_blank" rel="noopener">react-router</a></li><li><a href="https://github.com/ReactTraining/react-router/tree/master/packages/react-router-dom" target="_blank" rel="noopener">react-router-dom</a></li></ol></li><li>状态管理：<ol type="1"><li><a href="https://www.redux.org.cn/" target="_blank" rel="noopener">Redux</a></li><li><a href="https://cn.redux.js.org/docs/react-redux/" target="_blank" rel="noopener">React-Redux</a></li><li><a href="https://redux-saga-in-chinese.js.org/" target="_blank" rel="noopener">Redux-Saga</a></li><li><a href="https://github.com/immerjs/immer" target="_blank" rel="noopener">Immer</a></li></ol></li><li>UI：<ol type="1"><li><a href="https://ant.design/docs/resources-cn" target="_blank" rel="noopener">Antd</a></li><li><a href="https://www.echartsjs.com/zh/option.html#title" target="_blank" rel="noopener">echartsjs</a></li><li><a href="https://github.com/hustcc/echarts-for-react" target="_blank" rel="noopener">echarts-for-react</a></li></ol></li></ol><h3 id="疑问解答">疑问解答</h3><p>采用官方脚手架--<a href="https://www.html.cn/create-react-app/docs/getting-started/" target="_blank" rel="noopener">create-react-app</a>；</p><blockquote><p>为何不用<a href="https://dvajs.com/guide/" target="_blank" rel="noopener">dvajs</a>?</p></blockquote><p>综合性很强，但我认为应该<strong>先难后易</strong></p><blockquote><p>为何不用<a href="https://umijs.org/zh-CN/docs/getting-started" target="_blank" rel="noopener">umi</a>?</p></blockquote><p>综合性更强，仍旧认为应该<strong>先难后易</strong></p><p>学习node，我觉得先了解express，再写koa，最后采用egg 是个不错的选择。</p><blockquote><p>建议不要eject!</p></blockquote><p>初心是学习react全家桶，不是webpack【后期有空再学】, 至于less相关配置，可以<a href="https://ant.design/docs/react/use-in-typescript-cn#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98" target="_blank" rel="noopener">换个做法</a></p><h2 id="开动">开动</h2><p>由于打算写这个系列的文章的时候，基本的UI框架已经搭建好，现在就把文件目录罗列出来，并加以说明，针对这个过程中遇到的问题，会在之后一一罗列，代码中几乎都会有注释。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README\ 2.md    <span class="comment"># 说明文件</span></span><br><span class="line">├── README.md       <span class="comment"># 说明文件</span></span><br><span class="line">├── config-overrides.js     <span class="comment"># less 相关配置</span></span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── public      <span class="comment"># 资源文件</span></span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── logo192.png</span><br><span class="line">│   ├── logo512.png</span><br><span class="line">│   ├── manifest.json</span><br><span class="line">│   └── robots.txt</span><br><span class="line">├── src         <span class="comment"># 代码区</span></span><br><span class="line">│   ├── App.less        <span class="comment"># 布局文件</span></span><br><span class="line">│   ├── App.test.tsx    <span class="comment"># 测试文件</span></span><br><span class="line">│   ├── App.tsx         <span class="comment"># 入口布局</span></span><br><span class="line">│   ├── Page.tsx        <span class="comment"># 入口文件</span></span><br><span class="line">│   ├── components          <span class="comment">#组件</span></span><br><span class="line">│   │   ├── HeaderCustom.tsx    <span class="comment"># 头部组件</span></span><br><span class="line">│   │   ├── SiderCustom.tsx     <span class="comment"># 侧边栏</span></span><br><span class="line">│   │   ├── SiderMenu.tsx       <span class="comment"># 侧边栏菜单</span></span><br><span class="line">│   │   ├── forms                   <span class="comment"># 文件夹--表单</span></span><br><span class="line">│   │   ├── index.tsx           <span class="comment"># 组件统一导出文件</span></span><br><span class="line">│   │   ├── pages               <span class="comment"># 单页面，如404</span></span><br><span class="line">│   │   └── widget              <span class="comment"># 小组件，如copyright</span></span><br><span class="line">│   ├── containers  <span class="comment"># 容器组件</span></span><br><span class="line">│   │   └── XXX     <span class="comment"># 后期会增加</span></span><br><span class="line">│   ├── images  <span class="comment"># 图片</span></span><br><span class="line">│   ├── index.css</span><br><span class="line">│   ├── index.tsx <span class="comment"># 入口配置文件</span></span><br><span class="line">│   ├── react-app-env.d.ts <span class="comment"># .d.ts文件</span></span><br><span class="line">│   ├── redux   <span class="comment"># redux 相关</span></span><br><span class="line">│   │   ├── configureStore.ts <span class="comment"># 统一配置redux</span></span><br><span class="line">│   │   └── modules <span class="comment"># redux modules 文件夹</span></span><br><span class="line">│   ├── routes  <span class="comment"># 路由配置文件夹</span></span><br><span class="line">│   │   ├── config.ts   <span class="comment"># 路由的配置文件</span></span><br><span class="line">│   │   └── index.tsx   <span class="comment"># 遍历配置文件，并初始化路由</span></span><br><span class="line">│   ├── serviceWorker.ts</span><br><span class="line">│   ├── setupTests.ts</span><br><span class="line">│   ├── style   <span class="comment"># 样式文件夹</span></span><br><span class="line">│   │   ├── antd</span><br><span class="line">│   │   ├── imgs</span><br><span class="line">│   │   └── index.less</span><br><span class="line">│   ├── test.js</span><br><span class="line">│   └── utils   <span class="comment"># 小功能</span></span><br><span class="line">│       ├── antdValidate.ts</span><br><span class="line">│       └── index.ts</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure><p>采用 <a href="https://www.html.cn/create-react-app/docs/adding-typescript/" target="_blank" rel="noopener">Create React App TS</a>.</p><h3 id="步骤一-初始化">步骤一 初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- 初始化</span></span><br><span class="line">$ npx create-react-app react-project --typescript</span><br><span class="line">$ <span class="comment"># 或者</span></span><br><span class="line">$ yarn create react-app react-project --typescript</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- TS相关依赖</span></span><br><span class="line">$ npm install --save typescript @types/node @types/react @types/react-dom @types/jest</span><br><span class="line">$ <span class="comment"># 或者</span></span><br><span class="line">$ yarn add typescript @types/node @types/react @types/react-dom @types/jest</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 启动</span></span><br><span class="line">$ <span class="built_in">cd</span> react-project</span><br><span class="line">$ npm start</span><br></pre></td></tr></table></figure><p>以上构建好&amp;启动了项目。</p><h3 id="步骤二-下载相关依赖">步骤二 下载相关依赖</h3><p>其实应该用到啥配置啥，这样更能明白，但是现在只能罗列下，建文件夹、下载、、、都太简单了. &gt; 换个思路，把目前需要的包罗列出来，然后逐步完善代码。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认生成的文件</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"react-project"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"@ant-design/icons"</span>: <span class="string">"^4.0.6"</span>,</span><br><span class="line">    <span class="attr">"@testing-library/jest-dom"</span>: <span class="string">"^4.2.4"</span>,</span><br><span class="line">    <span class="attr">"@testing-library/react"</span>: <span class="string">"^9.5.0"</span>,</span><br><span class="line">    <span class="attr">"@testing-library/user-event"</span>: <span class="string">"^7.2.1"</span>,</span><br><span class="line">    <span class="attr">"@types/jest"</span>: <span class="string">"^24.9.1"</span>,</span><br><span class="line">    <span class="attr">"@types/node"</span>: <span class="string">"^12.12.36"</span>,</span><br><span class="line">    <span class="attr">"@types/react"</span>: <span class="string">"^16.9.34"</span>,</span><br><span class="line">    <span class="attr">"@types/react-dom"</span>: <span class="string">"^16.9.6"</span>,</span><br><span class="line">    <span class="attr">"antd"</span>: <span class="string">"^4.1.4"</span>,</span><br><span class="line">    <span class="attr">"react"</span>: <span class="string">"^16.13.1"</span>,</span><br><span class="line">    <span class="attr">"react-dom"</span>: <span class="string">"^16.13.1"</span>,</span><br><span class="line">    <span class="attr">"react-redux"</span>: <span class="string">"^7.2.0"</span>,</span><br><span class="line">    <span class="attr">"react-router-config"</span>: <span class="string">"^5.1.1"</span>,</span><br><span class="line">    <span class="attr">"react-router-dom"</span>: <span class="string">"^5.1.2"</span>,</span><br><span class="line">    <span class="attr">"react-scripts"</span>: <span class="string">"3.4.1"</span>,</span><br><span class="line">    <span class="attr">"redux"</span>: <span class="string">"^4.0.5"</span>,</span><br><span class="line">    <span class="attr">"redux-thunk"</span>: <span class="string">"^2.3.0"</span>,</span><br><span class="line">    <span class="attr">"typescript"</span>: <span class="string">"^3.7.5"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;  <span class="comment">// 下边会更改这个部分</span></span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"react-scripts start"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"react-scripts build"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"react-scripts test"</span>,</span><br><span class="line">    <span class="attr">"eject"</span>: <span class="string">"react-scripts eject"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"eslintConfig"</span>: &#123;</span><br><span class="line">    <span class="attr">"extends"</span>: <span class="string">"react-app"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"browserslist"</span>: &#123;</span><br><span class="line">    <span class="attr">"production"</span>: [</span><br><span class="line">      <span class="string">"&gt;0.2%"</span>,</span><br><span class="line">      <span class="string">"not dead"</span>,</span><br><span class="line">      <span class="string">"not op_mini all"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"development"</span>: [</span><br><span class="line">      <span class="string">"last 1 chrome version"</span>,</span><br><span class="line">      <span class="string">"last 1 firefox version"</span>,</span><br><span class="line">      <span class="string">"last 1 safari version"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>目前为止，配置文件内容</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"react-project-ts"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"@ant-design/icons"</span>: <span class="string">"^4.0.6"</span>,</span><br><span class="line">    <span class="attr">"@testing-library/jest-dom"</span>: <span class="string">"^4.2.4"</span>,</span><br><span class="line">    <span class="attr">"@testing-library/react"</span>: <span class="string">"^9.5.0"</span>,</span><br><span class="line">    <span class="attr">"@testing-library/user-event"</span>: <span class="string">"^7.2.1"</span>,</span><br><span class="line">    <span class="attr">"@types/echarts"</span>: <span class="string">"^4.4.6"</span>,</span><br><span class="line">    <span class="attr">"@types/jest"</span>: <span class="string">"^24.9.1"</span>,</span><br><span class="line">    <span class="attr">"@types/node"</span>: <span class="string">"^12.12.36"</span>,</span><br><span class="line">    <span class="attr">"@types/react"</span>: <span class="string">"^16.9.34"</span>,</span><br><span class="line">    <span class="attr">"@types/react-dom"</span>: <span class="string">"^16.9.6"</span>,</span><br><span class="line">    <span class="attr">"@types/react-redux"</span>: <span class="string">"^7.1.7"</span>,</span><br><span class="line">    <span class="attr">"@types/react-router-config"</span>: <span class="string">"^5.0.1"</span>,</span><br><span class="line">    <span class="attr">"@types/react-router-dom"</span>: <span class="string">"^5.1.4"</span>,</span><br><span class="line">    <span class="attr">"@types/redux-thunk"</span>: <span class="string">"^2.1.0"</span>,        <span class="comment">// 以上都是针对ts的</span></span><br><span class="line">    <span class="attr">"antd"</span>: <span class="string">"^4.1.4"</span>,       <span class="comment">// antd</span></span><br><span class="line">    <span class="attr">"babel-plugin-import"</span>: <span class="string">"^1.13.0"</span>,   <span class="comment">// 按需加载组件代码和样式的 babel 插件， 对应的是 config-overrides.js</span></span><br><span class="line">    <span class="attr">"customize-cra"</span>: <span class="string">"^0.9.1"</span>,   <span class="comment">// 加载 less 样式； 配置config-overrides.js</span></span><br><span class="line">    <span class="attr">"echarts"</span>: <span class="string">"^4.7.0"</span>,  <span class="comment">// 百度图表</span></span><br><span class="line">    <span class="attr">"echarts-for-react"</span>: <span class="string">"^2.0.15-beta.1"</span>, <span class="comment">// 百度图表 react版本</span></span><br><span class="line">    <span class="attr">"less"</span>: <span class="string">"^3.11.1"</span>,      <span class="comment">// less</span></span><br><span class="line">    <span class="attr">"less-loader"</span>: <span class="string">"^5.0.0"</span>,    <span class="comment">// less 加载</span></span><br><span class="line">    <span class="attr">"react"</span>: <span class="string">"^16.13.1"</span>,</span><br><span class="line">    <span class="attr">"react-app-rewired"</span>: <span class="string">"^2.1.5"</span>, <span class="comment">// 对 create-react-app 的默认配置进行自定义，更改的是 package.json 中的scripts：start、build、test</span></span><br><span class="line">    <span class="attr">"react-dom"</span>: <span class="string">"^16.13.1"</span>,</span><br><span class="line">    <span class="attr">"react-redux"</span>: <span class="string">"^7.2.0"</span>,    <span class="comment">// react &lt;-&gt; redux</span></span><br><span class="line">    <span class="attr">"react-router-config"</span>: <span class="string">"^5.1.1"</span>,    <span class="comment">// 路由配置</span></span><br><span class="line">    <span class="attr">"react-router-dom"</span>: <span class="string">"^5.1.2"</span>,</span><br><span class="line">    <span class="attr">"react-scripts"</span>: <span class="string">"3.4.1"</span>,</span><br><span class="line">    <span class="attr">"redux"</span>: <span class="string">"^4.0.5"</span>,</span><br><span class="line">    <span class="attr">"redux-logger"</span>: <span class="string">"^3.0.6"</span>, <span class="comment">// 日志</span></span><br><span class="line">    <span class="attr">"redux-thunk"</span>: <span class="string">"^2.3.0"</span>,    <span class="comment">// 异步</span></span><br><span class="line">    <span class="attr">"typescript"</span>: <span class="string">"^3.7.5"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"react-app-rewired start"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"react-app-rewired build"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"react-app-rewired test"</span>,</span><br><span class="line">    <span class="attr">"eject"</span>: <span class="string">"react-scripts eject"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"eslintConfig"</span>: &#123;</span><br><span class="line">    <span class="attr">"extends"</span>: <span class="string">"react-app"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"browserslist"</span>: &#123;</span><br><span class="line">    <span class="attr">"production"</span>: [</span><br><span class="line">      <span class="string">"&gt;0.2%"</span>,</span><br><span class="line">      <span class="string">"not dead"</span>,</span><br><span class="line">      <span class="string">"not op_mini all"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"development"</span>: [</span><br><span class="line">      <span class="string">"last 1 chrome version"</span>,</span><br><span class="line">      <span class="string">"last 1 firefox version"</span>,</span><br><span class="line">      <span class="string">"last 1 safari version"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结，这部分主要添加一些所需模块，没啥东西。</p><h4 id="注意事项">⚠️注意事项</h4><blockquote><p>疑问1🤔️： 如何按需加载antd组件？</p></blockquote><ol type="1"><li>babel-plugin-import：<ol type="1"><li>目标：按需引用antd</li><li>如何做：<a href="https://ant.design/docs/react/use-in-typescript-cn#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98" target="_blank" rel="noopener">antd说明--搜：babel-plugin-import</a></li></ol></li></ol><blockquote><p>疑问2🤔️：如何加载less文件？？</p></blockquote><ol type="1"><li>react-app-rewired<ol type="1"><li>目标：自定义启动服务</li><li>如何做：<a href="https://ant.design/docs/react/use-in-typescript-cn#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98" target="_blank" rel="noopener">antd说明--搜react-app-rewired</a></li></ol></li></ol><p>针对这两个问题，由于只是配置，仔细看下<a href="https://ant.design/docs/react/use-in-typescript-cn#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98" target="_blank" rel="noopener">antd说明</a><strong>完全可以搞定。</strong></p><p>本来写了个demo，感觉太简单了，没必要。。。</p><h3 id="步骤三-自定义布局">步骤三 自定义布局</h3><blockquote><p>这个部分主要采用antd的布局方式</p></blockquote><p>常规布局，<strong>sider、header、 content、footer</strong></p><p>侧边栏布局效果如下</p><figure><img src="/2020/04/20React实战系列-布局与组件/03.png" alt><figcaption>整体布局与首页</figcaption></figure><h3 id="步骤四-表单页面">步骤四 表单页面</h3><figure><img src="/2020/04/20React实战系列-布局与组件/04.png" alt><figcaption>表单页面</figcaption></figure><p>之后单文件的注意事项会在代码首部写明，便于之后复习。 因为表单页面场景比较多，结合注册登录页面将常规使用、触发，模拟触发交互数据的动作，过程中主要遇到的问题</p><h4 id="注意事项-1">⚠️注意事项</h4><ol type="1"><li>函数组件路由如何跳转?<ol type="1"><li>路由跳转的几种方式：<ol type="1"><li>路由组件<ol type="1"><li>this.props.history.push()</li></ol></li><li>非路由组件 ✍️<ol type="1"><li>useHistory: react-router-dom中的hook--useHistory(): 可以获取到history</li><li>withRouter: 添加withRouter，参数中包含props</li></ol></li></ol></li></ol></li><li>函数组件中form如何在antion中获取到/验证 form value?<ol type="1"><li>✍️ 利用Form.useForm()，可以获取到form, 进一步获取到form.validateFields()、form.getFieldValue('phone')</li><li>验证方法<ol type="1"><li>点击实例代码看控制台</li><li>看代码中的注释</li></ol></li></ol></li></ol><h2 id="代码链接">代码链接</h2><p>这篇文章跨度有点大，但是并不涉及数据流相关操作，故不懂的就看代码吧，里边有注释，其中还有些布局问题，先解决大问题，具体细节之后再修仔补。</p><blockquote><p>之后的章节都会以不同的分支作为与文章对应的代码。</p></blockquote><h3 id="代码">代码</h3><p>仓库： git@github.com:simuty/react-project.git 分支： origin/chapter1/step2</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22React实战系列-介入数据管理【2】</title>
      <link href="/2020/04/22React%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97-%E4%BB%8B%E5%85%A5%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
      <url>/2020/04/22React%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97-%E4%BB%8B%E5%85%A5%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/04/22React实战系列-介入数据管理/../../../images/photos/2020/007.jpg" width="60%"></p><p>民之从事，常于几成而败之。慎终如始，则无败事。--- 《道德经》第64章</p><a id="more"></a><h3 id="目标">目标</h3><ol type="1"><li>redux</li><li>redux-saga</li><li>immer</li><li>normalizr</li></ol><p>第一节结合antd搭建了页面框架、常见的表单、列表等，侧重点在于UI层面，完整的项目离不开<strong>UI与数据流</strong>，这节开始介入数据管理，之后根据具体的需求，综合开发；</p><p>这个部分内容量有点大，尽可能明朗一些。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Redux </tag>
            
            <tag> Redux-Saga </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express Koa Redux 中间件对比</title>
      <link href="/2020/04/16%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%BE%83/"/>
      <url>/2020/04/16%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/04/16中间件比较/../../../images/photos/2020/006.jpg" width="80%"></p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = compose</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middleware</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 每个中间件都是一个 generator or async , 接收 【context 和 next】 两个参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>))</span><br><span class="line">      index = i</span><br><span class="line">      <span class="comment">// 取出第 index 个中间件并执行</span></span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">      <span class="comment">// 如果所有中间件都执行完跳出，并返回一个 Promise</span></span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 每个中间件都是一个 generator or async , 接收 context 和 next 两个参数</span></span><br><span class="line">        <span class="comment">// 每个中间件调用都会在 next 调用处卡住知道递归执行下一个 dispatch ，取出下一个中间件</span></span><br><span class="line">        <span class="comment">// 这样只有后面的中间件的 dispatch resolve掉，前面的中间件才会继续执行，最外层的 dispatch(0) 才会 resolve 掉</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看源码可以得出：</p><ol type="1"><li><p>dispatch方法是递归调用；</p></li><li><p>最重要的一行</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br></pre></td></tr></table></figure><p>一步步解读</p><ol type="1"><li><strong>fn</strong> ： 是指中间件，即函数，包含（context 和 next）两个参数；</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间件实例</span></span><br><span class="line"><span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'B--'</span>)</span><br><span class="line">  next()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'--B'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><p><strong>context</strong> ： 不作处理，直接采用外部传进来的；</p></li><li><p><strong>dispatch.bind(null, i + 1)</strong>：下一个中间件；</p></li></ol><p>因为dispatch是<code>递归调用</code>，进入下次调用，获取到中间件。</p><h3 id="执行步骤">执行步骤</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// koa 实例</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A_M = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'A--'</span>)</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'--A'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> B_M = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'B--'</span>)</span><br><span class="line">  next()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'--B'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> C_M = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'C--'</span>)</span><br><span class="line">  ctx.body = <span class="string">'hello'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'--C'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(A_M);</span><br><span class="line">app.use(B_M);</span><br><span class="line">app.use(C_M);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">5000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请打开: http://127.0.0.1:5000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol type="1"><li>dispatch(0)，Promise.resolve(fn(context, dispatch.bind(null, 0 + 1)))执行，第一个中间件内容将一直运行到 <code>await next()</code></li><li>执行<code>await next()</code>， next() = dispatch.bind(null, 0 + 1)，这是第二个中间件</li><li>第二个中间件将一直运行到 await next()</li><li>next()= dispatch.bind(null, 1 + 1)，这是第三个中间件</li><li>第三中间件将一直运行到 await next()</li><li>next()= dispatch.bind(null, 2 + 1)，没有第四种中间件，它将立即返回if (!fn) return Promise.resolve()，</li><li>await next()在第三个中间件中解析后，执行第三种中间件中的剩余代码。</li><li>await next()在第二中间件resolve了，剩余的则执行第二中间件的代码。</li><li>await next()在第一中间件resolve了，剩下的是执行在第一中间件代码。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这也就让我们看到了next函数到底是什么，是dispatch.bind(null, i + 1)。也正是通过dispatch将控制权移交给了下一个中间件。在use中await next()正式将控制权移交给下一个中间件，第一个 =&gt; 第二个 =&gt; ... =&gt; 最后一个，当最后一个中间件执行完毕时，此时，开始执行栈将当前栈顶执行环境出栈，最后一个 =&gt; 倒数第二个 =&gt; ... =&gt;第一个。也就形成了洋葱模型。</span><br><span class="line"></span><br><span class="line">作者：菩提谛听</span><br><span class="line">链接：</span><br><span class="line">来源：掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>next方法相当于dispatch.bind(null, i+1),如果中间件不调用next()方法的话，程序执行流将会中断，说的直白一点就是下面一个中间件只有声明的机会却没有执行的机会</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> koa入口文件，<span class="string">`new Koa`</span> -&gt; <span class="string">`use(中间件)`</span>-&gt; <span class="string">`listen()`</span></span><br><span class="line"><span class="number">2.</span> listen回调函数中会触发**compose**</span><br><span class="line">   <span class="number">1.</span> 生成[A_M, B_M, C_M]数组；</span><br><span class="line"><span class="number">3.</span> 调用递归函数, 以下步骤主要涉及：**洋葱模型**</span><br><span class="line">   <span class="number">1.</span> 调用dispatch(<span class="number">0</span>), 获取到：<span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, <span class="number">0</span> + <span class="number">1</span>))); 即获取中间件 A_M;</span><br><span class="line">   <span class="number">2.</span> 输出中间件中的：A--</span><br><span class="line">   <span class="number">3.</span> 触发中间件中的： <span class="keyword">await</span> next(), 因为<span class="string">`next() = dispatch.bind(null, 0 + i)`</span></span><br><span class="line">   <span class="number">4.</span> 回调<span class="number">3.1</span> dispatch(<span class="number">1</span>), 得到中间件 B_M;</span><br><span class="line">   <span class="number">5.</span> 执行<span class="number">3.2</span> <span class="number">3.3</span>;</span><br><span class="line">   <span class="number">6.</span></span><br></pre></td></tr></table></figure><p>参考链接 <a href="https://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">JavaScript 的 this 原理</a> <a href="https://segmentfault.com/a/1190000016843275" target="_blank" rel="noopener">傻瓜式解读koa中间件处理模块koa-compose</a> <a href="https://juejin.im/post/5e19beca5188252c6c477b94" target="_blank" rel="noopener">koa-compose源码解读</a> <a href="http://perkinzone.cn/2017/08/15/Redux,Koa,Express%E4%B9%8Bmiddleware%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94/#2-koa%E7%9A%84middleware%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">Redux,Koa,Express之middleware机制对比</a> <a href="https://www.jianshu.com/p/70fb2405b281" target="_blank" rel="noopener">Express, Koa, Redux中间件的区别,写法和执行流程</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redux </tag>
            
            <tag> Express </tag>
            
            <tag> Koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React实战系列-网易音乐&lt;1&gt;</title>
      <link href="/2020/04/15React%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97-%E7%BD%91%E6%98%93%E9%9F%B3%E4%B9%901%20copy%202/"/>
      <url>/2020/04/15React%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97-%E7%BD%91%E6%98%93%E9%9F%B3%E4%B9%901%20copy%202/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/04/15React实战系列-网易音乐1 copy 2/../../../images/photos/2020/006.jpg" width="80%"></p><a id="more"></a><blockquote><p>声明 本系列参考<a href="https://juejin.im/book/5da96626e51d4524ba0fd237" target="_blank" rel="noopener">React Hooks 与 Immutable 数据流实战</a>完成，每一章节都将整合：遇到的问题、个人思考、知识点汇总等。 在原有代码之上进行了修改。</p></blockquote><p>目标</p><ol type="1"><li>本系列目标<ol type="1"><li><p>熟悉前端开发流程</p></li><li><p>熟练掌握一种框架目录结构，熟练使用 React+Router+Redux 相关插件</p></li><li><p>掌握Redux数据流及其相关，如immer</p></li><li><p><strong>不打算掌握布局相关</strong>，因为实例不允许。。。</p></li></ol></li><li>本文目标<ol type="1"><li><p>构建项目、目录结构划分</p></li><li><p>router-config配置、react-thunk基本使用</p></li><li><p>、PureComponent+memo+Component相关</p></li><li><p>接入redux、immer使用</p></li></ol></li></ol><h1 id="第一部分-初始化">第一部分 初始化</h1><p>代码会放在<a href>github</a>上，以不同的分支来区分。</p><blockquote><p>该部分不属于重点</p></blockquote><h2 id="构建项目以及目录结构">构建项目以及目录结构</h2><p>采用<a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">Create React App</a>进行构建。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>整理目录结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├─api                   <span class="comment">// 网路请求代码、工具类函数和相关配置</span></span><br><span class="line">├─application           <span class="comment">// 项目核心功能</span></span><br><span class="line">│   └── Singers         <span class="comment">// 其中一个实例</span></span><br><span class="line">│       ├── index.js    <span class="comment">// 该路由入口文件</span></span><br><span class="line">│       ├── store       <span class="comment">// 存储相关</span></span><br><span class="line">│       │   ├── actionCreators.js   <span class="comment">// action 获取数据相关</span></span><br><span class="line">│       │   ├── constants.js    <span class="comment">// 常量</span></span><br><span class="line">│       │   ├── index.js    <span class="comment">// 导出配置</span></span><br><span class="line">│       │   └── reducer.js  <span class="comment">// reduer 接受action请求，整合数据，触发更新UI</span></span><br><span class="line">│       └── style.js</span><br><span class="line">├─assets                <span class="comment">// 字体配置及全局样式</span></span><br><span class="line">├─baseUI                <span class="comment">// 基础 UI 轮子</span></span><br><span class="line">├─components            <span class="comment">// 可复用的 UI 组件</span></span><br><span class="line">├─routes                <span class="comment">// 路由配置文件</span></span><br><span class="line">└─store                 <span class="comment">// redux 相关文件</span></span><br><span class="line">  App.js                <span class="comment">// 根组件</span></span><br><span class="line">  index.js              <span class="comment">// 入口文件</span></span><br><span class="line">  serviceWorker.js      <span class="comment">// PWA 离线应用配置</span></span><br><span class="line">  style.js              <span class="comment">// 默认样式</span></span><br></pre></td></tr></table></figure><p>该部分主要是采用了独立文件夹的方式存放文件、目录作用域划分等操作。属于习惯问题。</p><h2 id="第二部分-让框架跑起来">第二部分 让框架跑起来</h2><p>该项目包含react+router+redux+dom等主要模块的引用，故，如何安排相应的模块以及配置是个问题。</p><h3 id="router-config">router-config</h3><p>首先配置路由，在浏览器中可以见到不同的URL对应不同的页面，在此主要贴代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="comment">// 第一步，引用配置</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderRoutes &#125; <span class="keyword">from</span> <span class="string">'react-router-config'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">            &lt;HashRouter&gt;</span><br><span class="line">                &#123;renderRoutes(routes)&#125;</span><br><span class="line">            &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Provider&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="react-router-config究竟做了什么">react-router-config究竟做了什么？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// !源码</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Switch, Route &#125; <span class="keyword">from</span> <span class="string">"react-router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRoutes</span>(<span class="params">routes, extraProps = &#123;&#125;, switchProps = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> routes ? (</span><br><span class="line">    &lt;Switch &#123;...switchProps&#125;&gt;</span><br><span class="line"><span class="comment">// !主要是这句！</span></span><br><span class="line">      &#123;routes.map(<span class="function">(<span class="params">route, i</span>) =&gt;</span> (</span><br><span class="line">        &lt;Route</span><br><span class="line">          key=&#123;route.key || i&#125;</span><br><span class="line">          path=&#123;route.path&#125;</span><br><span class="line">          exact=&#123;route.exact&#125;</span><br><span class="line">          strict=&#123;route.strict&#125;</span><br><span class="line">          render=&#123;props =&gt;</span><br><span class="line">            route.render ? (</span><br><span class="line">              route.render(&#123; ...props, ...extraProps, <span class="attr">route</span>: route &#125;)</span><br><span class="line">            ) : (</span><br><span class="line">              &lt;route.component &#123;...props&#125; &#123;...extraProps&#125; route=&#123;route&#125; /&gt;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">  ) : null;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default renderRoutes;</span></span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="comment">// renderRoutes 这个方法只渲染一层路由, 需要在【父】【component】中加 &#123;renderRoutes(routes)&#125;</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">exact</span>: <span class="literal">true</span>, <span class="attr">render</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&#123;</span>'/<span class="attr">page1</span>'&#125; /&gt;</span></span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/page1'</span>, <span class="attr">component</span>: Page1 &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/page2'</span>,</span><br><span class="line">        component: Page2,</span><br><span class="line">        routes: [</span><br><span class="line">            &#123;</span><br><span class="line">                path: <span class="string">'/page2/child'</span>,</span><br><span class="line">                component: Child,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;HashRouter&gt;</span><br><span class="line">            &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">                &lt;h1&gt;Hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &#123;renderRoutes(routes)&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="注意事项">注意事项</h4><ol type="1"><li><p>renderRoutes只渲染一层，故包含子路由的需要，需要在【父】【component】中加 {renderRoutes(routes)}</p></li><li><p>哈希路由 <code>#</code>, 是否重新获取资源？</p></li></ol><h3 id="component-vs-purecomponent-vs-memo">Component VS PureComponent VS memo</h3><blockquote><p>整个部分涉及React优化性能内容</p></blockquote><p>React核心开发团队一直都努力地让React变得更快。在React中可以用来优化组件性能的方法大概有以下几种: 1. 组件懒加载(React.lazy(...)和 <suspense>) 2. PureComponent 3. shouldComponentUpdate(...){...} 生命周期函数 4. React.memo()</suspense></p><h4 id="component-vs-purecomponent">Component VS PureComponent</h4><ol type="1"><li>默认Component遇到state Props 变化时，父子组件都更新。</li><li>Component通过shouldComponentUpdate生命周期函数进行判断是否更新组件；</li><li>PureComponent组件<strong>没有</strong>shouldComponentUpdate生命周期函数，组件内部自动判断时候需要更新。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>._compositeType === CompositeTypes.PureClass) &#123;</span><br><span class="line">  shouldUpdate = !shallowEqual(prevProps, nextProps) || ! shallowEqual(inst.state, nextState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React源码中很容易看到：shadowEqual只会"浅"检查组件的props和state，这就意味着嵌套对象和数组是不会被比较的。</p><p>PureComponent适合用于5展示的组件。</p><h4 id="purecomponent-vs-memo">PureComponent VS memo</h4><p>函数组件没有state、shouldComponentUpdate，故无法采用 <strong>生命周期｜｜自动浅比较</strong>的方式。</p><blockquote><p>React v16.6 引入 React.memo()</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// !需求》：现在有一个显示时间的组件,每一秒都会重新渲染一次</span></span><br><span class="line"><span class="comment">// ?对于Child组件我们肯定不希望也跟着渲染，所有需要用到PureComponent || React.momo()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parent</span></span><br><span class="line"><span class="keyword">import</span> React  <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            date : <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                date:<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Child seconds=&#123;<span class="number">1</span>&#125;/&gt;</span><br><span class="line">                &lt;div&gt;&#123;<span class="keyword">this</span>.state.date.toString()&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Child</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">&#123;seconds&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am rendering'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;I am update every &#123;seconds&#125; seconds&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;*&#125; prevProps 组件将会接收的下一个参数props</span><br><span class="line"> * @param &#123;*&#125; nextProps 组件的下一个状态state </span><br><span class="line"> * @returns</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">function areEqual(prevProps, nextProps) &#123;</span></span><br><span class="line"><span class="regexp">    if (prevProps.seconds === nextProps.seconds) &#123;</span></span><br><span class="line"><span class="regexp">        return true;</span></span><br><span class="line"><span class="regexp">    &#125; else &#123;</span></span><br><span class="line"><span class="regexp">        return false;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 第一个参数为纯函数的组件，</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 第二个参数用于对比props控制是否刷新，</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/      与shouldComponentUpdate()功能类似。</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default React.memo(Child, areEqual);</span></span><br><span class="line"><span class="regexp">/</span>* -------- React.memo ----------- *<span class="regexp">/</span></span><br></pre></td></tr></table></figure><p>PureComponent 🆚 VS 🆚 memo</p><ul><li>React.PureComponent是银</li><li>React.memo(...)是金</li><li>React.PureComponent是给ES6的类组件使用的</li><li>React.memo(...)是给函数组件使用的</li><li>React.PureComponent减少ES6的类组件的无用渲染</li><li>React.memo(...)减少函数组件的无用渲染</li></ul><h4 id="redux-devtools-extension-调试工具">redux-devtools-extension 调试工具</h4><p><a href="http://extension.remotedev.io/" target="_blank" rel="noopener">redux-devtools-extension 官网</a></p><figure><img src="/2020/04/15React实战系列-网易音乐1 copy 2/09.png" alt><figcaption>redux-devtools-extension</figcaption></figure><p><img src="/2020/04/15React实战系列-网易音乐1 copy 2/10.png" alt="使用说明"> 图片来源：https://blog.csdn.net/achenyuan/article/details/80884895</p><h2 id="第三部分-数据链路">第三部分 数据链路</h2><p>redux在之前的文章中已经有过学习，包含了主要的步骤以及概念。可以参考前几天的<a href="https://simuty.com/2020/04/10React%E7%B3%BB%E5%88%97-Redux/">----React系列-Redux&lt;2&gt;</a>。</p><p>可以参考下册两个图，加以回忆。</p><figure><img src="/2020/04/15React实战系列-网易音乐1 copy 2/04.gif" alt><figcaption>流程</figcaption></figure><figure><img src="/2020/04/15React实战系列-网易音乐1 copy 2/03.png" alt><figcaption>代码主要步骤</figcaption></figure><p>按照之前的理解就可以直接上手，初始化 action -&gt; dispatch -&gt; reducer =&gt; new state =&gt; update UI.</p><p>其中有个问题，如何 <strong>高效</strong> 的处理state事关 <strong>性能优劣</strong>。前一节，对<a href="https://simuty.com/2020/04/13React%E7%B3%BB%E5%88%97-immutable%E4%B8%8A%E4%B8%8B%E6%96%87/"></a></p><h3 id="react-redux-react-redux">react &amp; redux &amp; react-redux</h3><p>三者之间的关系可以看下册官方说明</p><ol type="1"><li>React：负责组件的UI界面渲染；</li><li>Redux：数据处理中心； <a href="https://redux.js.org/introduction/getting-started" target="_blank" rel="noopener">redux 官网</a></li><li>React-Redux：连接组件和数据中心，也就是把React和Redux联系起来。 <a href="https://react-redux.js.org/" target="_blank" rel="noopener">react-redux 官网</a></li></ol><figure><img src="/2020/04/15React实战系列-网易音乐1 copy 2/05.jpg" alt><figcaption>回顾下react生命周期</figcaption></figure><figure><img src="/2020/04/15React实战系列-网易音乐1 copy 2/06.jpg" alt><figcaption>redex核心</figcaption></figure><p><strong>React-Redux</strong></p><p>Redux 本身和React没有关系，只是数据处理中心，是React-Redux让他们联系在一起。</p><p>React-Redux提供两个方法： 1. connect: connect连接React组件和Redux store。connect实际上是一个<strong>高阶函数</strong>，返回一个新的已与Redux store连接的<strong>容器组件</strong>。</p><ol start="2" type="1"><li>Provider: 实现store的全局可访问，将store传给每个组件。<strong>原理</strong>：使用React的context，context可以实现跨组件之间的传递。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VisibleTodoList = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(TodoList)</span><br></pre></td></tr></table></figure><p>复制代码TodoList是 <strong>UI 组件</strong>，VisibleTodoList就是由 react-redux 通过connect方法自动生成的<strong>容器组件</strong>。</p><ol type="1"><li>mapStateToProps：从Redux状态树中提取需要的部分作为props传递给当前的组件。</li><li>mapDispatchToProps：将需要绑定的响应事件（action）作为props传递到组件上。</li></ol><figure><img src="/2020/04/15React实战系列-网易音乐1 copy 2/07.jpg" alt><figcaption>connent</figcaption></figure><h4 id="三者之间的关系">三者之间的关系</h4><figure><img src="/2020/04/15React实战系列-网易音乐1 copy 2/08.jpg" alt><figcaption>关系</figcaption></figure><h3 id="redux-thunk">redux-thunk</h3><p><a href="https://github.com/reduxjs/redux-thunk" target="_blank" rel="noopener">redux-thunk</a> With a plain basic Redux store, you can only do simple synchronous updates by dispatching an action. Middleware extend the store's abilities, and let you write async logic that interacts with the store.</p><p>Thunks are the recommended middleware for basic Redux side effects logic, including complex synchronous logic that needs access to the store, and simple async logic like AJAX requests.</p><p>学习 https://zhuanlan.zhihu.com/p/85403048</p><h2 id="第四部分-注意事项">第四部分 注意事项⚠️</h2><p>函数组件<code>mapStateToProps</code>拿到的数据是整个state 普通组件<code>mapStateToProps</code>拿到的数据是createRouter()中的reducer导出的默认值。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Redux </tag>
            
            <tag> Immer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React系列-immutable上下文&lt;4&gt;</title>
      <link href="/2020/04/13React%E7%B3%BB%E5%88%97-immutable%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2020/04/13React%E7%B3%BB%E5%88%97-immutable%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/04/13React系列-immutable上下文/01.jpg" width="80%"></p><p>真正的无知不是知识的贫乏, 而是拒绝获取知识! ——波普尔 (哲学家 思想家)</p><a id="more"></a><blockquote><p>优化之减少渲染</p></blockquote><h1 id="目标">目标</h1><ul><li>diff算法</li><li>优化方式</li><li>Immutable以及替代品【重点】</li></ul><p>文章流程 &gt; React -&gt; 遇到问题 -&gt; 优化 -&gt; 优化方式 -&gt; 原理以及选择</p><h2 id="第一部分-diff算法以及问题">第一部分 diff算法以及问题</h2><p>React 采用的是虚拟 DOM (即 VDOM )，每次属性 (props) 和状态 (state) 发生<strong>变化</strong>的时候，render 函数返回不同的元素树，React 会检测当前返回的元素树和上次渲染的元素树之前的差异，然后针对差异的地方进行更新操作，最后渲染为真实 DOM，这就是整个 Reconciliation 过程，其<strong>核心就是进行新旧 DOM 树对比的 diff 算法。</strong></p><figure><img src="/2020/04/13React系列-immutable上下文/03.jpg" alt><figcaption>03</figcaption></figure><blockquote><p>为了获得更优秀的性能，首当其冲的工作便是 <strong>减少 diff</strong> 的过程，那么在保证应该更新的节点能够得到更新的前提下，这个 diff 的过程如何来避免呢？</p></blockquote><p>答案是利用 shouldComponentUpdate 这个生命周期函数。这个函数做了什么事情呢？</p><figure><img src="/2020/04/13React系列-immutable上下文/02.jpg" alt><figcaption>Diff 原理全解析</figcaption></figure><h2 id="第二部分-解决方案">第二部分 解决方案</h2><p>由第一部分中的流程图以及生命周期函数shouldComponentUpdate可知，如果想要<strong>该渲染的时候才渲染</strong>，就只能在此做操作。</p><blockquote><p>重点就在于：属性 (props) 和状态 (state) 什么时候发生变化。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> PureComponent (memo) 进行浅层比较</span><br><span class="line"><span class="number">2.</span> shouldComponentUpdate 中进行深层比对</span><br><span class="line"><span class="number">3.</span> immutable 数据结构 + SCU (memo) 浅层比对</span><br></pre></td></tr></table></figure><h3 id="深浅比较">深浅比较</h3><p>PureComponent (memo) 进行<strong>浅层比较</strong>。源码中有段代码中，一旦<strong>属性的值为引用类型</strong>的时候浅比较就失灵了。这种方式仅仅适用于无状态组件或者状态数据非常简单的组件，对于大量的应用型组件，它是无能为力的。</p><p>那么，如果在shouldComponentUpdate进行<strong>深层比较</strong>，即全比较，如果数据量大，则性能损耗严重。</p><blockquote><p>怎么解决这个问题?</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span> (<span class="params">objA: mixed, objB: mixed</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 下面的 is 相当于 === 的功能，只是对 + 0 和 - 0，以及 NaN 和 NaN 的情况进行了特殊处理</span></span><br><span class="line">  <span class="comment">// 第一关：基础数据类型直接比较出结果</span></span><br><span class="line">  <span class="keyword">if</span> (is (objA, objB)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第二关：只要有一个不是对象数据类型就返回 false</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> objA !== <span class="string">'object'</span> ||</span><br><span class="line">    objA === <span class="literal">null</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> objB !== <span class="string">'object'</span> ||</span><br><span class="line">    objB === <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第三关：在这里已经可以保证两个都是对象数据类型，比较两者的属性数量</span></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="built_in">Object</span>.keys (objA);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="built_in">Object</span>.keys (objB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keysA.length !== keysB.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第四关：比较两者的属性是否相等，值是否相等</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !hasOwnProperty.call (objB, keysA [i]) ||</span><br><span class="line">      !is (objA [keysA [i]], objB [keysA [i]])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态对比">状态对比</h3><p>关于如何做对比以及采用何种方式，在第三部分由始说起</p><h2 id="第三部分-immutable-data-相关">第三部分 Immutable Data 相关</h2><p>鉴于上述问题，针对数据罗列主要的几种类型的数据结构，如下：</p><ul><li>不可变（Immutable）数据<ul><li>新数据结构<ul><li><a href="https://github.com/immutable-js/immutable-js" target="_blank" rel="noopener">facebook/immutable-js</a></li></ul></li></ul></li><li>不可变更新（Immutable Update）实用程序<ul><li><a href="https://github.com/mweststrate/immer" target="_blank" rel="noopener">mweststrate/immer</a></li></ul></li><li>Immutable/Redux 互操作<ul><li><a href="https://github.com/gajus/redux-immutable" target="_blank" rel="noopener">gajus/redux-immutable</a></li></ul></li></ul><h3 id="immutable-js">immutable-js</h3><p><strong>参考来源</strong> <a href="https://github.com/camsong/blog/issues/3" target="_blank" rel="noopener">Immutable 详解及 React 中实践</a></p><blockquote><p>Shared mutable state is the root of all evil（共享的可变状态是万恶之源） -- Pete Hunt</p></blockquote><figure><img src="/2020/04/13React系列-immutable上下文/04.png" alt><figcaption>04</figcaption></figure><p>JavaScript 中的对象一般是<strong>可变的（Mutable）</strong>，因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。如 foo={a: 1}; bar=foo; bar.a=2 你会发现此时 foo.a 也被改成了 2。</p><p>虽然这样做可以<strong>节约内存</strong>，但当应用复杂后，这就造成了非常大的隐患，Mutable 带来的优点变得得不偿失。</p><p>为了解决这个问题，一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了 CPU 和内存的浪费。</p><blockquote><p>Immutable 可以很好地解决这些问题。</p></blockquote><h4 id="immutable-data">Immutable Data</h4><p>Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个<strong>新的 Immutable 对象</strong>。</p><p>Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要<strong>保证旧数据同时可用且不变。</strong></p><p>同时为了<strong>避免 deepCopy</strong> 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。请看下面动画：</p><p><a href="/05.gif">05</a></p><p>Facebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 <strong>Persistent Data Structure</strong>，还有很多易用的数据类型。像 Collection、List、Map、Set、Record、Seq。有非常全面的<code>map、filter、groupBy、reduce、find</code>函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。</p><p>其中有 3 种最重要的数据结构说明一下：（Java 程序员应该最熟悉了）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>：键值对集合，对应于 <span class="built_in">Object</span>，ES6 也有专门的 <span class="built_in">Map</span> 对象</span><br><span class="line">List：有序可重复的列表，对应于 <span class="built_in">Array</span></span><br><span class="line"><span class="built_in">Set</span>：无序且不可重复的列表</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> bar = foo;</span><br><span class="line">bar.a.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo.a.b);  <span class="comment">// 打印 2</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === bar);  <span class="comment">//  打印 true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 immutable.js 后</span></span><br><span class="line"><span class="keyword">import</span> Immutable <span class="keyword">from</span> <span class="string">'immutable'</span>;</span><br><span class="line">foo = Immutable.fromJS(&#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;);</span><br><span class="line">bar = foo.setIn([<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="number">2</span>);   <span class="comment">// 使用 setIn 赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getIn([<span class="string">'a'</span>, <span class="string">'b'</span>]));  <span class="comment">// 使用 getIn 取值，打印 1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === bar);  <span class="comment">//  打印 false</span></span><br></pre></td></tr></table></figure><p><strong>Immutable.is</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> map1 = Immutable.Map(&#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">1</span>, <span class="attr">c</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> map2 = Immutable.Map(&#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">1</span>, <span class="attr">c</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">// 比较内存地址</span></span><br><span class="line">map1 === map2;             <span class="comment">// false</span></span><br><span class="line"><span class="comment">// Immutable.is 比较的是两个对象的 hashCode 或 valueOf（对于 JavaScript 对象）</span></span><br><span class="line">Immutable.is(map1, map2);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="优缺点">优缺点</h4><ol type="1"><li>Immutable 降低了 Mutable 带来的复杂度</li><li>节省内存</li><li>Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟</li><li>并发安全</li></ol><hr><ol type="1"><li>需要学习新的 API</li><li>增加了资源文件大小</li><li>容易与原生对象混淆</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; is &#125; <span class="keyword">from</span> <span class="string">'immutable'</span>;</span><br><span class="line"></span><br><span class="line">shouldComponentUpdate: <span class="function">(<span class="params">nextProps = &#123;&#125;, nextState = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> thisProps = <span class="keyword">this</span>.props || &#123;&#125;, thisState = <span class="keyword">this</span>.state || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(thisProps).length !== <span class="built_in">Object</span>.keys(nextProps).length ||</span><br><span class="line">      <span class="built_in">Object</span>.keys(thisState).length !== <span class="built_in">Object</span>.keys(nextState).length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!is(thisProps[key], nextProps[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> nextState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (thisState[key] !== nextState[key] &amp;&amp; !is(thisState[key], nextState[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图</p><p><img src="/2020/04/13React系列-immutable上下文/06.png"></p><h3 id="immerjs">immerjs</h3><p><a href="https://immerjs.github.io/immer/docs/introduction" target="_blank" rel="noopener">immer官网</a></p><p><a href="https://juejin.im/post/5aaf6d596fb9a028d207be00" target="_blank" rel="noopener">以下摘录--精读《Immer.js》源码</a></p><p>Immer 想解决的问题，是利用元编程简化 Immutable 使用的复杂度。 immer 是使用原生数据结构的 API 而不是内置的 API.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> produce = <span class="built_in">require</span>(<span class="string">'immer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  done: <span class="literal">false</span>,</span><br><span class="line">  val: <span class="string">'string'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newState = produce(state, (draft) =&gt; &#123;</span><br><span class="line">  draft.done = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(state.done)    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(newState.done) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">produce(obj, draft =&gt; &#123;</span><br><span class="line">  draft.count++</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>整体思路：draft 是 obj 的<strong>代理</strong>，对 draft mutable 的修改都会流入到<strong>自定义 setter 函数</strong>，它并不修改原始对象的值，而是递归父级不断<strong>浅拷贝</strong>，最终返回新的<strong>顶层对象</strong>，作为 produce 函数的<strong>返回</strong>值。</p><h4 id="构建代理">构建代理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  modified, <span class="comment">// 是否被修改过</span></span><br><span class="line">  finalized, <span class="comment">// 是否已经完成（所有 setter 执行完，并且已经生成了 copy）</span></span><br><span class="line">  parent, <span class="comment">// 父级对象</span></span><br><span class="line">  base, <span class="comment">// 原始对象（也就是 obj）</span></span><br><span class="line">  copy, <span class="comment">// base（也就是 obj）的浅拷贝，使用 Object.assign(Object.create(null), obj) 实现</span></span><br><span class="line">  proxies, <span class="comment">// 存储每个 propertyKey 的代理对象，采用懒初始化策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代理对象上，绑定了自定义的 getter setter，然后直接将其扔给 <strong>produce 执行</strong>。</p><h4 id="getter">getter</h4><p>produce 回调函数中包含了<code>用户的 mutable 代码</code>。所以现在入口变成了 getter 与 setter。</p><p>getter 主要用来懒初始化代理对象，也就是<strong>当代理对象子属性被访问</strong>的时候，才会生成其代理对象。</p><ol type="1"><li>不浪费资源；</li><li>子对象可以被访问到。</li></ol><h4 id="setter">setter</h4><p>当对 draft 修改时，会对 base 也就是原始值进行<strong>浅拷贝</strong>，保存到 copy 属性，同时将 modified 属性设置为 true。这样就完成了最重要的 Immutable 过程，而且浅拷贝并不是很消耗性能，加上是按需浅拷贝，因此 Immer 的性能还可以。</p><p>同时为了保证整条链路的对象都是新对象，会根据 parent 属性递归父级，不断浅拷贝，直到这个叶子结点到根结点整条链路对象都换新为止。</p><p>完成了 modified 对象再有属性被修改时，会将这个新值保存在 copy 对象上。</p><h4 id="生成-immutable-对象">生成 Immutable 对象</h4><p>当<strong>执行完 produce</strong> 后，用户的所有修改已经完成（所以 Immer 没有支持异步），如果 <strong>modified</strong> 属性为 false，说明用户根本没有改这个对象，那直接返回原始 base 属性即可。</p><p>如果 modified 属性为 <strong>true</strong>，说明对象发生了修改，返回 <strong>copy 属性</strong>即可。但是 setter 过程是递归的，draft 的子对象也是 draft（包含了 base copy modified 等额外属性的代理），我们必须一层层递归，拿到真正的值。</p><p>所以在这个阶段，所有 draft 的 <strong>finalized</strong> 都是 <strong>false，copy</strong> 内部可能还存在大量 draft 属性，因此递归 base 与 copy 的子属性，如果相同，就直接返回；如果不同，递归一次整个过程（从这小节第一行开始）。</p><p>最后返回的对象是由 base 的一些属性（没有修改的部分）和 copy 的一些属性（修改的部分）最终拼接而成的。最后使用 freeze 冻结 copy 属性，将 <strong>finalized</strong> 属性设置为 <strong>true。</strong></p><p>至此，返回值生成完毕，我们将最终值保存在 copy 属性上，并将其冻结，返回了 Immutable 的值。</p><p>Immer 因此完成了不可思议的操作：Create the next immutable state by mutating the current one。</p><blockquote><p>源码读到这里，发现 Immer 其实可以支持异步，只要支持 produce 函数返回 Promise 即可。最大的问题是，最后对代理的 revoke 清洗，需要借助全局变量，这一点阻碍了 Immer 对异步的支持。</p></blockquote><p><img src="/2020/04/13React系列-immutable上下文/07.png"></p><p><a href="https://immerjs.github.io/immer/docs/introduction" target="_blank" rel="noopener">immer官网</a></p><h3 id="优点">优点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Immutability with normal JavaScript objects, arrays, Sets and Maps. No new APIs to learn!</span><br><span class="line">Strongly typed, no string based paths selectors etc.</span><br><span class="line">Structural sharing out of the box</span><br><span class="line">Object freezing out of the box</span><br><span class="line">Deep updates are a breeze</span><br><span class="line">Boilerplate reduction. Less noise, more concise code.</span><br><span class="line">First class support for patches</span><br><span class="line">Small: 3KB gzipped</span><br></pre></td></tr></table></figure><p>参考阅读： <a href="https://github.com/camsong/blog/issues/3" target="_blank" rel="noopener">Immutable详解及 React 中实践</a> <a href="https://juejin.im/entry/59b5e4916fb9a00a3b3bd52d" target="_blank" rel="noopener">精读 Immutable 结构共享</a> <a href="https://juejin.im/post/5b9b30a35188255c6418e67c" target="_blank" rel="noopener">深入探究Immutable.js的实现机制（一）</a> <a href="https://juejin.im/post/5ba4a6b75188255ca1537b19" target="_blank" rel="noopener">深入探究immutable.js的实现机制（二）</a> <a href="https://zhangzhao.name/posts/immer-immutable/" target="_blank" rel="noopener">immer.js 简介及源码简析</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ES系列-数据类型&lt;1&gt;</title>
      <link href="/2020/04/12ES%E7%B3%BB%E5%88%97-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/04/12ES%E7%B3%BB%E5%88%97-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/04/12ES系列-数据类型/../../../images/photos/2020/001.jpg" width="80%"></p><p>Software is like sex; it's better when it's free. ——Linus Torvalds (Linux之父)</p><a id="more"></a><h1 id="js-数据类型">JS 数据类型</h1><h3 id="第一部分-js的数据类型及其检测">第一部分 JS的数据类型及其检测</h3><h4 id="js数据类型总揽">JS数据类型总揽</h4><figure><img src="/2020/04/12ES系列-数据类型/03.jpg" alt><figcaption>07adp2x1cp.jpeg</figcaption></figure><figure><img src="/2020/04/12ES系列-数据类型/04.png" alt><figcaption>image.png</figcaption></figure><blockquote><p>简述，值类型与引用类型的图解示例。</p></blockquote><figure><img src="/2020/04/12ES系列-数据类型/05.png" alt><figcaption>截屏2020-03-25上午10.19.46.png</figcaption></figure><h4 id="typeof">typeof</h4><blockquote><p>只能区分基本类型</p></blockquote><figure><img src="/2020/04/12ES系列-数据类型/06.png" alt><figcaption>image.png</figcaption></figure><h4 id="栈堆">栈堆</h4><p><strong><a href="http://www.ruanyifeng.com/blog/2013/11/stack.html" target="_blank" rel="noopener">来源：Stack的三种含义</a></strong> ** 程序运行的时候，需要内存空间存放数据。一般来说，系统会划分出两种不同的内存空间：</p><ol type="1"><li>一种叫做stack（栈），</li><li>一种叫做heap（堆）。</li></ol><p>它们的主要区别是：</p><ol type="1"><li>stack是有结构的，每个区块按照一定次序存放，可以明确知道每个区块的大小；</li><li>heap是没有结构的，数据可以任意存放。因此，stack的寻址速度要快于heap。</li></ol><p>其他的区别还有，一般来说，每个线程分配一个stack，每个进程分配一个heap，也就是说，stack是线程独占的，heap是线程共用的。此外，stack创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow错误，而heap的大小是不确定的，需要的话可以不断增加。</p><p>根据上面这些区别，数据存放的规则是：<strong>只要是局部的、占用空间确定的数据，一般都存放在stack里面，否则就放在heap里面</strong>。请看下面这段代码（来源）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> y=<span class="number">2</span>;</span><br><span class="line">    class1 cls1 = <span class="keyword">new</span> class1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="/2020/04/12ES系列-数据类型/07.png" alt><figcaption>image.png</figcaption></figure><blockquote><p>当Method1方法运行结束，会发生什么事？</p></blockquote><p>回答是<strong>整个stack被清空</strong>，i、y和cls1这三个变量消失，因为它们是局部变量，区块一旦运行结束，就没必要再存在了。而<strong>heap之中的那个对象实例继续存在</strong>，直到系统的垃圾清理机制（garbage collector）将这块内存回收。因此，<strong>一般来说，内存泄漏都发生在heap，即某些内存空间不再被使用了，却因为种种原因，没有被系统回收。</strong></p><h3 id="第二部分-类型转换">第二部分 类型转换</h3><h4 id="tostring-valueof">ToString ValueOf</h4><p>Javascript 中几乎所有类型都具有<strong>toString和valueOf属性</strong>。几乎所有的类型对象比如<strong>Number,String,Boolean,Array,Function,Object,Date,RegExp</strong>的原型对象上都有各自的toString或valueOf方法的实现,故它们的实例化的对象自然就继承了这两个方法。下面看一下这些类型的原型对象上是否有这两个方法的实现： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>);    <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">Number</span>.prototype.hasOwnProperty(<span class="string">'valueOf'</span>);    <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">String</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>);    <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">String</span>.prototype.hasOwnProperty(<span class="string">'valueOf'</span>);    <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">Boolean</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>);    <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">Boolean</span>.prototype.hasOwnProperty(<span class="string">'valueOf'</span>);    <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>);     <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.hasOwnProperty(<span class="string">'valueOf'</span>);     <span class="comment">//输出false </span></span><br><span class="line"><span class="built_in">Function</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>);     <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.hasOwnProperty(<span class="string">'valueOf'</span>);     <span class="comment">//输出false</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>);     <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty(<span class="string">'valueOf'</span>);     <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">Date</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>);     <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">Date</span>.prototype.hasOwnProperty(<span class="string">'valueOf'</span>);     <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">RegExp</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>);     <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">RegExp</span>.prototype.hasOwnProperty(<span class="string">'valueOf'</span>);     <span class="comment">//输出false</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，只有<strong>Array,Function,RegExp的原型上没有valueOf属</strong>性,但是为什么其实例化对象能调用该方法呢？ 我们都知道上面所有列举的类型的原型(prototype)都是继承于Object的原型(prototype)的，当Array,Function,RegExp的实例化对象找不到某个属性时会沿着原型链往上找，直到找到或给出undefined。<strong>其实例对象调用的是Object原型上的valueOf， </strong> <strong>valueOf()作用</strong></p><figure><img src="/2020/04/12ES系列-数据类型/08.png" alt><figcaption>image.png</figcaption></figure><h4 id="toprimitive">ToPrimitive</h4><p>抽象方法ToPrimitive将对象值转换为相应的基本类型值。该方法会 首先检查该值是否有valueOf()方法，如果有并且返回基本类型值，就使用该值进行强制类型转换； 如果没有就使用toString()的返回值(如果存在)来进行强制类型转换； 如果valueOf()和toString()均不返回基本类型值，会产生TypeError错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a + b   <span class="comment">//"1,23,4"</span></span><br></pre></td></tr></table></figure><ol type="1"><li>数组的valueOf()操作无法得到<strong>简单基本类型值</strong>，于是调用toString()，</li><li>因此两个数组变成了"1,2"和"3,4"</li><li><ul><li>将它们拼接后返回。</li></ul></li></ol><h4 id="汇总">汇总</h4><p>可以参考下册两张图，好好研究下</p><figure><img src="/2020/04/12ES系列-数据类型/09.png" alt><figcaption>image.png</figcaption></figure><figure><img src="/2020/04/12ES系列-数据类型/10.png" alt><figcaption>image.png</figcaption></figure><h4 id="练习题">练习题</h4><h5 id="section"><code>1. [] == ![]</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. []作为对象ToPrimitive得到 &apos;&apos;  </span><br><span class="line">2. ![]作为boolean转换得到0 </span><br><span class="line">a. ![] 等价于 !Boolean([])，除了六种情况外，Boolean()都是true</span><br><span class="line">3. &apos;&apos; == 0 </span><br><span class="line">4. 转换为 0==0 //true</span><br></pre></td></tr></table></figure><h5 id="undefined-false"><code>2. [undefined] == false</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 第一步，应用 规则5 ，[undefined]通过toString变成 &apos;&apos;,</span><br><span class="line">  题目变成  &apos;&apos; == false</span><br><span class="line">- 第二步，应用 规则2 ，题目变成  &apos;&apos; == 0</span><br><span class="line">- 第三步，应用 规则3 ，题目变成  0 == 0</span><br><span class="line">- 所以， 答案是 true ！</span><br><span class="line">// 但是 if([undefined]) 又是个true！</span><br></pre></td></tr></table></figure><p>参考文章 <a href="https://chinese.freecodecamp.org/news/javascript-implicit-type-conversion/" target="_blank" rel="noopener">Javascript 隐式类型转换，一篇就够了！</a> <a href="https://juejin.im/post/5b076c006fb9a07aa43c9fda#heading-8" target="_blank" rel="noopener">你可能忽略的js类型转换</a> <a href="https://juejin.im/post/5b3b76de5188251afc25567f#heading-3" target="_blank" rel="noopener">JavaScript中的强制类型转换</a> <a href="https://www.jianshu.com/p/91ffaf79de1c" target="_blank" rel="noopener">深入理解JavaScript中的toString，valueOf属性</a></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React系列-setState&lt;3&gt;</title>
      <link href="/2020/04/12React%E7%B3%BB%E5%88%97-setState/"/>
      <url>/2020/04/12React%E7%B3%BB%E5%88%97-setState/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/04/12React系列-setState/01.jpg" width="80%"></p><p>我唯一能确定的就是自己的无知 ——苏格拉底 (哲学之父)</p><a id="more"></a><h2 id="目标">目标</h2><ul><li>理解setState为何知道更新</li><li>理解hooks的执行者</li></ul><hr><p>原文链接： <a href="https://overreacted.io/zh-hans/how-does-setstate-know-what-to-do/" target="_blank" rel="noopener">How Does setState Know What to Do?</a></p><hr><h3 id="疑惑">疑惑🤔：</h3><blockquote></blockquote><p>当你在组件中调用&gt; <code>setState</code>&gt; 的时候，你认为发生了些什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">class Button extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; clicked: false &#125;;</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">  // setState</span><br><span class="line">    this.setState(&#123; clicked: true &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.clicked) &#123;</span><br><span class="line">      return &lt;h1&gt;Thanks&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        Click me!</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Button /&gt;, document.getElementById(&apos;container&apos;));</span><br></pre></td></tr></table></figure><p>当然是：React根据下一个状态<code>{clicked：true}</code>重新渲染组件，同时更新DOM以匹配返回的<code>&lt;h1&gt;Thanks&lt;/ h1&gt;</code>元素啊。</p><p>看起来很直白。但是等等，<strong>是 <em>React_做了这些吗 ？还是_React DOM </em>？</strong> **</p><hr><blockquote><p>疑惑🤔： 我们或许会认为：<code>React.Component</code>类包含了DOM更新的逻辑。</p></blockquote><p>但是如果是这样的话，<code>this.setState()</code>又如何能在其他环境下使用呢？举个例子，React Native app中的组件也是继承自<code>React.Component</code>。他们依然可以像我们在上面做的那样调用<code>this.setState()</code>，而且React Native渲染的是安卓和iOS原生的界面而不是DOM。 因此，<strong><code>React.Component</code>以某种未知的方式将处理状态（state）更新的任务委托给了特定平台的代码。</strong>在我们理解这些是如何发生的之前，让我们深挖一下包（packages）是如何分离的以及为什么这样分离。 **</p><hr><blockquote><p>疑惑😂： 有一个很常见的误解就是React“引擎”是存在于<code>react</code>包里面的。 然而事实并非如此。</p></blockquote><p>** 实际上从<a href="https://reactjs.org/blog/2015/07/03/react-v0.14-beta-1.html#two-packages" target="_blank" rel="noopener">React 0.14</a>我们将代码拆分成多个包以来，<code>react</code>包故意只暴露一些定义组件的API。绝大多数React的_实现_都存在于“渲染器（renderers）”中。 &gt; <code>react-dom</code>、<code>react-dom/server</code>、 <code>react-native</code>、 <code>react-test-renderer</code>、 <code>react-art</code>都是常见的渲染器（当然你也可以<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/README.md#practical-examples" target="_blank" rel="noopener">创建属于你的渲染器</a>）。    </p><p>这就是为什么不管你的目标平台是什么，<code>react</code>包都是可用的。从<code>react</code>包中导出的一切，比如<code>React.Component</code>、<code>React.createElement</code>、 <code>React.Children</code> 和（最终的）<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">Hooks</a>，都是独立于目标平台的。无论你是运行React DOM，还是 React DOM Server,或是 React Native，你的组件都可以使用同样的方式导入和使用。 ** 相比之下，渲染器包暴露的都是特定平台的API，比如说：<code>ReactDOM.render()</code>，可以让你将React层次结构（hierarchy）挂载进一个DOM节点。每一种渲染器都提供了类似的API。理想状况下，绝大多数_组件_都不应该从渲染器中导入任何东西。只有这样，组件才会更加灵活。</p><hr><blockquote><p><strong>✌️</strong> <strong>和大多数人现在想的一样，React “引擎”就是存在于各个渲染器的内部。</strong></p></blockquote><p>** 很多渲染器包含一份同样代码的复制 —— 我们称为<a href="https://github.com/facebook/react/tree/master/packages/react-reconciler" target="_blank" rel="noopener">“协调器”(“reconciler”)</a>。<a href="https://reactjs.org/blog/2017/12/15/improving-the-repository-infrastructure.html#migrating-to-google-closure-compiler" target="_blank" rel="noopener">构建步骤(build step)</a>将协调器代码和渲染器代码平滑地整合成一个高度优化的捆绑包（bundle）以获得更高的性能。（代码复制通常来说不利于控制捆绑包的大小，但是绝大多数React用户同一时间只会选用一个渲染器，比如说<code>react-dom</code>。）</p><p>这里要注意的是： <code>react</code>包仅仅是让你_使用_ React 的特性，但是它完全不知道这些特性是_如何_实现的。而渲染器包(<code>react-dom</code>、<code>react-native</code>等)提供了React特性的实现以及平台特定的逻辑。这其中的有些代码是共享的(“协调器”)，但是这就涉及到各个渲染器的实现细节了。 **</p><hr><blockquote><p>🤩： 现在我们知道为什么当我们想使用新特性时，<code>react</code> 和 <code>react-dom</code>_都_需要被更新。</p></blockquote><p>** 举个例子，当React 16.3添加了Context API，<code>React.createContext()</code>API会被React包暴露出来。 但是<code>React.createContext()</code> 其实并没有_实现_ context。因为在React DOM 和 React DOM Server 中同样一个 API 应当有不同的实现。所以<code>createContext()</code>只返回了一些普通对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 简化版代码</span><br><span class="line">function createContext(defaultValue) &#123;</span><br><span class="line">  let context = &#123;</span><br><span class="line">    _currentValue: defaultValue,</span><br><span class="line">    Provider: null,</span><br><span class="line">    Consumer: null</span><br><span class="line">  &#125;;</span><br><span class="line">  context.Provider = &#123;</span><br><span class="line">    $$typeof: Symbol.for(&apos;react.provider&apos;),</span><br><span class="line">    _context: context</span><br><span class="line">  &#125;;</span><br><span class="line">  context.Consumer = &#123;</span><br><span class="line">    $$typeof: Symbol.for(&apos;react.context&apos;),</span><br><span class="line">    _context: context,</span><br><span class="line">  &#125;;</span><br><span class="line">  return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> </strong> 当你在代码中使用 <code>&lt;MyContext.Provider&gt;</code> 或 <code>&lt;MyContext.Consumer&gt;</code>的时候， 是**_渲染器决定如何处理这些接口。React DOM也许用某种方式追踪context的值，但是React DOM Server用的可能是另一种不同的方式。</p><p><strong>所以，如果你将<code>react</code>升级到了16.3+，但是不更新<code>react-dom</code>，那么你就使用了一个尚不知道<code>Provider</code> 和 <code>Consumer</code>类型的渲染器。</strong>这就是为什么一个老版本的<code>react-dom</code>会<a href="https://stackoverflow.com/a/49677020/458193" target="_blank" rel="noopener">报错说这些类型是无效的</a>。</p><hr><blockquote><p><code>疑问😑😑</code> <code>react</code>包并不包含任何有趣的东西，除此之外，具体的实现也是存在于<code>react-dom</code>，<code>react-native</code>之类的渲染器中。但是这并没有回答我们的问题。<code>React.Component</code>中的<code>setState()</code>如何与正确的渲染器“对话”？</p></blockquote><p><strong> </strong>答案是：每个渲染器都在已创建的类上设置了一个特殊的字段。**这个字段叫做<code>updater</code>。这并不是_你_要设置的的东西——而是，React DOM、React DOM Server 或 React Native在创建完你的类的实例之后会立即设置的东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// React DOM 内部</span><br><span class="line">const inst = new YourComponent();</span><br><span class="line">inst.props = props;</span><br><span class="line">inst.updater = ReactDOMUpdater;</span><br><span class="line"></span><br><span class="line">// React DOM Server 内部</span><br><span class="line">const inst = new YourComponent();</span><br><span class="line">inst.props = props;</span><br><span class="line">inst.updater = ReactDOMServerUpdater;</span><br><span class="line"></span><br><span class="line">// React Native 内部</span><br><span class="line">const inst = new YourComponent();</span><br><span class="line">inst.props = props;</span><br><span class="line">inst.updater = ReactNativeUpdater;</span><br></pre></td></tr></table></figure><p>** 查看<a href="https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react/src/ReactBaseClasses.js#L58-L67" target="_blank" rel="noopener"><code>React.Component</code>中<code>setState</code>的实现</a>， <code>setState</code>所做的一切就是委托渲染器创建这个组件的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 适当简化的代码</span><br><span class="line">setState(partialState, callback) &#123;</span><br><span class="line">  // 使用`updater`字段回应渲染器！</span><br><span class="line">  this.updater.enqueueSetState(this, partialState, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 这就是this.setState()<code>尽管定义在React包中，却能够更新DOM的原因。它读取由React DOM设置的</code>this.updater`，让React DOM安排并处理更新。</p><h3 id="小结">✌️✌️✌️小结</h3><ol type="1"><li>setState缘由</li><li>存放位置以及如何通信</li><li>渲染器被指派处理state的变化。</li></ol><hr><h3 id="疑惑-1">疑惑🤔🤔🤔：</h3><blockquote><p>当使用Hooks时，<code>useState是</code>怎么 “知道要做什么”的 ？</p></blockquote><p>当人们第一次看见<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">Hooks proposal API</a>，他们可能经常会想： <code>useState是</code>怎么 “知道要做什么”的？然后假设它比那些包含<code>this.setState()</code>的<code>React.Component</code>类更“神奇”。</p><p>但是正如我们今天所看到的，<strong>基类中<code>setState()</code>的执行一直以来都是一种错觉。它除了将调用转发给当前的渲染器外，什么也没做</strong>。<code>useState</code> Hook<a href="https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react/src/ReactHooks.js#L55-L56" target="_blank" rel="noopener">也是做了同样的事情</a>。 <strong> </strong>Hooks使用了一个“dispatcher”对象，代替了<code>updater</code>字段。**当你调用<code>React.useState()</code>、<code>React.useEffect()</code>、 或者其他内置的Hook时，这些调用被转发给了当前的dispatcher。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// React内部(适当简化)</span><br><span class="line">const React = &#123;</span><br><span class="line">  // 真实属性隐藏的比较深，看你能不能找到它！</span><br><span class="line">  __currentDispatcher: null,</span><br><span class="line"></span><br><span class="line">  useState(initialState) &#123;</span><br><span class="line">    return React.__currentDispatcher.useState(initialState);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  useEffect(initialState) &#123;</span><br><span class="line">    return React.__currentDispatcher.useEffect(initialState);</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>各个渲染器会在渲染你的组件之前设置dispatcher：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// React DOM 内部</span><br><span class="line">const prevDispatcher = React.__currentDispatcher;</span><br><span class="line">React.__currentDispatcher = ReactDOMDispatcher;</span><br><span class="line">let result;</span><br><span class="line">try &#123;</span><br><span class="line">  result = YourComponent(props);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  // 恢复原状</span><br><span class="line">  React.__currentDispatcher = prevDispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>      举个例子， React DOM Server的实现是在<a href="https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L340-L354" target="_blank" rel="noopener">这里</a>，还有就是React DOM 和 React Native共享的协调器的实现在<a href="https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-reconciler/src/ReactFiberHooks.js" target="_blank" rel="noopener">这里</a>。</p><p>这就是为什么像<code>react-dom</code>这样的渲染器需要访问那个你调用Hooks的<code>react</code>包。否则你的组件将不会“看见”dispatcher！如果在一个组件树中存在<a href="https://github.com/facebook/react/issues/13991" target="_blank" rel="noopener">React的多个副本</a>，也许并不会这样。但是，这总是导致了一些模糊的错误，因此Hooks会强迫你在出现问题之前解决包的重复问题。</p><p>在高级工具用例中，你可以在技术上覆盖dispatcher，尽管我们不鼓励这种操作。（对于<code>__currentDispatcher</code>这个名字我撒谎了，但是你可以在React仓库中找到真实的名字。）比如说， React DevTools将会使用<a href="https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-debug-tools/src/ReactDebugHooks.js#L203-L214" target="_blank" rel="noopener">一个专门定制的dispatcher</a>通过捕获JavaScript堆栈跟踪来观察Hooks树。<em>请勿模仿。</em></p><p>这也意味着Hooks本质上并没有与React绑定在一起。如果未来有更多的库想要重用同样的原生的Hooks, 理论上来说dispatcher可以移动到一个分离的包中，然后暴露成一个一等（first-class）的API，然后给它起一个不那么“吓人”的名字。但是在实践中，我们会尽量避免过早抽象，直到需要它为止。</p><p><code>updater</code>字段和<code>__currentDispatcher</code>对象都是称为<strong><em>依赖注入</em></strong>的通用编程原则的形式。在这两种情况下，渲染器将诸如<code>setState</code>之类的功能的实现“注入”到通用的React包中，以使组件更具声明性。</p><p>使用React时，你无需考虑这其中的原理。我们希望React用户花更多时间考虑他们的应用程序代码，而不是像依赖注入这样的抽象概念。但是如果你想知道<code>this.setState()</code>或<code>useState()</code>是如何知道该做什么的，我希望这篇文章会有所帮助。</p><p>参考链接 <a href="https://juejin.im/post/5c31b814f265da612b13bf23" target="_blank" rel="noopener">react 渲染器了解一下？</a> <a href="https://juejin.im/post/5ae2a019f265da0b736d5f46" target="_blank" rel="noopener">Dependency Injection-依赖注入详解</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Reac实战系列-单页面&lt;1&gt;</title>
      <link href="/2020/04/11Reac%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97-%E5%8D%95%E9%A1%B5%E9%9D%A2/"/>
      <url>/2020/04/11Reac%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97-%E5%8D%95%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/04/11Reac实战系列-单页面/01.jpg" width="80%"></p><p>知识上的投资总能得到最好的回报。 ——本杰明.富兰克林 (美国开国元勋 物理学家 作家)</p><a id="more"></a><p>目标: 结合前几篇文章，汇总一个小Demo.</p><h1 id="react实战">React实战</h1><p>本示例依照<a href="https://www.yuque.com/ant-design/course/wybhm9" target="_blank" rel="noopener">Ant Design 实战教程（beta 版）</a>进行编写，非常感谢各位大佬的倾情付出！谢谢🙏</p><blockquote><p>正是江南好风景，落花时节学代码</p></blockquote><figure><img src="/2020/04/11Reac实战系列-单页面/03.gif" alt><figcaption>react1.gif</figcaption></figure><p>有了前两节的铺垫，这个<a href="https://www.yuque.com/ant-design/course/wybhm9" target="_blank" rel="noopener">Ant Design 实战教程（beta 版）</a>也觉得挺顺手的，汇总下编写的流程以及接下来要进一步学习的内容。</p><h3 id="第一部分-整体概述">第一部分 整体概述</h3><p>该demo是个典型的SPA项目，实现功能如布局、侧边栏、列表、表格、弹窗等，其中包含：</p><ul><li>应用框架：<a href="https://umijs.org/zh-CN/docs" target="_blank" rel="noopener">Umi</a></li><li>数据流：<a href="https://dvajs.com/guide/" target="_blank" rel="noopener">DvaJs</a></li><li>UI: <a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">Antd</a></li></ul><blockquote><p><a href="https://umijs.org/zh-CN/docs" target="_blank" rel="noopener">Umi</a>，中文可发音为<strong>乌米</strong>, 是可扩展的企业级前端应用框架。Umi 以路由为基础的，同时支持配置式路由和约定式路由，保证路由的功能完备，并以此进行功能扩展。然后配以生命周期完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求。</p></blockquote><blockquote><p><a href="https://dvajs.com/guide/" target="_blank" rel="noopener">DvaJs</a>首先是一个基于 <a href="https://github.com/reduxjs/redux" target="_blank" rel="noopener">redux</a> 和 <a href="https://github.com/redux-saga/redux-saga" target="_blank" rel="noopener">redux-saga</a> 的数据流方案，然后为了简化开发体验，dva 还额外内置了 <a href="https://github.com/ReactTraining/react-router" target="_blank" rel="noopener">react-router</a> 和 <a href="https://github.com/github/fetch" target="_blank" rel="noopener">fetch</a>，所以也可以理解为一个轻量级的应用框架。</p></blockquote><blockquote><p><a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">Antd</a> 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">hhw-4:antd-course hhw$ tree -L 4 -I node_modules</span><br><span class="line">.</span><br><span class="line">├── config #配置文件</span><br><span class="line">│   └── config.js</span><br><span class="line">├── dist</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── umi.js</span><br><span class="line">├── mock</span><br><span class="line">│   └── articleMock.js</span><br><span class="line">├── package.json</span><br><span class="line">└── src</span><br><span class="line">    ├── layout</span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── models</span><br><span class="line">    │   ├── articleModel.js</span><br><span class="line">    │   ├── chartModel.js</span><br><span class="line">    │   └── complexArticleModel.js</span><br><span class="line">    ├── pages</span><br><span class="line">    │   ├── Chart</span><br><span class="line">    │   │   └── ChartClass.js</span><br><span class="line">    │   ├── Complex</span><br><span class="line">    │   │   ├── Article.js</span><br><span class="line">    │   │   └── ComplexArticle.js</span><br><span class="line">    │   ├── Dashboard</span><br><span class="line">    │   │   ├── Analysis.js</span><br><span class="line">    │   │   ├── Monitor.js</span><br><span class="line">    │   │   └── Workplace.js</span><br><span class="line">    │   └── HelloWorld.js</span><br><span class="line">    ├── service</span><br><span class="line">    │   └── chart.js</span><br><span class="line">    └── util</span><br><span class="line">        └── request.js</span><br></pre></td></tr></table></figure><p>其实有了React、Redux的基础，示例代码很容易看懂，在这里就不贴代码了，罗列一些操作中疑惑的地方。</p><h2 id="第二部分">第二部分</h2><h3 id="一dvajs--effect">一、DvaJs--Effect</h3><p>Reducer如果做了异步操作，将破坏redux中reducer是纯函数的机制，effect 就是专门处理这些具有 "副作用" 的操作的执行单元。 #### <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespace: <span class="string">'some_namespace'</span>,</span><br><span class="line">  state: &#123;&#125;,</span><br><span class="line">  effects: &#123; <span class="comment">// 定义 effects 成员</span></span><br><span class="line">    <span class="string">'someEffect'</span>: <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="string">'someOtherEffect'</span>: <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>宏观上看，effect 是一层中间件。</li><li>局部上看 effect 就是一个一个的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">generator function</a>。 #### #### 1. 中间层 &gt; 什么是中间层？ &gt; " Middleware is some code you can put between the framework receiving a request, and the framework generating a response. "</li></ul><p>       当 action 被 dispatch 之后，会先到达 effect 处理副作用，然后该 effect 最终会促使新的 action 发送出去，这个新的 action 可能被其他的 effect 再捕获继续处理，也可能被 reducer 捕获并结束，无论怎样，最终处理逻辑的终点都将是 reducer。 #### 2. generator function。</p><figure><img src="/2020/04/11Reac实战系列-单页面/02.png" alt><figcaption>image.png</figcaption></figure><p>异步的实质是事件发生促使程序的执行点来回跳转。我们使用 callback 本质上是描述跳转的一种手段。generator function 并没有改变异步的本质，只是改变了描述的方式，使得程序看起来像是同步一样。 一个 generator function 在执行时有 <strong>两方</strong>。一方是 generator function 本身，另一方是 generator function 的句柄持有者，而这一般都是框架所持有。我们姑且称这个句柄为 genStub。当框架调用 genStub.next() 时，generator function 会执行到下一个 <code>yield</code> 然后暂停，并把 yield 后面表达式的计算值返还给框架，同时把程序执行权交给框架。框架拿到值后做处理，比如就是异步处理，处理结束拿到结果，再次调用 genStub.next()，返还值给 generator function 同时驱动它恢复执行。当恢复执行时，你可以认为 <strong>返回的处理结果会整体替换 <code>yield &lt;expression&gt;</code></strong>，然后程序继续执行到下一个 yield。</p><blockquote><p>yield 这个单词用在这里特别形象：yield 本身有「让步」的意思，也有「产出」的意思。</p></blockquote><p><strong>「generator function yield 到外部的值」和「外部返还给 generator function 的值」不是一回事！！！</strong> <strong> #### 3. 使用 入参有两个对象，第一个对象就是匹配这个 effect 的 action 对象，因此可以取到约定的 </strong>payload** 这个字段，第二个对象是** <em>effect 原语集</em>**，其中 <code>call</code>, <code>put</code> 最为常用，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call: 阻塞 用于调用异步逻辑，支持 promise</span><br><span class="line">put: 不阻塞 用于触发 action,一般来触发reducer改变state</span><br><span class="line">select: 不阻塞 用于从 state 里获取数据</span><br><span class="line">take: 阻塞 dva封装了take，可以监听action的开始和结束阶段，take会阻塞到监听的事件触发，才执行下一步</span><br></pre></td></tr></table></figure><p><strong>示例</strong> <img src="/2020/04/11Reac实战系列-单页面/04.png" alt="image.png"></p><h3 id="二代理">二、代理</h3><p>在前端开发中，一种常见的规避跨域的方法就是：把 ajax 请求发送到你的本地开发服务器，然后本地开发服务器再把 ajax 请求转发到远端去，从网络拓扑上看本地开发服务器起着「反向代理」的作用。本地服务器和远端服务器是「服务器和服务器间的通信」，就不存在跨域问题了。</p><p>配置代理也很简单，只需要您在配置文件 config/config.js 中与 routes 同级处增加 proxy 字段，代码如下，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+  proxy: &#123;</span><br><span class="line">+    <span class="string">'/dev'</span>: &#123;</span><br><span class="line">+      target: <span class="string">'https://08ad1pao69.execute-api.us-east-1.amazonaws.com'</span>,</span><br><span class="line">+      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">+    &#125;,</span><br><span class="line">+  &#125;,</span><br></pre></td></tr></table></figure><p>配置的含义是：去往本地服务器 localhost:8000 的 ajax 调用中，如果是以 <code>/dev</code> 开头的，那么就转发到远端的 <code>https://08ad1pao69.execute-api.us-east-1.amazonaws.com</code> 服务器当中，<code>/dev</code> 也会保留在转发地址中。</p><figure><img src="/2020/04/11Reac实战系列-单页面/05.png" alt><figcaption>image.png</figcaption></figure><h3 id="三二次封装">三、二次封装</h3><p>Antd真的很赞！对于开发者而言，公共的代码其实可以二次封装一下，比如from表单等，可以减少不少的代码。</p><h3 id="四css-modules">四、CSS Modules</h3><figure><img src="/2020/04/11Reac实战系列-单页面/06.png" alt><figcaption>image.png</figcaption></figure><p><a href="https://github.com/camsong/blog/issues/5" target="_blank" rel="noopener">CSS Modules 详解及 React 中实践</a> <a href>CSS MODULES用法教程</a></p><p><strong>CSS modules</strong> 将生成全局唯一的hash值【标签实际的class】。通过全局唯一的class name 变相的就可以获取到<strong>局部作用域【scoped css】，</strong>如果一个 CSS 文件仅仅是作用在某个局部的话，我们称这样一个 CSS 文件为 <em>CSS module</em>。 <strong>注意：很多 CSS 选择器是不会被 CSS Modules 处理的，比如 body、div 、a 这样的 HTML 标签名就不会。我们推荐如果要定义局部 css 样式/动画， 只使用 class 或 <span class="citation" data-cites="keyframe">@keyframe</span>。</strong></p><p><strong><a href="https://less.bootcss.com/" target="_blank" rel="noopener">Less 官方文档</a></strong> <strong> &gt; <a href="http://lesscss.org/usage/" target="_blank" rel="noopener">Less</a> 是一个 CSS 的超集，Less 允许我们</strong>_定义变量_<strong>，使用</strong>_嵌套式声明，定义函数_**等。严格说 Less 包含两部分：1. Less 的语法。2. Less 预处理器（Less preprocessor）。浏览器终究只认识 CSS，所以 Less 文件需要经过 Less 预处理器编译成为 CSS。 &gt; &gt; 在工具的支持下，一个 Less 文件首先会经过 CSS modules 的编译，把类名全局唯一化，然后才被 Less preprocessor 编译成为 CSS 文件。正因此，Less 文件可以和 CSS modules 无缝联合使用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// less 文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 常量</span><br><span class="line">@grey-color: rgba(0, 0, 0, 0.25);</span><br><span class="line"></span><br><span class="line">// 类嵌套</span><br><span class="line"><span class="selector-class">.hello</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">32px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#30b767</span>;</span><br><span class="line">  .deleted &#123;</span><br><span class="line">    <span class="selector-tag">text-decoration</span>: <span class="selector-tag">line-through</span>;</span><br><span class="line">    <span class="selector-tag">background-color</span>: <span class="keyword">@grey-color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重写Antd样式</span><br><span class="line"><span class="selector-class">.override-ant-btn</span> &#123;</span><br><span class="line">  // CSS Modules 允许使用:global(.className)的语法，声明一个全局规则。凡是这样声明的class，都不会被编译成哈希字符串。</span><br><span class="line">  <span class="selector-pseudo">:global(.ant-btn)</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">16px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;commonStyles.hello&#125;</span>&gt;</span> css module <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;lessStyles.hello&#125;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;lessStyles.deleted&#125;</span>&gt;</span>Less class 嵌套<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;lessStyles[</span>'<span class="attr">override-ant-btn</span>']&#125;&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">Button</span>&gt;</span>圆角样式按妞<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">Button</span>&gt;</span>antd 原始按钮<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure><img src="/2020/04/11Reac实战系列-单页面/07.png" alt><figcaption>image.png</figcaption></figure><p>最后强调，global 不应该被滥用，特别地我们建议：若想在某个文件中覆盖 antd 样式，请加上一个类似 <code>.override-ant-btn</code> 的类包裹住 global 修饰的名称，以避免全局样式声明分散在项目各处。</p><p>还有很多待补充的内容，边做边学</p><p>参考链接</p><ul><li>阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">redux 三部曲</a>。</li><li>redux-saga 的<a href="http://leonshi.com/redux-saga-in-chinese/docs/api/index.html" target="_blank" rel="noopener">中文文档</a>。</li><li><a href="https://dvajs.com/guide/develop-complex-spa.html#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDmodel" target="_blank" rel="noopener">使用 Dva 开发复杂 SPA</a></li><li><a href="https://dvajs.com/guide/source-code-explore.html#%E9%9A%90%E8%97%8F%E5%9C%A8-package-json-%E9%87%8C%E7%9A%84%E7%A7%98%E5%AF%86" target="_blank" rel="noopener">Dva源码解析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React系列-Redux&lt;2&gt;</title>
      <link href="/2020/04/10React%E7%B3%BB%E5%88%97-Redux/"/>
      <url>/2020/04/10React%E7%B3%BB%E5%88%97-Redux/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/04/10React系列-Redux/01.jpg" width="80%"></p><p>预测未来最好的方法就是去创造未来 ——林肯 (美国前总统)</p><a id="more"></a><h1 id="react-通信之-redux">React 通信之 Redux</h1><h3 id="背景">背景</h3><p>React 组件 componentDidMount 的时候初始化 Model，并监听 Model 的 change 事件，当 Model 发生改变时调用 React 组件的 setState 方法重新 render 整个组件，最后在组件 componentWillUnmount 的时候取消监听并销毁 Model。 <img src="/2020/04/10React系列-Redux/03.png" alt="image.png"></p><p>图片来源：<a href="https://www.processon.com/view/5db55958e4b0e433944fdc87" target="_blank" rel="noopener">https://www.processon.com/view/5db55958e4b0e433944fdc87</a></p><h3 id="第一部分-redux的出现">第一部分 Redux的出现</h3><blockquote><p>存在即合理</p></blockquote><p>如<strong>下图左侧</strong>所示，react单向流动的特性，导致在复杂的状态管理面前，会越来越麻烦。Redux的出现就是为了解决state里面的数据问题。 如<strong>下图右侧</strong>所示，redux维护单一状态库。</p><p>Redux三大特性： 1 唯一数据源 2 保持只读状态 3 数据改变只能通过纯函数来执行</p><figure><img src="/2020/04/10React系列-Redux/04.png" alt><figcaption>image.png</figcaption></figure><h3 id="第二部分-redux概念">第二部分 Redux概念</h3><h4 id="一粗略认识">一、粗略认识</h4><p>首先回想下，曾经你去图书馆借书的场景+上图右侧树图。</p><ul><li><strong>你</strong>去图书馆；</li><li><strong>询问</strong>管理员是否有《西部世界iii》这本书；</li><li>管理员<strong>查阅</strong>库存；</li><li>_<strong>反馈</strong>_给你，自己网上找资源去；</li><li>你去网上找资源。</li></ul><p>这个流程其实包含了Redux的整个流程。 <strong>询问 + 查阅</strong>** = **_<strong>反馈。</strong>__<strong>即：action + state = new state</strong>_ &gt; <em><strong>有果必有因</strong></em></p><p><img src="/2020/04/10React系列-Redux/05.png" alt="image.png"> <img src="/2020/04/10React系列-Redux/06.png" alt="image.png"> <img src="/2020/04/10React系列-Redux/07.png" alt="image.png"></p><h4 id="二具体的概念">二、具体的概念</h4><p>React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。 &gt; <strong>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑</strong></p><p>你可能会问，如果一个组件既有 UI 又有业务逻辑，那怎么办？回答是，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。 React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p><p>** 以上摘录自---<a href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html" target="_blank" rel="noopener">阮一峰的网络日志</a>，建议初学者多读几遍。</p><ul><li><strong>Action：</strong> 把数据从应用传到 store 的有效载荷；</li><li><strong>Store</strong>: 保存数据的地方；</li><li><strong>Dispatcher</strong>: view发出Action的唯一办法；</li><li><strong>Reducer：</strong> Store收到Action以后，必须给出一个新的state，这样view才会发生变化。<strong>Reducer即根据Action计算state；</strong></li><li><strong>State</strong>: store里面存储的数据。</li></ul><figure><img src="/2020/04/10React系列-Redux/08.gif" alt><figcaption>redux1.gif</figcaption></figure><figure><img src="/2020/04/10React系列-Redux/09.gif" alt><figcaption>redux2.gif</figcaption></figure><h4 id="三示例代码">三、示例代码</h4><p>Redux一个简单的加数操作，涉及完整的流程。 其中涉及</p><ul><li>redux各个概念；</li><li>UI组件 &amp; 容器组件 的相互关系；</li><li>Provider的使用 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider, connect &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value, onIncreaseClick &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;&#123;value&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;onIncreaseClick&#125;&gt;Increase&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Counter.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  value: PropTypes.number.isRequired,</span></span><br><span class="line"><span class="regexp">  onIncreaseClick: PropTypes.func.isRequired</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 定义action</span></span><br><span class="line"><span class="regexp">const increaseAction = &#123; type: "increase" &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * Reducer函数</span><br><span class="line"> * @param &#123;*&#125; state 默认值</span><br><span class="line"> * @param &#123;*&#125; action 根据action来计算state.</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">function counter(state = &#123; count: 0 &#125;, action) &#123;</span></span><br><span class="line"><span class="regexp">  const count = state.count;</span></span><br><span class="line"><span class="regexp">  switch (action.type) &#123;</span></span><br><span class="line"><span class="regexp">    case "increase":</span></span><br><span class="line"><span class="regexp">      return &#123; count: count + 1 &#125;;</span></span><br><span class="line"><span class="regexp">    default:</span></span><br><span class="line"><span class="regexp">      return state;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 创建store -&gt; 需要reducer -&gt; 默认值+action</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">const store = createStore(counter);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。</span><br><span class="line"> * @param &#123;*&#125; state</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">function mapStateToProps(state) &#123;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    value: state.count</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * 建立 UI 组件的参数到store.dispatch方法的映射</span><br><span class="line"> * 定义了哪些用户的操作应该当作 Action，传给 Store。</span><br><span class="line"> * 它可以是一个函数，也可以是一个对象。</span><br><span class="line"> *</span><br><span class="line"> * <span class="number">1.</span> 函数：</span><br><span class="line"> *      - 参数：</span><br><span class="line"> *        可以拿到dispatch和ownProps（容器组件的props对象）两个参数；</span><br><span class="line"> *      - 返回值</span><br><span class="line"> *        一个对象，每个键值对都是一个映射，[键名对应函数名]</span><br><span class="line"> *         定义了 UI 组件的参数怎样发出 Action。</span><br><span class="line"> * <span class="number">2.</span> 对象</span><br><span class="line"> *      它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，</span><br><span class="line"> *      会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。</span><br><span class="line"> * @param &#123;*&#125; dispatch</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">function mapDispatchToProps(dispatch) &#123;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 同名函数 onIncreaseClick， dispatch 一个action</span></span><br><span class="line"><span class="regexp">    onIncreaseClick: () =&gt; dispatch(increaseAction)</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * connect 自动生成容器组件，将UI组件[Counter]与[容器组件]即关联起来。</span><br><span class="line"> * Counter: UI 组件</span><br><span class="line"> * mapStateToProps： 输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数</span><br><span class="line"> * mapDispatchToProps： 用户发出的动作如何变为 Action 对象，从 UI 组件传出去。</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">const App = connect(</span></span><br><span class="line"><span class="regexp">  mapStateToProps,</span></span><br><span class="line"><span class="regexp">  mapDispatchToProps</span></span><br><span class="line"><span class="regexp">)(Counter);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ React-Redux 提供Provider组件，可以让容器组件拿到state。</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 原理： React中的context属性，</span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;Provider store=&#123;store&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &lt;App /</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById("root")</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></li></ul><p>结合下图理解 <img src="/2020/04/10React系列-Redux/10.png" alt="image.png"></p><p>图片来源：<a href="https://juejin.im/post/5acdbe8f51882548fe4a7af1" target="_blank" rel="noopener">https://juejin.im/post/5acdbe8f51882548fe4a7af1</a> #### 总结 这个例子中，最外层的Provider利用react-redux中的provider组件，<em><strong>那么究竟provider组件做了什么？为何provider子组件能够或许context属性？</strong></em> &gt; 上篇文章利用context进行传值，并未过多的解释说明。</p><p>Provider 本身是一个 react 组件，这一点首先要搞清楚。它的实现原理非常简单，利用了 React 的 context 这一特性。文档<a href="https://react.docschina.org/docs/context.html" target="_blank" rel="noopener">Context - React</a>, 只要在最外层的组件实现一个 getChildContext 这个方法，返回一个对象，内部的组件都可以通过 this.context 拿到这个对象。所以一个简单的 Provider 实现是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">store</span>: <span class="keyword">this</span>.props.store &#125;    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line"><span class="keyword">const</span> store = createStore();</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">, document.querySelector('#root'));</span></span><br></pre></td></tr></table></figure><p>那么整个页面的逻辑流程就是：</p><ol type="1"><li>创建Store，createStore(), 接受reducers&amp;默认值；</li><li>createStore 对每一个reducer进行dispatch一个action.type=@<span class="citation" data-cites="redux/INTT类型的action">@redux/INTT类型的action</span>，然后返回state默认值；</li><li>render()进行渲染，每个子组件通过传入的this.context.store.getState()方法获取state对象+ownProps给mapStateToProps方法，构建props，应用到子组件上；</li><li>UI组件触发action, 随即mapDispatchToProps触发相应的action；</li><li>strore接收到action进行reduce，得到新的state，然后再调用所有子组件的mapDispatchToProps生成props.</li><li>最后provider进行重新渲染需要更新的组件。 ### 第三部分 react-redux示例--<a href="https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos" target="_blank" rel="noopener">TodoList demo</a> 试着从头到位实现一边，会更加深对本文的理解。鉴于代码太多&amp;上述的理解，应该是没问题的，但不要眼高手低。</li></ol><figure><img src="/2020/04/10React系列-Redux/11.png" alt><figcaption>image.png</figcaption></figure><h4 id="感谢">感谢</h4><p><a href="https://juejin.im/post/5acdbe8f51882548fe4a7af1" target="_blank" rel="noopener">一幅图明白React-Redux的原理</a> <a href="https://www.cnblogs.com/liuheng/p/11796819.html" target="_blank" rel="noopener">解析：让你弄懂redux原理</a> <a href="https://www.cnblogs.com/nayek/p/12369418.html" target="_blank" rel="noopener">https://www.cnblogs.com/nayek/p/12369418.html</a> <a href="https://www.processon.com/view/5db55958e4b0e433944fdc87" target="_blank" rel="noopener">https://www.processon.com/view/5db55958e4b0e433944fdc87</a> <a href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React系列-生命周期&lt;1&gt;</title>
      <link href="/2020/04/09React%E7%B3%BB%E5%88%97-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2020/04/09React%E7%B3%BB%E5%88%97-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/04/09React系列-生命周期/01.jpg" width="80%"></p><p>一个人的价值, 在于他贡献了什么, 而不在于他获得了什么。 ——爱因斯坦</p><a id="more"></a><h1 id="react生命周期原生通信">React生命周期&amp;原生通信</h1><h6 id="由四张图引发的一系列事件">由四张图引发的一系列事件。。。。</h6><figure><img src="/2020/04/09React系列-生命周期/03.png" alt><figcaption>image.png</figcaption></figure><figure><img src="/2020/04/09React系列-生命周期/04.png" alt><figcaption>image.png</figcaption></figure><h3 id="section"></h3><h3 id="本文主要根据原生传参展开顺带温故下生命周期接下来就是redux.">本文主要根据原生传参展开，顺带温故下生命周期，接下来就是Redux.</h3><h3 id="section-1"></h3><h3 id="第一部分-生命周期">第一部分 生命周期</h3><h4 id="一概念">一、概念</h4><p>在组件<strong>创建、加载运行、被销毁</strong>的过程中，总是伴随着各种各样的事件，组件在特定时期触发对应的事件，都属于组件的生命周期范畴。</p><p><strong>生命周期的三种状态：</strong></p><ul><li>Mounting：已插入真实 DOM</li><li>Updating：正在被重新渲染</li><li>Unmounting：已移出真实 DOM</li></ul><p>完整的生命周期如下图所示，可以在代码中，尝试一下，各个方法在什么时候会触发，触发效果是什么。 <img src="/2020/04/09React系列-生命周期/05.png" alt="生命周期.png"> 图片来源：https://www.cnblogs.com/ygjzs/p/12203390.html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="keyword">this</span>.props.count</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在组件即将挂载到页面上的时候执行，此时，组件尚未挂载到页面</span></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"componentWillMount"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在内存中开始渲染DOM，未展示</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// ⚠️在此如果更新state, 则会进入死循环</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;这是 Counter 计数器组件&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="button" value="加1" onClick=&#123;this.increment&#125; /</span>&gt;</span><br><span class="line">        &lt;hr /&gt;</span><br><span class="line">        &lt;h3 id=<span class="string">"content"</span> ref=<span class="string">"h3"</span>&gt;</span><br><span class="line">          当前的数量是：&#123;<span class="keyword">this</span>.state.count&#125;</span><br><span class="line">        &lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断组件是否需要更新</span></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(nextProps, nextState);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 组件将要更新，但Dom, state还是旧的</span></span><br><span class="line">  componentWillUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">"WillUpdate: "</span> +</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"content"</span>).innerHTML +</span><br><span class="line">        <span class="string">". state: "</span> +</span><br><span class="line">        <span class="keyword">this</span>.state.count</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 组件完成了更新，此时，state 中的数据、虚拟DOM、页面上的DOM，都是最新的</span></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">"DidUpdate: "</span> +</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"content"</span>).innerHTML +</span><br><span class="line">        <span class="string">". state: "</span> +</span><br><span class="line">        <span class="keyword">this</span>.state.count</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二部分-原生通信">第二部分 原生通信</h3><p><strong>以下示例codesandbox地址</strong>：<a href="https://codesandbox.io/s/gifted-grothendieck-2wsy3" target="_blank" rel="noopener">https://codesandbox.io/s/gifted-grothendieck-2wsy3</a> 主要实现以下功能：</p><ul><li>父子组件通过props互相传值；</li><li>孙子组件通过context传参数。</li></ul><figure><img src="/2020/04/09React系列-生命周期/06.gif" alt><figcaption>Kapture 2020-03-18 at 16.28.13.gif</figcaption></figure><h4 id="一父子组件互相传值">一、父子组件互相传值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Son <span class="keyword">from</span> <span class="string">"./Son"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      content: <span class="string">""</span>,</span><br><span class="line">      inputMsg: <span class="string">""</span>,</span><br><span class="line">      receiveMsg: <span class="string">""</span>,</span><br><span class="line">      contextMsg: <span class="string">""</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** ------使用props传值----------- */</span></span><br><span class="line">  <span class="comment">// 更改状态</span></span><br><span class="line">  inputMsg = <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      inputMsg: item.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  sendMsg = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> text = <span class="keyword">this</span>.state.inputMsg;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      content: text</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 父组件将一个函数作为 props 传递给子组件，</span></span><br><span class="line"><span class="comment">   * 子组件调用该回调函数，便可以向父组件通信。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  handleCallBack = <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      receiveMsg: msg</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/** ------使用props传值----------- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** ------使用context传值----------- */</span></span><br><span class="line">  <span class="comment">// 父组件声明自己支持 context</span></span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    callback: PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父组件提供一个函数，用来返回相应的 context 对象</span></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      callback: <span class="keyword">this</span>.callback.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callback(msg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      contextMsg: msg</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** ------使用context传值----------- */</span></span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;父子组件互相传值&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input value=&#123;this.state.inputMsg&#125; onChange=&#123;this.inputMsg&#125; /</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.sendMsg&#125;&gt; 传给子组件 &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr /</span>&gt;</span><br><span class="line">        &lt;label&gt; 将要发送的数据： &#123;<span class="keyword">this</span>.state.inputMsg&#125; &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr /</span>&gt;</span><br><span class="line">        &lt;label&gt; 接受props方式的数据： &#123;<span class="keyword">this</span>.state.receiveMsg&#125; &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr /</span>&gt;</span><br><span class="line">        &lt;label&gt; 接受Context方式的数据： &#123;<span class="keyword">this</span>.state.contextMsg&#125; &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr /</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Son</span><br><span class="line">          content=&#123;<span class="keyword">this</span>.state.content&#125;</span><br><span class="line">          handleCallBack=&#123;<span class="keyword">this</span>.handleCallBack.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> GrandSon <span class="keyword">from</span> <span class="string">"./GrandSon"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 回调父组件的handleCallBack方法，向上传值</span></span><br><span class="line">  callBack = <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.handleCallBack(msg);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      <span class="comment">// 1. 接受父组件传过来的值</span></span><br><span class="line">        &lt;h4&gt;子组件接受的值：&#123;<span class="keyword">this</span>.props.content&#125;&lt;<span class="regexp">/h4&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 2. 向父组件传值</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.callBack("发送： " + this.props.content)&#125;&gt;</span></span><br><span class="line"><span class="regexp">          向父组件传值</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">        &lt;hr /&gt;</span><br><span class="line">        &lt;GrandSon /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="二跨级组件">二、跨级组件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandSon</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 子组件声明自己需要使用 context</span></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    callback: PropTypes.func</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 回调函数</span></span><br><span class="line">  cb = <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.context.callback(msg);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.cb(<span class="string">"发消息"</span>)&#125;&gt; 孙子向爷爷发消息 。&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>官方文档一看就会，一写就蒙圈。。 通过以上这两个示例，主要加深了对React的理解，将组件与数据串联起来，页面很丑，数据来凑，示例中没有数据校验与代码优化。 接下来对剩余的几张图【Redux、Dva】以示例的方式展示出来，应该快轮到antd了。</p><h6 id="参考链接">参考链接</h6><p><a href="https://www.cnblogs.com/ygjzs/p/12203390.html" target="_blank" rel="noopener">React 生命周期</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机--Chrome使用</title>
      <link href="/2019/06/15_chrome%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/06/15_chrome%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/06/15_chrome使用/../../../images/photos/2020/004.jpg" width="80%"></p><p>只有两样东西可能是无限的: 宇宙的大小和人类的愚蠢。不过, 对于前者我不太确定 :) ——爱因斯坦</p><a id="more"></a><h2 id="目录">目录</h2><figure><img src="/2019/06/15_chrome使用/15606166007495.jpg?200x200" alt><figcaption>-w204</figcaption></figure><figure><img src="/2019/06/15_chrome使用/digital-transformation-in-50-soundbites-19-638.jpg" alt><figcaption>digital-transformation-in-50-soundbites-19-638-w319</figcaption></figure><p><strong>目标</strong></p><p>以更高效的方式去领略人类的智慧。</p><h3 id="前言">前言</h3><p><strong>除了程序员以外，好像没有别的行业，流行分享自己的知识</strong>。相反的，这个世界上大部分行业，强调的都是保密，千万不能让别人知道我的独家信息和知识。</p><p>由此看来，<strong>程序员世界的开源和分享，其实是例外</strong>。正常情况下，这些东西都应该是标价出售的，花了钱才能拿到手。</p><p>经济学有一个假定，每个人都是自私的，追求自己的利益最大化，从而才能让这个世界变得有效率。那么，当我们鼓励开源和分享的时候，可不可以说我们正在做一件反人性的事情呢？[摘录自：<a href="http://www.ruanyifeng.com/blog/2019/05/weekly-issue-57.html" target="_blank" rel="noopener">阮一峰技术博客</a>]</p><blockquote><p>知识是无价的，每个人都应该有平等的权利去享用教育资源</p></blockquote><p>对于浏览器，强烈推荐正版<strong>firefox</strong>其次 <strong>chrome</strong>，没有别的了。</p><p>还没从chrome转换成firefox,使用方法都类似，就写chrome了，该文<code>不涉及技术实现</code>,只叙述<code>使用方法</code>;</p><p>本文没有先后顺序，可任意跳转查看</p><blockquote><p>每个人有权利获取有效的信息 爱学习的人是幸运的，送给你们</p></blockquote><h3 id="第一部分-基本使用">第一部分 基本使用</h3><figure><img src="/2019/06/15_chrome使用/15605977689367.jpg" alt><figcaption>-w1141</figcaption></figure><h4 id="下载">1. 下载</h4><p><a href="https://www.google.cn/intl/zh-CN/chrome/" target="_blank" rel="noopener">首推官网下载</a>。如果访问不了，相信百度还是可以访问的，虽说有点不尽人意。。。</p><h4 id="基本配置使用">2. 基本配置/使用</h4><p>试想你买回来个手机，虽说电话、短信、音乐等基本功能已经可供使用，似乎是不言而喻的东西。也正是这些不言而喻的东西，才让你再使用的时候自然而然。</p><blockquote><p>为了那些自然而然，从0开始认识她吧 她提供给你可能远超你所想到的。</p></blockquote><figure><img src="/2019/06/15_chrome使用/15605986047101.jpg" alt><figcaption>-w500</figcaption></figure><figure><img src="/2019/06/15_chrome使用/15605989584660.jpg" alt><figcaption>-w500</figcaption></figure><figure><img src="/2019/06/15_chrome使用/15605994447444.jpg" alt><figcaption>-w500</figcaption></figure><blockquote><p><strong>安全是相对的。</strong></p></blockquote><figure><img src="/2019/06/15_chrome使用/15606003797177.jpg" alt><figcaption>-w600</figcaption></figure><p>到此已经把浏览器的各种设置罗列，如需满足需求，找到相应的地方更改即可。 <strong>接下来是如何有效的搜索。</strong></p><h3 id="第二部分-高效的搜索">第二部分 高效的搜索</h3><p>该部分主要针对搜索技巧的汇总，整理了个思维导图，然后对相应的技巧进行实例化、场景化解释。这又是<strong>长长长长长的一篇文章</strong></p><figure><img src="/2019/06/15_chrome使用/%E6%90%9C%E7%B4%A2%E6%98%AF%E9%97%A8%E8%89%BA%E6%9C%AF.png" alt><figcaption>搜索是门艺术</figcaption></figure><h4 id="指令类">1. 指令类</h4><blockquote><p>不要忘了，页面中搜索关键字----cmd/ctrl+f</p></blockquote><h5 id="基本">基本</h5><h6 id="逻辑运算">逻辑运算</h6><p><img src="/2019/06/15_chrome使用/15606070892238.jpg"></p><p><img src="/2019/06/15_chrome使用/15606071440188.jpg"></p><p><img src="/2019/06/15_chrome使用/15606071858867.jpg"></p><h6 id="其他">其他</h6><figure><img src="/2019/06/15_chrome使用/15606074332900.jpg" alt><figcaption>-w300</figcaption></figure><p><img src="/2019/06/15_chrome使用/15606074698417.jpg" alt="-w300"> <img src="/2019/06/15_chrome使用/15606075069026.jpg" alt="-w300"></p><h5 id="进阶">进阶</h5><p><img src="/2019/06/15_chrome使用/15606078626881.jpg" alt="-w400"> <img src="/2019/06/15_chrome使用/15606079520059.jpg" alt="-w400"></p><p><img src="/2019/06/15_chrome使用/15606082742367.jpg" alt="-w400"> <img src="/2019/06/15_chrome使用/15606083219251.jpg" alt="-w400"></p><p>在标题中搜索</p><figure><img src="/2019/06/15_chrome使用/15606084266580.jpg" alt><figcaption>-w400</figcaption></figure><p>在指定URL【统一资源定位符】对应的内容中找【关键字】 <img src="/2019/06/15_chrome使用/15606086652706.jpg" alt="-w400"></p><h4 id="搜索技巧">2. 搜索技巧</h4><h5 id="搜索思维">搜索思维</h5><blockquote><p>不论你用不用，资源都在那里</p><p>这一块只是引导类</p></blockquote><p>如何搜到所需内容，需要的不仅是基本技巧【前面部分内容】，还需要<strong>思考发布者是如何思考的</strong>，他的思考<code>决定了</code>使用哪些的<strong>关键字、语句、分词</strong>。</p><p>发布者总会采用<strong>标题党</strong>的套路,如：</p><p><img src="/2019/06/15_chrome使用/15606091535164.jpg"></p><p>最近在学Python，寻思着总会有人做总结、思维导图之类的，就可以搜索<code>python学习</code> 选择<strong>image</strong></p><p>看，全都是，找几个好点的，照着学就是了<strong>just do it</strong> <img src="/2019/06/15_chrome使用/15606093683902.jpg"></p><p>还有搜索，可以切换中英文去搜，对吧✅</p><blockquote><p>好了，到此为止，搜索的技巧基本结束了</p></blockquote><p><strong>类似于如下这种操作</strong></p><p><img src="/2019/06/15_chrome使用/15606095648889.jpg"></p><p>但是不能<code>知其然不知其所以然</code>，只会用接下来的工具。</p><p><img src="/2019/06/15_chrome使用/15606097550656.jpg"></p><h5 id="工具网址推荐">工具网址推荐</h5><blockquote><p>终于进入智人时代了。</p><p>点点鼠标就行了。。</p></blockquote><p>百宝箱---<a href="http://www.miguyu.com/" target="_blank" rel="noopener">咪咕鱼</a> <img src="/2019/06/15_chrome使用/15606103935215.jpg" alt="-w400"></p><p>Mac工具下载---<a href="https://xclient.info/" target="_blank" rel="noopener">精品Mac应用</a> 美剧----<a href="http://www.zmz2019.com/" target="_blank" rel="noopener">YYeTs 人人影视字幕组</a></p><p>电子书----<a href="https://bookset.me/4983.html" target="_blank" rel="noopener">六千本电子书📚。。。</a> <img src="/2019/06/15_chrome使用/15606104541759.jpg"></p><h3 id="第三部分-插件">第三部分 插件</h3><p>交了钱，车漏不<code>漏油</code>不知道，反正是可以开回家了。 &gt; 此时，拿了驾照、读过说明书。你就是<code>司机</code>了。</p><p>和<code>老司机</code>相比，区别可能是<code>技巧、装备</code>； 和<code>大神</code>相比，区别是：<code>民科</code>与<strong>科班</strong></p><p><strong>不可能把所有的插件都罗列，再次罗列一些常用的</strong></p><p>装备达到一定程度就是累赘了，<strong>如果家大业大，请随意</strong></p><figure><img src="/2019/06/15_chrome使用/15606127596203.jpg" alt><figcaption>-w250</figcaption></figure><h4 id="安装方式">1.安装方式</h4><h5 id="官方安装">官方安装</h5><p>建议直接上<a href="https://chrome.google.com/webstore/category/extensions?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">chrome 网上应用店</a>进行下载相关插件，Firefox也有类似的商店</p><p><img src="/2019/06/15_chrome使用/15606114775300.jpg"></p><p>直接点击相应的下载安装即可。</p><h5 id="离线安装">离线安装</h5><p>针对打不开第一种方式的，可以参考<a href="http://www.cnplugins.com/" target="_blank" rel="noopener">插件网</a>，</p><blockquote><p>步骤： 1. 下载 2. 打开chrome拓展程序 3. 拖插件到浏览器</p></blockquote><figure><img src="/2019/06/15_chrome使用/15606117112223.jpg" alt><figcaption>-w400</figcaption></figure><p><strong>还得提交验证码。。。</strong></p><h4 id="插件推荐">2.插件推荐</h4><p>默认为官方链接，也可以在3.1.2对应的网址中搜索相应的名字</p><h5 id="必备">必备</h5><p>1.去广告<a href="https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb" target="_blank" rel="noopener">Adblock Plus</a></p><p><img src="/2019/06/15_chrome使用/15606123732369.jpg"></p><p>2.下载器---<a href="https://chrome.google.com/webstore/detail/chrono-download-manager/mciiogijehkdemklbdcbfkefimifhecn/reviews" target="_blank" rel="noopener">Chrono下载管理器</a></p><p><img src="/2019/06/15_chrome使用/15606123265811.jpg"></p><p>3.新标签页面风景图---<a href="https://chrome.google.com/webstore/detail/dream-afar-new-tab/henmfoppjjkcencpbjaigfahdjlgpegn" target="_blank" rel="noopener">远方 New Tab</a></p><p><img src="/2019/06/15_chrome使用/15606124466544.jpg"></p><h5 id="工具">工具</h5><p>1.网页截图---<a href="https://chrome.google.com/webstore/detail/take-webpage-screenshots/mcbpblocgmgfnpjjppndjkmgjaogfceg" target="_blank" rel="noopener">FireShot</a></p><p><img src="/2019/06/15_chrome使用/15606123438949.jpg"></p><p>2.标签整理----<a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall" target="_blank" rel="noopener">oneTab</a></p><p><strong>省内存小能手</strong></p><p><img src="/2019/06/15_chrome使用/15606125863364.jpg"></p><p>3.英语翻译----<a href="https://chrome.google.com/webstore/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D-%E8%81%9A%E5%90%88%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg?hl=en" target="_blank" rel="noopener">沙拉查词-聚合词典划词翻译</a></p><p><img src="/2019/06/15_chrome使用/15606128832337.jpg"></p><blockquote><p>先分享这几个吧</p></blockquote><h3 id="第四部分-油候">第四部分 油候</h3><h4 id="配置">1. 配置</h4><h5 id="油候">油候</h5><p><strong>某文库、解除某云限制、VIP视频、蚊香高清音乐。。。。</strong></p><p>这是令人苦恼却不得不面对的问题，只不过你没学会用浏览器而已。</p><p>【油猴脚本】就是一个<strong>浏览器插件</strong>，它本身也可以添加很多<strong>不同的脚本。</strong></p><p>chrome地址----<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">Tampermonkey</a>。也可以第三方搜索下载</p><p><img src="/2019/06/15_chrome使用/15606133501778.jpg"></p><h5 id="脚本">脚本</h5><p>这个是插件，但插件内部还需下载脚本。</p><p>这个是脚本商店----<a href="https://greasyfork.org/zh-CN/scripts" target="_blank" rel="noopener">greasyfork</a></p><p><img src="/2019/06/15_chrome使用/15606135370111.jpg"></p><h5 id="关系">关系</h5><p>主要就是对网页数据进行相应的操作，比如插件可以屏蔽广告，脚本也可以。</p><blockquote><p>注释：不能保证每个插件、脚本都安全。</p></blockquote><p><img src="/2019/06/15_chrome使用/15606141541781.jpg"> #### 2.推荐脚本</p><p>直接截个图吧，因为名字就是功能。</p><p><img src="/2019/06/15_chrome使用/15606161539539.jpg"></p><blockquote><p>特别喜欢的一个两个：<strong>豆瓣的、汇总</strong></p></blockquote><p><img src="/2019/06/15_chrome使用/15606157139291.jpg"></p><p><strong>怎么用</strong></p><ol type="1"><li>点击安装；</li><li>刷新网页</li><li>找到新增的标签即可</li></ol><p><img src="/2019/06/15_chrome使用/15606164981912.jpg"> <img src="/2019/06/15_chrome使用/15606165328233.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块系列之--模块与包【18】</title>
      <link href="/2019/06/10_Python%E6%A8%A1%E5%9D%97%E4%B9%8BOS/"/>
      <url>/2019/06/10_Python%E6%A8%A1%E5%9D%97%E4%B9%8BOS/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/06/10_Python模块之OS/../../../images/photos/2020/005.jpg" width="80%"></p><p>真正的无知不是知识的贫乏, 而是拒绝获取知识! ——波普尔 (哲学家 思想家)</p><a id="more"></a><p>[toc]</p><p>##目标</p><ul><li>掌握常用的文件目录操作</li><li>学习with关键字</li><li>练习题</li></ul><h3 id="第一部分-os模块">第一部分 os模块</h3><p>os模块是Python标准库中的一个用于访问操作系统相关功能的模块，os模块提供了一种可移植的使用操作系统功能的方法。</p><h4 id="os模块的主要功能">1. os模块的主要功能：</h4><ol type="1"><li>系统相关</li><li>目录及文件操作</li><li>执行命令和管理进程</li></ol><h4 id="文件及目录相关">2. 文件及目录相关</h4><table><thead><tr class="header"><th>方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>os.mkdir</td><td>创建目录</td></tr><tr class="even"><td>os.rmdir</td><td>删除目录</td></tr><tr class="odd"><td>os.rename</td><td>重命名</td></tr><tr class="even"><td>os.remove</td><td>删除文件</td></tr><tr class="odd"><td>os.getcwd</td><td>获取当前工作路径</td></tr><tr class="even"><td>os.walk</td><td>遍历目录</td></tr><tr class="odd"><td>os.path.join</td><td>连接目录与文件名</td></tr><tr class="even"><td>os.path.split</td><td>分割文件名与目录</td></tr><tr class="odd"><td>os.path.abspath</td><td>获取绝对路径</td></tr><tr class="even"><td>os.path.dirname</td><td>获取路径</td></tr><tr class="odd"><td>os.path.basename</td><td>获取文件名或文件夹名</td></tr><tr class="even"><td>os.path.splitext</td><td>分离文件名与扩展名</td></tr><tr class="odd"><td>os.path.isfile</td><td>判断给出的路径是否是一个文件</td></tr><tr class="even"><td>os.path.isdir</td><td>判断给出的路径是否是一个目录</td></tr></tbody></table><p>背诵这种真的没啥意义，不如来个实例记得快些。网上找了个实例，来源<a href="https://blog.csdn.net/weixin_44251129/article/details/87449170" target="_blank" rel="noopener">python 文件操作练习题</a>, 稍加改动，<strong>还有bug</strong>，但包含了一些常用的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pylint: disable=no-member</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    mulu = input(<span class="string">'请输入目录：'</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(mulu):  <span class="comment"># 判断是否存在此目录</span></span><br><span class="line">        os.chdir(mulu)  <span class="comment"># 改变当前脚本工作目录；相当于shell下cd</span></span><br><span class="line">        ret = os.listdir(os.getcwd())  <span class="comment"># 打印出此目录的所有文件</span></span><br><span class="line">        print(ret)</span><br><span class="line">        lst1 = []</span><br><span class="line">        lst2 = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">            <span class="keyword">if</span> os.path.isfile(i):  <span class="comment"># 判断是否是文件</span></span><br><span class="line">                lst1.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lst2.append(i)</span><br><span class="line">        print(<span class="string">'文件：%s'</span> % lst1)</span><br><span class="line">        print(<span class="string">'文件夹：%s'</span> % lst2)</span><br><span class="line">        ret1 = input(<span class="string">'请选择操作：全部文件添加前缀（a） 全部删除前缀(s) 添加文件(d) 删除文件(f) 单个文件重命名(g):'</span>)</span><br><span class="line">        <span class="keyword">if</span> ret1.upper() == <span class="string">'A'</span>:</span><br><span class="line">            a = input(<span class="string">'请输入所要添加的前缀：'</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> ret:  <span class="comment"># 便利所有文件，</span></span><br><span class="line">                os.rename(i, a + i)  <span class="comment"># 使用字符串拼接，添加前缀</span></span><br><span class="line">            print(<span class="string">'添加成功'</span>)</span><br><span class="line">        <span class="keyword">elif</span> ret1.upper() == <span class="string">'S'</span>:</span><br><span class="line">            a = input(<span class="string">'请输入所要删除的前缀：'</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">                os.rename(i, i.replace(a, <span class="string">''</span>, <span class="number">1</span>))</span><br><span class="line">            print(<span class="string">'删除前缀成功'</span>)</span><br><span class="line">        <span class="keyword">elif</span> ret1.upper() == <span class="string">'D'</span>:</span><br><span class="line">            file_name = input(<span class="string">'请输入所要添加文件名称：'</span>)</span><br><span class="line">            <span class="keyword">with</span> open(file_name, mode=<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            print(<span class="string">'添加文件成功'</span>)</span><br><span class="line">        <span class="keyword">elif</span> ret1.upper() == <span class="string">'F'</span>:</span><br><span class="line">            del_name = input(<span class="string">'请输入所要删除的文件名：'</span>)</span><br><span class="line">            os.remove(del_name)</span><br><span class="line">            print(<span class="string">'删除文件成功'</span>)</span><br><span class="line">        <span class="keyword">elif</span> ret1.upper() == <span class="string">'G'</span>:</span><br><span class="line">            name = input(<span class="string">'请输入原始文件名[old name]:'</span>)</span><br><span class="line">            <span class="keyword">if</span> name.strip() == <span class="string">''</span>:</span><br><span class="line">                name = input(<span class="string">'不可为空，请输入原始文件名[old name]:'</span>)</span><br><span class="line"></span><br><span class="line">            newName = input(<span class="string">'请输入新的文件名[new name]:'</span>)</span><br><span class="line">            <span class="keyword">if</span> newName.strip() == <span class="string">''</span>:</span><br><span class="line">                newName = input(<span class="string">'不可为空，请输入新的文件名[old name]:'</span>)</span><br><span class="line"></span><br><span class="line">            os.rename(name, newName)</span><br><span class="line">            print(<span class="string">'修改成功'</span>)</span><br><span class="line">        os.chdir(<span class="string">'..'</span>)  <span class="comment"># 留在当前目录 以防输入两次文件夹名称报错</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'输入有误，请重新输入'</span>)</span><br></pre></td></tr></table></figure><h3 id="第二部分-with关键字">第二部分 with关键字</h3><blockquote><p>第一部分中的with究竟是什么意思？为何要用with呢？</p></blockquote><p>pyhton2.5中加入<code>with</code>, 常用来替换<code>try ... except ... finally ...</code>.</p><p>我们采用事务链接时，会着这样判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.begin()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># do some actions</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    db.commit()</span><br></pre></td></tr></table></figure><p>如果将发起事务请求的操作变成可以支持with关键字的，那么用像这样的代码就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> transaction(db):</span><br><span class="line">    <span class="comment"># do some actions</span></span><br></pre></td></tr></table></figure><p>第一部分的<code>with</code>就是保证读取文件内容时，不论出现什么意外，都保证最终关闭。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br></pre></td></tr></table></figure><h4 id="with-的一般执行过程">with 的一般执行过程</h4><p>一段基本的with表达式，其结构是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> EXPR <span class="keyword">as</span> VAR:</span><br><span class="line">    BLOCK</span><br></pre></td></tr></table></figure><p>其中：EXPR可以是任意表达式；as VAR是可选的。其一般的执行过程是这样的：</p><ol type="1"><li>计算EXPR，并获取一个上下文管理器。</li><li>上下文管理器的__exit()__方法被保存起来用于之后的调用。</li><li>调用上下文管理器的__enter()__方法。</li><li>如果with表达式包含as VAR，那么EXPR的返回值被赋值给VAR。</li><li>执行BLOCK中的表达式。</li><li>调用上下文管理器的__exit()__方法。如果BLOCK的执行过程中发生了一个异常导致程序退出，那么异常的type、value和traceback(即sys.exc_info()的返回值)将作为参数传递给__exit()__方法。否则，将传递三个None。</li></ol><h4 id="实现类似的with过程">实现类似的with过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">transaction</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, db)</span>:</span></span><br><span class="line">        self.db = db</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.db.begin()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, type, value, traceback)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> type <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            db.commit()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            db.rollback()</span><br></pre></td></tr></table></figure><p>基于装饰器的方法或更相信教程可参考<a href="http://yuez.me/python-zhong-de-guan-jian-zi-with-xiang-jie/" target="_blank" rel="noopener">Python 中的关键字with详解</a></p><h3 id="第三部分-习题">第三部分 习题</h3><p>狗东二面笔试题</p><ol type="1"><li>生成一个大文件ips.txt,要求1200行，每行随机为172.25.254.0/24段的ip;</li><li>读取ips.txt文件统计这个文件中ip出现频率排前10的ip;</li></ol><p><strong>分析</strong></p><ol type="1"><li>172.25.254.0/24，前24位为网络号，后八位为主机号，[0-255)；</li><li>1200行，写入ips.txt文件</li><li>统计次数，抽出前十条</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_ip_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="comment"># 172.25.254.[0,255)</span></span><br><span class="line">    ip = [<span class="string">'172.25.254.'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">255</span>)]</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'a+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># print(random.sample(ip,1))</span></span><br><span class="line">        <span class="comment"># 随机从数组中取第一个</span></span><br><span class="line">        [f.write(random.sample(ip, <span class="number">1</span>)[<span class="number">0</span>] + <span class="string">'\n'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1200</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create_ip_file(<span class="string">'ips.txt'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sorted_by_ip</span><span class="params">(filename, count=<span class="number">10</span>)</span>:</span></span><br><span class="line">    ips_dict = dict()</span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> ip <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> ip <span class="keyword">in</span> ips_dict:</span><br><span class="line">                ips_dict[ip] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ips_dict[ip] = <span class="number">1</span></span><br><span class="line">    print(ips_dict.items())</span><br><span class="line">    sorted_ip = sorted(</span><br><span class="line">        ips_dict.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:count]</span><br><span class="line">    <span class="keyword">return</span> sorted_ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(sorted_by_ip(<span class="string">'ips.txt'</span>))</span><br></pre></td></tr></table></figure><p><strong>结果</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">'172.25.254.49\n'</span>, <span class="number">14</span>), (<span class="string">'172.25.254.80\n'</span>, <span class="number">12</span>), (<span class="string">'172.25.254.172\n'</span>, <span class="number">11</span>), (<span class="string">'172.25.254.65\n'</span>, <span class="number">11</span>), (<span class="string">'172.25.254.45\n'</span>, <span class="number">10</span>), (<span class="string">'172.25.254.30\n'</span>, <span class="number">10</span>), (<span class="string">'172.25.254.8\n'</span>, <span class="number">10</span>), (<span class="string">'172.25.254.196\n'</span>, <span class="number">9</span>), (<span class="string">'172.25.254.53\n'</span>, <span class="number">9</span>), (<span class="string">'172.25.254.121\n'</span>, <span class="number">9</span>)]</span><br></pre></td></tr></table></figure></p><p>参考 <a href="http://yuez.me/python-zhong-de-guan-jian-zi-with-xiang-jie/" target="_blank" rel="noopener">Python 中的关键字with详解</a> <a href="https://blog.csdn.net/weixin_40543283/article/details/87538401" target="_blank" rel="noopener">python文件操作练习题</a></p>]]></content>
      
      
      <categories>
          
          <category> 模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> os </tag>
            
            <tag> sys </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络系列之IP地址相关计算【1】</title>
      <link href="/2019/06/06_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%E4%B9%8BIP%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/06/06_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%E4%B9%8BIP%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>温故知新 推荐一本书 ---《网络是怎样连接的》 &gt; 本系列为学习该书📚的学习汇总</p><blockquote><p>同时会包含一些补充</p></blockquote><blockquote><p>完整内容可购买阅读相关该📚</p></blockquote></blockquote><h2 id="目标">目标</h2><ul><li>回顾 HTTP 请求消息</li><li>掌握 ip地址、子网掩码、子网的计算</li></ul><hr><h2 id="目录">目录</h2><figure><img src="/2019/06/06_计算机网络系列之IP相关计算/1.jpg" alt><figcaption>目录</figcaption></figure><blockquote><p>接下来会围绕第一章进行学习</p></blockquote><figure><img src="/2019/06/06_计算机网络系列之IP相关计算/15598029663358.jpg" alt><figcaption>-w545</figcaption></figure><h3 id="第一部分-整体概述">第一部分 整体概述</h3><h4 id="http-请求消息">HTTP 请求消息</h4><p>URL： Uniform Resource Locator，统一资源定位符。 FTP： File Transfer Protocol， 文件传送协议。 这是一种在上传、下载文件时使用的协议。使用 FTP 协议来传送文件的程序也被叫作 FTP。</p><h4 id="常见的url分类">常见的URL分类</h4><p>日常用的最多的是HTTP： Hypertext Transfer Protocol，超文本传送协议, 但也有其他一些，如下图： <img src="/2019/06/06_计算机网络系列之IP相关计算/15598034956658.jpg" alt="-w543"></p><h4 id="http协议">http协议</h4><p>HTTP 协议定义了<code>客户端和服务器之间交互的消息内容和步骤</code>。</p><p>大致过程如下，客户端请求，服务器返回相应的数据。</p><figure><img src="/2019/06/06_计算机网络系列之IP相关计算/15598039794266.jpg" alt><figcaption>-w544</figcaption></figure><p>如何访问服务器中，特定的资源？看下边的URL图解</p><figure><img src="/2019/06/06_计算机网络系列之IP相关计算/15598039030172.jpg" alt><figcaption>-w548</figcaption></figure><h4 id="主要方法">主要方法</h4><p>有了整体的大致流程，也有了拆分URL的图解，就看下有哪些方法吧，浏览器访问属于GET.</p><figure><img src="/2019/06/06_计算机网络系列之IP相关计算/15598043575873.jpg" alt><figcaption>-w560</figcaption></figure><blockquote><p>URI： Uniform Resource Identifier，统一资源标识符。</p></blockquote><p><img src="/2019/06/06_计算机网络系列之IP相关计算/15598053253527.jpg" alt="-w535"> <img src="/2019/06/06_计算机网络系列之IP相关计算/15598053387188.jpg" alt="-w535"> <img src="/2019/06/06_计算机网络系列之IP相关计算/15598053724873.jpg" alt="-w551"></p><figure><img src="/2019/06/06_计算机网络系列之IP相关计算/15598051510339.jpg" alt><figcaption>-w2002</figcaption></figure><h3 id="第二部分-ip地址">第二部分 IP地址</h3><blockquote><p>该部分摘录自<a href="https://blog.51cto.com/6930123/2112403" target="_blank" rel="noopener">《IP地址详解》</a>，详情请参看原文。</p></blockquote><h4 id="ip地址分类">IP地址分类</h4><p><strong>IP地址（Internet Protocol Address），缩写为IP Adress</strong>，是一种在Internet上的给主机统一编址的地址格式，也称为网络协议（IP协议）地址。它为互联网上的每一个网络和每一台主机分配一个逻辑地址，常见的IP地址，分为<code>IPv4</code>与<code>IPv6</code>两大类，当前广泛应用的是IPv4，目前IPv4几乎耗尽，下一阶段必然会进行版本升级到IPv6；如无特别注明，一般我们讲的的IP地址所指的是IPv4。</p><figure><img src="/2019/06/06_计算机网络系列之IP相关计算/01b93a1d0acac52cc0bd4878696d4098.png" alt><figcaption>01b93a1d0acac52cc0bd4878696d4098-w473</figcaption></figure><p>IP地址分<strong>A、B、C、D、E五类</strong>，其中A、B、C这三类是比较常用的IP地址，D、E类为特殊地址。</p><blockquote><p>IP 地址是一串 32 比特的数字，按照 8 比特（1 字节）为一组分成 4 组，分别用十进制表示 然后再用圆点隔开。</p></blockquote><blockquote><p>在计算机二进制中，1个字节 = 8位 = 8bit（比特）</p></blockquote><figure><img src="/2019/06/06_计算机网络系列之IP相关计算/15598063874073.jpg" alt><figcaption>-w375</figcaption></figure><p><strong>Ip地址汇总</strong></p><p><img src="/2019/06/06_计算机网络系列之IP相关计算/15598087831047.jpg"></p><blockquote><p><strong>注：</strong> 为何减去2？</p></blockquote><p>在计算机网络中，主机ID全部为<code>0</code>的地址为<code>网络地址</code>，而主机ID全部为<code>1</code>的地址为<code>广播地址</code>，这2个地址是不能分配给主机用的。</p><h4 id="公网和私网ip地址">公网和私网IP地址</h4><p><code>公网IP地址</code> 公有地址分配和管理由Inter NIC（Internet Network Information Center 因特网信息中心）负责。各级ISP使用的公网地址都需要向Inter NIC提出申请，有Inter NIC统一发放，这样就能确保地址块不冲突。</p><p><code>私网IP地址</code> 创建IP寻址方案的人也创建了私网IP地址。这些地址可以被用于私有网络，在Internet没有这些IP地址，Internet上的路由器也没有到私有网络的路由表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A类：10.0.0.0 255.0.0.0，保留了1个A类网络。</span><br><span class="line">B类：172.16.0.0 255.255.0.0～172.31.0.0 255.255.0.0，保留了16个B类网络。</span><br><span class="line">C类：192.168.0.0 255.255.255.0～192.168.255.0 255.255.255.0，保留了256个C类网络。</span><br><span class="line">PS：私网地址访问Internet需要做NAT或PAT网络地址转换</span><br></pre></td></tr></table></figure><p><img src="/2019/06/06_计算机网络系列之IP相关计算/15598095553143.jpg"></p><p><img src="/2019/06/06_计算机网络系列之IP相关计算/15598095596202.jpg"></p><h4 id="子网掩码">子网掩码</h4><h5 id="引子">引子</h5><p>IP地址在设计时就考虑到<code>地址分配的层次特点</code>，将每个IP地址都分割成<code>网络号</code>和<code>主机号</code>两部分，以便于IP地址的<strong>寻址操作</strong>。</p><blockquote><p>如何确定：IP地址的网络号和主机号各是多少位呢？</p></blockquote><p><strong>那就了解下子网掩码</strong></p><p><a href="https://baike.baidu.com/item/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81#2" target="_blank" rel="noopener">百度百科</a></p><h5 id="定义">定义</h5><p>子网掩码(subnet mask)是每个使用互联网的人必须要掌握的基础知识，只有掌握它，才能够真正理解TCP/IP协议的设置。</p><p>子网掩码——<strong>屏蔽一个IP地址的网络部分的“全1”比特模式</strong>。对于A类地址来说，默认的子网掩码是255.0.0.0；对于B类地址来说默认的子网掩码是255.255.0.0；对于C类地址来说默认的子网掩码是255.255.255.0。 利用子网掩码可以把大的网络划分成子网，即VLSM（可变长子网掩码），也可以把小的网络归并成大的网络即超网。</p><h5 id="规则">规则</h5><p>子网掩码的长度也是32位，左边是<code>网络位</code>，用二进制数字“1”表示，<strong>1的数目等于网络位的长度</strong>；右边是<code>主机位</code>，用二进制数字“0”表示，<strong>0的数目等于主机位的长度。</strong></p><p><em>目的</em>： 是为了让掩码与ip地址做按位<code>与</code>运算时用0<strong>遮住原主机数</strong>，而不改变原网络段数字，而且很容易通过0的位数确定子网的主机数</p><h5 id="为何要用子网掩码">为何要用子网掩码？</h5><blockquote><p>子网掩码可以分离出IP地址中的<code>网络地址</code>和<code>主机地址</code>，那为什么要分离呢？</p></blockquote><p>因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即<code>网络地址是否相同</code>。 如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机， 否则就需要路由<code>网关</code>将数据包<code>转发</code>送到目的地。</p><p>设IP地址为192.168.10.2，子网掩码为255.255.255.240，那么子网掩码是怎样来区分网络地址和主机地址的呢。</p><p>主机地址为：0.0.0.2（将掩码取反，然后与运算）</p><h5 id="子网掩码和ip地址的关系">子网掩码和ip地址的关系</h5><blockquote><p>子网掩码是用来判断任意两台计算机的IP地址是否属于同一子网络的根据。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">And按位与运算：</span><br><span class="line">与运算是计算机中一种基本的逻辑运算方式，符号表示为&amp;，也可以表示为 and。</span><br><span class="line">参加运算的两个数据，按二进制位进行“与”运算。</span><br><span class="line">运算规则：0&amp;0=0；0&amp;1=0；1&amp;0=0；1&amp;1=1；</span><br><span class="line">即：两位同时为“1”，结果才为“1”，否则为0</span><br></pre></td></tr></table></figure><p><img src="/2019/06/06_计算机网络系列之IP相关计算/15598304763666.jpg"></p><blockquote><p>网络地址计算小技巧：IP地址和子网掩码做与运算，把IP地址的主机位直接归0，就快速得到网络地址。所以只要一看到IP地址和子网掩码，就能马上确认网络地址。</p></blockquote><h5 id="子网掩码的表示方法">子网掩码的表示方法</h5><p>①、点分十进制表示法 二进制转换十进制，每8位用点号隔开 例如：子网掩码二进制11111111.11111111.11111111.00000000，表示为255.255.255.0</p><p>②、CIDR斜线记法 IP地址/n 例1：192.168.1.100/24，其子网掩码表示为255.255.255.0，二进制表示为11111111.11111111.11111111.00000000 例2：172.16.198.12/20，其子网掩码表示为255.255.240.0，二进制表示为11111111.11111111.11110000.00000000</p><p><strong>不难发现，例1中共有24个１，例2中共有20个１，所以n是这么来的。运营商ISP常用这样的方法给客户分配IP地址。</strong></p><blockquote><p>注：n为1到32的数字，表示子网掩码中网络号的长度，通过n的个数确定子网的主机数=2^(32-n)-2（-2的原因：主机位全为0时表示本网络的网络地址，主机位全为1时表示本网络的广播地址，这是两个特殊地址）。</p></blockquote><p>做子网划分后的IP地址：网络号＋子网号＋子网主机号 举个栗子： 如：192.168.1.100/25，其子网掩码表示：255.255.255.128</p><h4 id="子网">子网</h4><p>子网划分是通过<strong>借用IP地址中若干位【主机地址】来充当子网的【网络地址】，从而将原网络划分为若干子网。</strong></p><p><img src="/2019/06/06_计算机网络系列之IP相关计算/15598306058611.jpg"></p><p>划分子网时，随着子网地址借用主机位数的增多，子网的数目随之增加，但每个子网中的可用主机数逐渐减少。</p><p>如C类地址，原有8位主机位，2^8-2即254个主机地址，默认子网掩码255.255.255.0。(全0或全1不可用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">借用1位主机位，产生2^1-2=0个子网，每个子网有2^7-2个主机地址；</span><br><span class="line">借用2位主机位，产生2^2-2=2个子网，每个子网有2^6-2个主机地址;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h4 id="计算子网掩码">计算子网掩码</h4><h5 id="根据子网数">根据子网数</h5><p>根据子网数，计算子网掩码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1)将子网数目转化为二进制来表示</span><br><span class="line">2)取得该二进制的位数，为 N</span><br><span class="line">3)取得该IP地址的类子网掩码，将其主机地址部分的前N位置1 即得出该IP地址划分子网的子网掩码。</span><br></pre></td></tr></table></figure><blockquote><p>如欲将B类IP地址168.195.0.0划分成27个子网：</p></blockquote><p>1)27=11011 2)该二进制为五位数，<code>N = 5</code> 3)将B类地址的子网掩码255.255.0.0的主机地址<code>前5位置1</code>（B类地址的主机位包括后两个字节，所以这里要把第三个字节的前5位置1），得到 255.255.248.0 即为划分成27个子网的B类IP地址 168.195.0.0的子网掩码（实际上是划成了32-2=30个子网）。</p><p>10101000 11000011 00000000 00000000 11111111 11111111 00000000 00000000 11111111 11111111 11111000 00000000 11111111 11111111 11111000 00000000</p><h5 id="根据主机数">根据主机数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 根据主机数计算子网掩码</span><br><span class="line">2. 根据子网掩码计算子网数</span><br><span class="line">3. 根据子网掩码计算主机数</span><br><span class="line">4. 根据子网掩码确定子网络的起止地址</span><br></pre></td></tr></table></figure><h6 id="根据主机数计算子网掩码">根据主机数计算子网掩码</h6><blockquote><p>把B类地址172.16.0.0划分成若干子网络，每个子网络能容纳500台主机，它的子网掩码是多少？</p></blockquote><p>①把500转换成二进制表示<code>111110100</code> ②统计一下这个二进制的数共有<code>9位</code> ③将子网掩码255.255.255.255<strong>从后向前的9位</strong>变成0 ④这就得到了所要的子网掩码（11111111.11111111.11111110.00000000）<code>255.255.254.0</code>。</p><h6 id="根据子网掩码计算子网数">根据子网掩码计算子网数</h6><blockquote><p>A类IP地址，子网掩码为255.224.0.0，它所能划分的最大有效子网数是多少？</p></blockquote><p>①将子网掩码转换成二进制表示<code>11111111.111</code>00000.00000000.00000000 ②统计一下它的网络位共有<code>11位</code> ③<code>A类</code>地址<code>网络位</code>的基础数是<code>8</code>，二者之间的<code>位数差是3</code> ④最大有效子网数就是<code>2的3次方</code>，即最多可以划分8个子网络。</p><blockquote><p>2的位数差次方</p></blockquote><h6 id="根据子网掩码计算主机数">根据子网掩码计算主机数</h6><blockquote><p>A类IP地址，子网掩码为255.252.0.0，将它划分成若干子网络，每个子网络中可用主机数有多少？</p></blockquote><p>①将子网掩码转换成二进制表示11111111.111111<code>00.00000000.00000000</code> ②统计一下它的主机位共有18位 ③最大可用主机数就是<code>2的18次方减2</code>（除去全是0的网络地址和全是1广播地址），即每个子网络最多有262142台主机可用。</p><blockquote><p>2的主机号长度次方</p></blockquote><h6 id="根据子网掩码确定子网络的起止地址">根据子网掩码确定子网络的起止地址</h6><blockquote><p>B类IP地址172.16.0.0，子网掩码为255.255.192.0，它所能划分的子网络起止地址是多少？</p></blockquote><p>11111111 11111111 <code>11</code>000000 00000000 [255.255.192.0] 11111111 11111111 00000000 00000000 [255.255.255.0]</p><p>①利用子网掩码计算，最多可以划分4个子网络,【差两位，2的2次方=4】 ②利用子网掩码计算，每个子网络可容纳16384台主机（包括网络地址和广播地址）【2的14次方-2】 ③用16384除以256（网段内包括网络地址和广播地址的全部主机数），结果是<code>64</code> ④具体划分网络起止方法如下：</p><p>172.16.0.0～172.16.<code>63</code>.255 172.16.<code>64</code>.0～172.16.127.255 172.16.<code>128</code>.0～172.16.191.255 172.16.<code>192</code>.0～172.16.255.255</p><figure><img src="/2019/06/06_计算机网络系列之IP相关计算/15598058385491.jpg" alt><figcaption>-w556</figcaption></figure><h3 id="推荐阅读参考链接">推荐阅读【参考链接】：</h3><p><a href="https://blog.51cto.com/6930123/2112403" target="_blank" rel="noopener">IP地址和子网划分学习笔记之《IP地址详解》系列</a> <a href="http://www.360doc.com/content/18/0921/19/37113458_788584404.shtml" target="_blank" rel="noopener">什么是子网？什么是子网掩码？</a> <a href="https://baike.baidu.com/item/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/5446046" target="_blank" rel="noopener">百度百科---子网划分</a> <a href="https://blog.csdn.net/xwq911/article/details/45368853" target="_blank" rel="noopener">子网数、主机数与子网掩码的关系</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP </tag>
            
            <tag> 子网掩码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03_Python模块系列之模块与包(17)</title>
      <link href="/2019/06/03_Python%E6%A8%A1%E5%9D%97%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"/>
      <url>/2019/06/03_Python%E6%A8%A1%E5%9D%97%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="目标">目标</h2><ul><li>区分模块、包；</li><li>✅掌握引用模块、包</li><li>✅进阶一点</li></ul><blockquote><p>原本以为今晚可以早早的睡觉，谁知道东西还是蛮多的。。。</p></blockquote><h3 id="第一部分-模块与包">第一部分 模块与包</h3><p>在编程语言中，<code>代码块、函数、类、模块，一直到包</code>，逐级封装，层层调用。</p><figure><img src="/2019/06/03_Python模块系列之模块与包/1.jpg" alt><figcaption>模块与包</figcaption></figure><h4 id="模块module">模块(module)</h4><p><strong>含义</strong> python中每个python文件就是一个模块，每个python文件中，封装类似功能的变量、函数、类型等等，可以被其他的python模块通过import关键字引入重复使用！</p><p><strong>分类</strong> 1. 自定义模块: 如：自己编写的一个py文件； 2. 内置模块： 如：os、sys、random等 3. 第三方模块：requests等</p><p><strong>好处</strong></p><ol type="1"><li>可维护性</li><li>可复用性</li></ol><h4 id="包package">包（package）</h4><p><strong>含义</strong> 包含多个python文件/模块的文件夹，并且文件夹中有一个名称为<strong><strong>init</strong>.py</strong>的特殊声明文件；</p><p><strong>作用</strong> 可以将大量功能相关的python模块包含起来统一管理，同样也可以被其他模块通过import关键字引入重复使用封装的模块和代码。</p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package_a</span><br><span class="line">├── __init__.py</span><br><span class="line">├── module_a1.py</span><br><span class="line">└── module_a2.py</span><br></pre></td></tr></table></figure><p><code>__init__.py</code>的作用</p><ol type="1"><li>Python中package的标识，不能删除（包其实是一个目录，为了和目录做区别，使用了__init__.py）</li><li>定义__all__用来模糊导入(包的调用中介绍)</li><li>编写Python代码(不建议在__init__中写python模块，可以在包中在创建另外的模块来写，尽量保证__init__.py简单）</li></ol><blockquote><p>包名通常为全部小写，避免使用下划线。</p></blockquote><h3 id="第二部分-使用">第二部分 使用</h3><h4 id="导入方法">导入方法</h4><p>常见的是<code>五种</code>引用方式：</p><ol type="1"><li>import <code>module_name</code>：本质是将module_name解释一遍，并将解释结果赋值给module_name；</li><li><code>from module_name</code> import <code>name</code>：本质将module_name中的name变量放到当前程序中运行一边，所以调用的时候直接print(name)就可以打印出name变量的值，切记调用模块的时候只需要import模块名，不需要加.py；</li><li>import <code>module_name1, module_name2,...</code>：导入多个模块；</li><li>from module_name import name <code>as nm</code>：为导入模块取<code>别名</code>；</li><li>from module_name import * ---- <strong>(不建议使用该方法)</strong>；</li></ol><blockquote><p>用<code>typescript</code>的很熟悉上边的写的吧；</p></blockquote><h4 id="模块搜索顺序原理看第三部分">模块搜索顺序🔍【原理看第三部分】</h4><p>不管你在程序中执行了多少次import，一个模块<strong>只会被导入一次</strong>，顺序如下：</p><p><code>import module_name ---&gt; module_name.py ---&gt; module_name.py的路径---&gt;sys.path</code></p><ol type="1"><li>当前执行脚本所在目录</li><li>Python的安装目录</li><li>Python安装目录里的site-packages目录</li></ol><h4 id="示例一-同级目录">示例一 同级目录</h4><figure><img src="/2019/06/03_Python模块系列之模块与包/3.jpg" alt><figcaption>引用示例</figcaption></figure><p>这个示例很简单，但已经把引用的使用罗列清楚了，因为Python不需要export。不像typescript那样有导入就有导出，所以，我们已经引用模块了。</p><blockquote><p>至于如何自定义个包，发布到GitHub，让后让别人用，我想那是不是现在关心的。</p></blockquote><h4 id="示例二-他级目录">示例二 他级目录</h4><p>工作区目录结构如下，实现<strong>moduleA</strong>引用<code>文件夹module下的moduleC</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Pipfile</span><br><span class="line">├── Pipfile.lock</span><br><span class="line">├── module</span><br><span class="line">│   └── moduleC.py</span><br><span class="line">├── moduleA.py</span><br><span class="line">└── moduleB.py</span><br></pre></td></tr></table></figure><blockquote><p>网上有很多实现的例子，但是，为何那样写？ &gt; 还是再开个第三部分吧</p></blockquote><h3 id="第三部分-深入理解引用">第三部分 深入理解引用</h3><p>摘录自：<a href="https://blog.csdn.net/weixin_38256474/article/details/81228492" target="_blank" rel="noopener">Python 3.x可能是史上最详解的【导入（import）】</a></p><h4 id="python运行机制">Python运行机制</h4><p>理解Python在执行import语句（导入内置（Python自个的）或第三方模块（已在sys.path中））时，<strong>进行了啥操作？</strong></p><ol type="1"><li>创建一个新的、空的module对象（它可能包含多个module）；</li><li>将该module对象 插入<strong>sys.modules</strong>中；</li><li>装载module的代码（如果需要，需先编译）；</li><li>执行新的module中对应的代码。</li></ol><blockquote><p>第二步涉及一个概念---sys.modules</p></blockquote><p><a href="https://docs.python.org/3.6/library/sys.html?highlight=sys%20modules#sys.modules" target="_blank" rel="noopener">官网解释</a> <strong>sys.modules</strong>是一个 将模块名称（module_name）映射到已加载的模块（modules） 的<strong>字典</strong>。可用来强制重新加载modules。Python一启动，它将<strong>被加载在内存中。</strong></p><p>当我们<code>导入新modules</code>，sys.modules将<code>自动记录</code>下该module；当第二次再导入该module时，Python将<code>直接</code>到字典中<code>查找</code>，加快运行速度。</p><p>它是个字典，故拥有字典的一切方法，如<code>sys.modules.keys()、sys.modules.values()、sys.modules[‘os’]</code>。但请不要轻易替换字典、或从字典中删除某元素，将可能导致Python运行失败。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.modules)<span class="comment">#打印，查看该字典具体内容。</span></span><br></pre></td></tr></table></figure><p><strong>导入分类</strong> 1. 相对导入： 同一目录下，如第二部分的实例 2. 绝对导入： 如下侧，不同目录的导入</p><p><strong>import分类</strong></p><ul><li>"标准"import，顶部导入;</li><li>嵌套import<ul><li>顺序导入-import</li><li>循环导入/嵌套导入-import</li></ul></li></ul><h5 id="标准import顶部导入">"标准"import，顶部导入</h5><p>在 moduleA 中引用 moduleC <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Pipfile</span><br><span class="line">├── Pipfile.lock</span><br><span class="line">├── module</span><br><span class="line">│   └── moduleC.py</span><br><span class="line">├── moduleA.py</span><br><span class="line">└── moduleB.py</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">this is moduleA</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line">BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line"><span class="comment"># 当前文件的绝对路径</span></span><br><span class="line">print(os.path.abspath(__file__))</span><br><span class="line"><span class="comment"># 获取目录</span></span><br><span class="line">print(BASE_DIR)</span><br><span class="line"><span class="comment"># 系统路径下加载</span></span><br><span class="line">sys.path.append(BASE_DIR)</span><br><span class="line">print(<span class="string">'\n'</span>)</span><br><span class="line">print(sys.path)</span><br><span class="line">print(<span class="string">'\n'</span>)</span><br><span class="line">print(sys.modules.keys())</span><br><span class="line">print(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module.moduleC <span class="keyword">import</span> add</span><br><span class="line"></span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">this is moduleC</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><figure><img src="/2019/06/03_Python模块系列之模块与包/5.jpg" alt><figcaption>第五</figcaption></figure><figure><img src="/2019/06/03_Python模块系列之模块与包/4.png" alt><figcaption>第四</figcaption></figure><h4 id="嵌套import">嵌套import</h4><p>有了上侧以及命名空间的知识，相对下侧图解，就容易理解了。</p><h5 id="顺序导入-import">顺序导入-import</h5><figure><img src="/2019/06/03_Python模块系列之模块与包/10.png" alt><figcaption>10</figcaption></figure><p>PS：各个模块的Local命名空间的独立的。即： test模块 import moduleA后，只能访问moduleA模块，不能访问moduleB模块。虽然moduleB已加载到内存中，如需访问，还得明确地在test模块 import moduleB。实际上打印locals()，字典中只有moduleA，没有moduleB。</p><h5 id="循环导入嵌套导入-import">循环导入/嵌套导入-import</h5><figure><img src="/2019/06/03_Python模块系列之模块与包/20.png" alt><figcaption>20</figcaption></figure><p>形如from moduleB import ClassB语句，根据Python内部import机制，执行细分步骤： 1. 在sys.modules中查找 符号“moduleB”； 2. 如果符号“moduleB”存在，则获得符号“moduleB”对应的module对象； 从的   dict__中获得 符号“ClassB”对应的对象。如果“ClassB”不存在，则抛出异常“ImportError: cannot import name ‘classB’” 3. 如果符号“moduleB”不存在，则创建一个新的 module对象。不过此时该新module对象的   dict   为空。然后执行moduleB.py文件中的语句，填充的   dict   。</p><p><strong>总结：from moduleB import ClassB有两个过程，先from module，后import ClassB。</strong></p><figure><img src="/2019/06/03_Python模块系列之模块与包/30.png" alt><figcaption>30</figcaption></figure><p>当然将moduleA.py语句 from moduleB import ClassB改为：import moduleB，将在第二次执行moduleB.py语句from moduleA import ClassA时报错：<code>ImportError: cannot import name ‘classA’</code></p><p><strong>解决这种circular import循环导入的方法：</strong> 例比：安装无线网卡时，需上网下载网卡驱动； 安装压缩软件时，从网上下载的压缩软件安装程序是被压缩的文件。</p><p>方法1—–&gt;延迟导入（lazy import）：把import语句写在方法/函数里，将它的作用域限制在局部。（此法可能导致性能问题） 方法2—–&gt;将from x import y改成import x.y形式 方法3—–&gt;组织代码（重构代码）：更改代码布局，可合并或分离竞争资源。 合并—–&gt;都写到一个.py文件里； 分离–&gt;把需要import的资源提取到一个第三方.py文件中。 总之，将循环变成单向。</p><p>How to avoid Python circle import error？ 代码布局、（架构）设计问题，解决之道是：将循环变成单向。采用分层、用时导入、相对导入（层次建议不要超过两个）</p><h3 id="參考">參考</h3><p><a href="http://m.imooc.com/article/details?article_id=247114" target="_blank" rel="noopener">PYTHON中的包和模块</a></p><p><a href="https://blog.csdn.net/weixin_38256474/article/details/81228492" target="_blank" rel="noopener">Python 3.x可能是史上最详解的【导入（import）】</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之--阶段总结与补充【16】</title>
      <link href="/2019/06/02_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/"/>
      <url>/2019/06/02_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="目标">目标</h2><ul><li>回顾Python面向对象</li><li>✅掌握<strong>pipenv虚拟环境</strong>的基本使用</li></ul><figure><img src="/2019/06/02_Python基础系列之阶段总结/0.jpg" alt><figcaption>0</figcaption></figure><p>在学习过程中也遇到一些疑惑，摸索了不同的形式、方法，有了一些结论，诸如：</p><ol type="1"><li>文章的面向群体--有一定编程基础的；属于个人学习📝，不可能面面俱到；</li><li>文章的形式--如果没有递进深入与实例，仅停留在基本；那是刷流氓；</li><li>学习的目标依旧是--向机器学习靠拢，出于好奇，挑战下自我。</li></ol><blockquote><p>也许好奇才是真正让我学习Python的原有； &gt; 不论对错，过程中渐渐培养了专注、思考、探索、总结，想必是值得。 勇敢走出舒适区，去做有意思的事，好好学数学 😆</p></blockquote><p>Python基础系列到此就要告一段落了，该部分主要包含了以下几件事</p><ol type="1"><li>迈出了开始学习Python的第一步；</li><li>归纳总结常用的数据类型、方法、函数等，可能会穿插些稍微深入些的知识点；</li><li>查漏补缺，在学习过程中更加深入了理解一些概念、原理。</li></ol><blockquote><p>接下来的安排 &gt; 因为Node.js属于日常工作范畴，工作之余换种心情😆</p></blockquote><ol type="1"><li>继续学习Python相关知识，模块、框架；</li><li>开始试着写项目，至于类型，在过程中再确定吧；</li><li>开始<strong>还</strong>曾经落下的<strong>数学📚</strong>，可能会分享相关内容，只是写文章太费时间了。。。；</li><li>希望在不久的将来，开始试着学习机器学习。</li></ol><h3 id="第一部分-python-面向对象">第一部分 Python 面向对象</h3><h3 id="第二部分-pipenv虚拟环境">第二部分 pipenv虚拟环境</h3><h4 id="pipenv-是什么">1. pipenv 是什么</h4><p><a href="https://github.com/pypa/pipenv" target="_blank" rel="noopener">官网地址</a> Pipenv is a production-ready tool that aims to bring the best of all <code>packaging</code> worlds to the Python world. It harnesses <strong>Pipfile, pip, and virtualenv</strong> into one single command.</p><p>大概意思就是：<code>Pipenv 可以为你的项目自动地创建和管理一个虚拟环境。</code></p><p>如果对Node熟悉的话，应该了解:</p><ol type="1"><li>nvm 管理nodejs的版本，可自由切换；</li><li>npm: 管理工具，可方便下载第三方模块；</li><li>package.json: 项目文件，记录一些模块依赖信息、配置信息等</li></ol><p>大概可以理解为：对比pipenv: &gt; pipenv = nvm + npm;</p><p>当然这只是个简单的。便于学习的对比；</p><p><strong>如有不对❌，敬请指出</strong></p><h4 id="pipenv-能解决什么">2. pipenv 能解决什么❓</h4><ol type="1"><li>你不再需要手动创建虚拟环境，Pipenv 为你自动创建。简单地说就是 pipenv 和 virtualenv 一起工作。</li><li>管理 requirements.txt 文件会导致一些问题，所以 Pipenv 用 Pipfile 和 Pipfile.lock 替代 requirements.txt，更适合于一般的使用场景。</li><li>安全。广泛地使用 Hash 校验，能够自动曝露安全漏洞。</li><li>随时查看图形化的依赖关系。</li><li>通过加载 .env 文件简化开发流程。</li></ol><h4 id="安装使用">3. 安装使用</h4><p><a href="https://github.com/pypa/pipenv" target="_blank" rel="noopener">官网地址</a>有对应的安装方法，下边以Mac为例;</p><p>前体是已经安装过Python、pip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install pipenv</span><br></pre></td></tr></table></figure><h4 id="实例一">4. 实例一</h4><p>目标</p><ul><li>初识环境</li><li>掌握基本的操作</li></ul><p>多余代码太多，实例一共包含以下几步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 初始化一个虚拟环境；</span><br><span class="line">2. 了解下虚拟环境内容；</span><br><span class="line">3. 新建文件，并运行；</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 初始化一个虚拟环境；</span></span><br><span class="line">hhw<span class="number">-4</span>:pythonEnv hhw$ pipenv install</span><br><span class="line">Creating a virtualenv <span class="keyword">for</span> this project…</span><br><span class="line">Pipfile: /Users/hhw/Desktop/pythonEnv/Pipfile</span><br><span class="line">Using /usr/local/Cellar/pipenv/<span class="number">2018.11</span><span class="number">.26</span>_2/libexec/bin/python3<span class="number">.7</span> (<span class="number">3.7</span><span class="number">.3</span>) to create virtualenv…</span><br><span class="line">⠋ Creating virtual environment...Already using interpreter /usr/local/Cellar/pipenv/<span class="number">2018.11</span><span class="number">.26</span>_2/libexec/bin/python3<span class="number">.7</span></span><br><span class="line">Using real prefix <span class="string">'/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7'</span></span><br><span class="line">New python executable <span class="keyword">in</span> /Users/hhw/.local/share/virtualenvs/pythonEnv-Vx1xxtfj/bin/python3<span class="number">.7</span></span><br><span class="line">Also creating executable <span class="keyword">in</span> /Users/hhw/.local/share/virtualenvs/pythonEnv-Vx1xxtfj/bin/python</span><br><span class="line">Installing setuptools, pip, wheel...</span><br><span class="line">done.</span><br><span class="line"></span><br><span class="line">✔ Successfully created virtual environment!</span><br><span class="line">Virtualenv location: /Users/hhw/.local/share/virtualenvs/pythonEnv-Vx1xxtfj</span><br><span class="line">Creating a Pipfile <span class="keyword">for</span> this project…</span><br><span class="line">Pipfile.lock <span class="keyword">not</span> found, creating…</span><br><span class="line">Locking [dev-packages] dependencies…</span><br><span class="line">Locking [packages] dependencies…</span><br><span class="line">Updated Pipfile.lock (a65489)!</span><br><span class="line">Installing dependencies <span class="keyword">from</span> Pipfile.lock (a65489)…</span><br><span class="line">  🐍   ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ <span class="number">0</span>/<span class="number">0</span> — <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">To activate this project<span class="string">'s virtualenv, run pipenv shell.</span></span><br><span class="line"><span class="string">Alternatively, run a command inside the virtualenv with pipenv run.</span></span><br><span class="line"><span class="string">hhw-4:pythonEnv hhw$</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. 新建文件，并运行；</span></span><br><span class="line"><span class="comment"># 下载requests模块</span></span><br><span class="line">hhw<span class="number">-4</span>:pythonEnv hhw$  pipenv install requests</span><br><span class="line">Installing requests…</span><br><span class="line">Adding requests to Pipfile<span class="string">'s [packages]…</span></span><br><span class="line"><span class="string">✔ Installation Succeeded</span></span><br><span class="line"><span class="string">Pipfile.lock (444a6d) out of date, updating to (a65489)…</span></span><br><span class="line"><span class="string">Locking [dev-packages] dependencies…</span></span><br><span class="line"><span class="string">Locking [packages] dependencies…</span></span><br><span class="line"><span class="string">✔ Success!</span></span><br><span class="line"><span class="string">Updated Pipfile.lock (444a6d)!</span></span><br><span class="line"><span class="string">Installing dependencies from Pipfile.lock (444a6d)…</span></span><br><span class="line"><span class="string">  🐍   ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ 5/5 — 00:00:02</span></span><br><span class="line"><span class="string">To activate this project'</span>s virtualenv, run pipenv shell.</span><br><span class="line">Alternatively, run a command inside the virtualenv <span class="keyword">with</span> pipenv run.</span><br><span class="line">hhw<span class="number">-4</span>:pythonEnv hhw$ vim test.py</span><br></pre></td></tr></table></figure><p>用 ls 命令查看当前项目目录，你会发现有两个文件：<code>Pipfile 和 Pipfile.lock 。</code></p><p>Pipfile 里有最新安装的包文件的信息，如名称、版本等。用来 在重新安装项目依赖或与他人共享项目时，你可以用 Pipfile 来跟踪项目依赖。 Pipfile.lock 则包含你的系统信息，所有已安装包的依赖包及其版本信息，以及所有安装包及其依赖包的 Hash 校验信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py 内容</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'https://httpbin.org/ip'</span>)</span><br><span class="line">print(<span class="string">'你的 IP 地址是 &#123;0&#125;'</span>.format(response.json()[<span class="string">'origin'</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pipenv run python main.py</span><br><span class="line">你的 IP 地址是 <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br></pre></td></tr></table></figure><p><strong>实例一 总结</strong></p><p>以上展示了如何创建一个虚拟环境、如何下载一个模块，在虚拟环境中运行；</p><p>也许不太直观，画了两个图，虚拟环境自己玩儿自己的。</p><p><img src="/2019/06/02_Python基础系列之阶段总结/1.jpg"></p><figure><img src="/2019/06/02_Python基础系列之阶段总结/2.jpg" alt><figcaption>虚拟环境</figcaption></figure><p>按实际需求来</p><ol type="1"><li>你的代码给别人，别人怎么正常运行？</li><li>pipenv 常用命令有哪些？</li></ol><p>问题一：冻结Pipfile；类比<code>package-lock.json</code></p><p>冻结就相当于将项目所使用的第三方库列表进行打包输出,类比<code>package-lock.json</code> 通过更新Pipfile.lock来冻结库名称及其版本，以及其依赖关系的列表。需要使用lock参数：<code>pipenv lock</code></p><p>被人怎么用？类比 <code>npm install</code> <code>pipenv install</code> Pipenv会在项目文件夹下自动寻找Pipfile和Pipfile.lock文件，创建一个新的虚拟环境并安装必要的软件包。</p><p>问题二： 可选参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ pipenv</span><br><span class="line">Usage: pipenv [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --update         更新Pipenv &amp; pip</span><br><span class="line">  --where          显示项目文件所在路径</span><br><span class="line">  --venv           显示虚拟环境实际文件所在路径</span><br><span class="line">  --py             显示虚拟环境Python解释器所在路径</span><br><span class="line">  --envs           显示虚拟环境的选项变量</span><br><span class="line">  --rm             删除虚拟环境</span><br><span class="line">  --bare           最小化输出</span><br><span class="line">  --completion     完整输出</span><br><span class="line">  --man            显示帮助页面</span><br><span class="line">  --three / --two  使用Python 3/2创建虚拟环境（注意本机已安装的Python版本）</span><br><span class="line">  --python TEXT    指定某个Python版本作为虚拟环境的安装源</span><br><span class="line">  --site-packages  附带安装原Python解释器中的第三方库</span><br><span class="line">  --jumbotron      不知道啥玩意....</span><br><span class="line">  --version        版本信息</span><br><span class="line">  -h, --help       帮助信息</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 命令参数</span><br><span class="line">Commands:</span><br><span class="line">  check      检查安全漏洞</span><br><span class="line">  graph      显示当前依赖关系图信息</span><br><span class="line">  install    安装虚拟环境或者第三方库</span><br><span class="line">  lock       锁定并生成Pipfile.lock文件</span><br><span class="line">  open       在编辑器中查看一个库</span><br><span class="line">  run        在虚拟环境中运行命令</span><br><span class="line">  shell      进入虚拟环境</span><br><span class="line">  uninstall  卸载一个库</span><br><span class="line">  update     卸载当前所有的包，并安装它们的最新版本</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定位项目路径</span></span><br><span class="line">$ pipenv --where</span><br><span class="line"><span class="comment"># 定位虚拟环境</span></span><br><span class="line">$ pipenv --venv</span><br><span class="line"><span class="comment"># 定位Python解释器</span></span><br><span class="line">$ pipenv --py</span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">$ pipenv install</span><br><span class="line"><span class="comment"># 卸载所有的包：</span></span><br><span class="line">$ pipenv uninstall --all</span><br><span class="line"><span class="comment"># 依赖关系</span></span><br><span class="line">$ pipenv graph</span><br><span class="line"><span class="comment"># 生成lock文件</span></span><br><span class="line">$ pipenv lock</span><br><span class="line"><span class="comment"># 安装开发环境依赖：</span></span><br><span class="line">$ pipenv install pytest --dev</span><br></pre></td></tr></table></figure><h4 id="实例二">5 实例二</h4><p>目标 - vscode 配置</p><p>实例一中直接运行，已经完全ok，但是写代码，我还是不会选择文本编辑器，，，</p><p>打开vscode，ヾ(｡｀Д´｡)我擦，找不到requests,思考片刻，因为setting.json中已经配置了python解释器【系统级别的】； 但是<strong>之后我们都不在这么玩儿了，毕竟会乱的</strong> 同样建议再项目目录中配置各自的配置项目</p><p><img src="/2019/06/02_Python基础系列之阶段总结/3.jpg"> <img src="/2019/06/02_Python基础系列之阶段总结/4.jpg"> <img src="/2019/06/02_Python基础系列之阶段总结/5.jpg"> <img src="/2019/06/02_Python基础系列之阶段总结/6.jpg"></p><p><strong>配置完毕</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hhw-4:pythonEnv hhw$ python3 test.py </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    import requests</span><br><span class="line">ModuleNotFoundError: No module named &apos;requests&apos;</span><br><span class="line">hhw-4:pythonEnv hhw$ pipenv run python test.py </span><br><span class="line">你的 IP 地址是 112.64.61.61, 112.64.61.61</span><br></pre></td></tr></table></figure><p>一直没找到一个合适的图来描述pipenv...</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 阶段总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之封装继承多态【15】</title>
      <link href="/2019/06/01_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/06/01_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="目标">目标</h2><ul><li>温故面向对象三大特性<ul><li>Python的私有是真的吗？</li><li>Python的多继承是什么？</li></ul></li><li>了解下魔方方法</li></ul><h3 id="第一部分-魔法方法">第一部分 魔法方法</h3><p>相信我们初学者都会有个疑问，下边的意思是啥？？为啥要写这个？ &gt; 反正我是先忽略这个问题，打算在学的过程中慢慢明白😆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span> :</span><br></pre></td></tr></table></figure><p><a href="https://www.zhihu.com/question/49136398/answer/114438004" target="_blank" rel="noopener">知乎的回答</a>： <code>__name__</code> 是当前模块名，当模块被直接运行时模块名为 <code>__main__</code> 。这句话的意思就是，<strong>当模块被直接运行时，以下代码块将被运行，当模块是被导入时，代码块不被运行。</strong></p><p>还有很多类似的，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__init__ :      构造函数，在生成对象时调用</span><br><span class="line">__del__ :       析构函数，释放对象时使用</span><br><span class="line">__repr__ :      打印，转换</span><br><span class="line">__setitem__ :   按照索引赋值</span><br><span class="line">__getitem__:    按照索引获取值</span><br><span class="line">__len__:        获得长度</span><br><span class="line">__cmp__:        比较运算</span><br><span class="line">__call__:       调用</span><br><span class="line">__add__:        加运算</span><br><span class="line">__sub__:        减运算</span><br><span class="line">__mul__:        乘运算</span><br><span class="line">__div__:        除运算</span><br><span class="line">__mod__:        求余运算</span><br><span class="line">__pow__:        幂</span><br></pre></td></tr></table></figure><p>使用实例，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.__len__()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"我被回收了！"</span>)</span><br><span class="line">obj = Foo()</span><br><span class="line"><span class="keyword">del</span> obj</span><br></pre></td></tr></table></figure><blockquote><p>等用到了，再看下 😆</p></blockquote><h3 id="第二部分-封装继承多态">第二部分 封装继承多态</h3><p><strong>封装</strong> 封装：将内部实现包裹起来，对外透明，提供api接口进行调用的机制</p><p>优点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 将变化隔离；</span><br><span class="line">2. 便于使用；</span><br><span class="line">3. 提高复用性；</span><br><span class="line">4. 提高安全性；</span><br></pre></td></tr></table></figure><p><strong>原则</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 将不需要对外提供的内容都隐藏起来；</span><br><span class="line">2. 把属性都隐藏，提供公共方法对其访问。</span><br></pre></td></tr></table></figure><p><strong>继承</strong> 即一个派生类（derived class）继承父类（base class）的变量和方法。</p><p><strong>多态：</strong>根据对象类型的不同以不同的方式进行处理。</p><p>前提：①类的继承关系 ②要有方法重写。</p><p><strong>父类替换子类</strong>： super(子类名, self).方法名()</p><blockquote><p>以上概念将通过以下几个实例来说明：</p></blockquote><h4 id="实例一-基本继承">实例一 基本、继承</h4><p><strong>首先试着下边的三个问题与代码的结果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Python的私有方法真的私有吗？</span><br><span class="line"><span class="number">2.</span> Python外部是否可以更改私有属性？</span><br><span class="line"><span class="number">3.</span> 关键字property是什么意思？</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sex, age)</span>:</span></span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="comment"># 定义一个私有变量</span></span><br><span class="line">        self.__sex = sex</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"性别：%s 年龄：%d "</span> % (self.__sex, self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">base = Person(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">print(base.speak())</span><br><span class="line">print(base.age)</span><br><span class="line"><span class="comment"># 调用私用变量： _类名__属性</span></span><br><span class="line">print(base._Person__sex)</span><br><span class="line"><span class="comment"># print(base.__sex)</span></span><br><span class="line"><span class="comment"># AttributeError: 'Person' object has no attribute '__sex'</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"===以上区分调用变量===="</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sex, age, name)</span>:</span></span><br><span class="line">        <span class="comment"># 调用父类的实例化方法</span></span><br><span class="line">        Person.__init__(self, sex, age)</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hide</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'示范隐藏的hide方法'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHeight</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__height</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setetHeight</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> height &lt;= <span class="number">0</span> <span class="keyword">or</span> height &gt; <span class="number">300</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'身高必须在0～300cm之间'</span>)</span><br><span class="line">        self.__height = height</span><br><span class="line"></span><br><span class="line">    <span class="comment"># property 将geter seter实例为类变量</span></span><br><span class="line">    height = property(getHeight, setetHeight)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建User对象</span></span><br><span class="line">u = User(<span class="string">"男"</span>, <span class="number">20</span>, <span class="string">"Python"</span>)</span><br><span class="line">print(u.name)</span><br><span class="line"><span class="comment">#  seter 方法过滤判断</span></span><br><span class="line"><span class="comment"># u.height = 0</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">File "class.1.py", line 47, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    u.height = 0</span></span><br><span class="line"><span class="string">  File "class.1.py", line 37, in setetHeight</span></span><br><span class="line"><span class="string">    raise ValueError('身高必须在0～300cm之间'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 走setter方法</span></span><br><span class="line">u.height = <span class="number">1</span></span><br><span class="line">print(u.height)</span><br><span class="line"><span class="comment"># 直接更改内部变量</span></span><br><span class="line">u._User__height = <span class="number">0</span></span><br><span class="line">print(u._User__height)</span><br><span class="line">print(u.height)</span><br></pre></td></tr></table></figure><p><strong>其实也不难</strong></p><blockquote><p>结果</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">性别：<span class="number">1</span> 年龄：<span class="number">100</span> </span><br><span class="line"><span class="comment"># 为何是打印None?</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">===以上区分调用变量====</span><br><span class="line">Python</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="实例二-多继承">实例二 多继承</h4><p>该部分摘录自<a href="https://hanjianwei.com/2013/07/25/python-mro/" target="_blank" rel="noopener">Python的方法解析顺序(MRO)</a></p><p>先思考几个问题：</p><ol type="1"><li>多继承顺序的规则是什么？</li><li>Python中<strong>MRO</strong>的三种方式是什么？</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模块inspect：检查运行模块的一些基本信息</span></span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"A.show()"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"C.show()"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __mro__ 等价于 inspect.getmro</span></span><br><span class="line"><span class="comment"># print(D.__mro__)</span></span><br><span class="line">print(inspect.getmro(D))</span><br><span class="line">x = D()</span><br><span class="line">x.show()</span><br></pre></td></tr></table></figure><figure><img src="/2019/06/01_Python基础系列之面向对象/3.svg" alt><figcaption>菱形</figcaption></figure><p>按照深度遍历，其顺序为 <strong>[D, B, A, object, C, A, object]</strong>，重复类只保留最后一个，因此变为 <strong>[D, B, C, A, object]</strong>。</p><p><strong>结果是</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</span><br><span class="line">C.show()</span><br></pre></td></tr></table></figure><blockquote><p>Python 至少有三种不同的 MRO：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 经典类（classic <span class="class"><span class="keyword">class</span>）的深度遍历。</span></span><br><span class="line"><span class="class">2. <span class="title">Python</span> 2.2 的新式类（<span class="title">new</span>-<span class="title">style</span> <span class="title">class</span>）预计算。</span></span><br><span class="line"><span class="class">3. <span class="title">Python</span> 2.3 的新式类的 <span class="title">C3</span> 算法。它也是 <span class="title">Python</span> 3 唯一支持的方式。</span></span><br></pre></td></tr></table></figure><ol type="1"><li>经典类</li></ol><p>经典类的遍历顺序为： 从左至右的深度优先遍历。以上述「菱形继承」为例，其查找顺序为 [D, B, A, C, A]，如果只保留重复类的第一个则结果为 <strong>[D, B, A, C]</strong></p><ol start="2" type="1"><li><p>2.2 新式类的执行结果<code>如上例子所示</code>，但其中有问题，</p></li><li><p>C3 现在Python采用的方式</p></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(D, E)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(D, F)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(B, C)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.__mro__</span><br><span class="line">(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.F'&gt;, &lt;type 'object'&gt;)</span><br></pre></td></tr></table></figure><p><img src="/2019/06/01_Python基础系列之面向对象/4.svg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">L[object] = [object]</span><br><span class="line">L[D] = [D, object]</span><br><span class="line">L[E] = [E, object]</span><br><span class="line">L[F] = [F, object]</span><br><span class="line">L[B] = [B, D, E, object]</span><br><span class="line">L[C] = [C, D, F, object]</span><br><span class="line">L[A] = [A] + merge(L[B], L[C], [B], [C])</span><br><span class="line">     = [A] + merge([B, D, E, object], [C, D, F, object], [B], [C])</span><br><span class="line">     = [A, B] + merge([D, E, object], [C, D, F, object], [C])</span><br><span class="line">     = [A, B, C] + merge([D, E, object], [D, F, object])</span><br><span class="line">     = [A, B, C, D] + merge([E, object], [F, object])</span><br><span class="line">     = [A, B, C, D, E] + merge([object], [F, object])</span><br><span class="line">     = [A, B, C, D, E, F] + merge([object], [object])</span><br><span class="line">     = [A, B, C, D, E, F, object]</span><br></pre></td></tr></table></figure><blockquote><p>说实在的没看懂 &gt; 最近没更新，是在找学数学方面的资源， &gt; 很开心，正在学</p></blockquote><h4 id="实例三-多态">实例三 多态</h4><blockquote><p>这个似乎很好理解</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kind</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"i am animal"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kind</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"i am a dog"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kind</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"i am a cat"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个函数接收一个animal参数，并调用它的kind方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_kind</span><span class="params">(animal)</span>:</span></span><br><span class="line">    animal.kind()</span><br><span class="line"></span><br><span class="line">d = Dog()</span><br><span class="line">c = Cat()</span><br><span class="line"></span><br><span class="line">show_kind(d)</span><br><span class="line">show_kind(c)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">i am a dog</span></span><br><span class="line"><span class="string">i am a cat</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h4 id="实例四-super">实例四 super</h4><p>如果想<strong>让父类替换子类</strong>，那么既可以用super()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        print(<span class="string">"父类的__init__方法被执行了！"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"父类的show方法被执行了！"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        <span class="comment"># super(子类名, self).方法名()</span></span><br><span class="line">        super(B, self).__init__(name=name)</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(B, self).show()</span><br><span class="line"></span><br><span class="line">obj = B(<span class="string">"jack"</span>, <span class="number">18</span>)</span><br><span class="line">obj.show()</span><br></pre></td></tr></table></figure><p>参考链接</p><p><a href="https://hanjianwei.com/2013/07/25/python-mro/" target="_blank" rel="noopener">Python的方法解析顺序(MRO)</a></p><p><a href="https://www.cnblogs.com/geekmao/p/7576441.html" target="_blank" rel="noopener">图解Python 【第六篇】：面向对象-类-进阶篇</a> <a href="https://blog.csdn.net/yanbober/article/details/8713250" target="_blank" rel="noopener">堆栈</a> <a href="https://www.cnblogs.com/geaozhang/p/7111961.html" target="_blank" rel="noopener">内存管理</a> <a href="https://blog.csdn.net/onlyanyz/article/details/45605773" target="_blank" rel="noopener">内存</a> <a href="http://stor.51cto.com/art/201901/591039.htm" target="_blank" rel="noopener">深入内存</a> <a href="https://blog.csdn.net/secretx/article/details/81100920" target="_blank" rel="noopener">python内存管理--分层分配】</a> <a href="https://zhuanlan.zhihu.com/p/40809619" target="_blank" rel="noopener">内存</a></p><p><a href="https://hanjianwei.com/2013/07/25/python-mro/" target="_blank" rel="noopener">Python的方法解析顺序(MRO)</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之面向对象编程【14】</title>
      <link href="/2019/05/26_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/05/26_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/26_Python基础系列之面向对象/1.png" width="50%" height="50%" align="center"> 摘要内容...... <a id="more"></a></p><h2 id="目标">目标</h2><ul><li>✅回顾面向过程、面向对象编程</li><li>✅回顾类与对象中的常用概念</li><li>✅对类的基本操作</li></ul><h3 id="第一部分-面向过程与面向对象">第一部分 面向过程与面向对象</h3><blockquote><p>第一部分只要是回顾下概念、区别。 &gt; 可以跳过</p></blockquote><h4 id="面向过程-opp">1 面向过程 OPP</h4><blockquote><p>相信大家学习编程的时候，刚接触的就是C语言吧，还记得那个main函数么</p></blockquote><p><code>“面向过程”(Procedure Oriented)</code>是一种以<strong>过程为中心的编程思想</strong>。就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p><figure><img src="/2019/05/26_Python基础系列之面向对象/1.png" alt><figcaption>面向过程</figcaption></figure><h4 id="面向对象-oop">2 面向对象 OOP</h4><p><strong>面向对象程序设计（英语：Object-oriented programming，缩写：OOP）</strong>是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。它可能<code>包含</code>数据、属性、代码与方法。</p><p><code>对象</code>则指的是<code>类</code>的<code>实例</code>。</p><p>它将对象作为程序的<code>基本单元</code>，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象.<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">摘录自维基百科</a></p><figure><img src="/2019/05/26_Python基础系列之面向对象/" alt><figcaption>面向过程</figcaption></figure><p>三大特性是： - 封装 - 继承 - 多态</p><p>五大基本原则 - 单一职责原则SRP(Single Responsibility Principle) - 开放封闭原则OCP(Open－Close Principle) - 替换原则(the Liskov Substitution Principle LSP) - 依赖原则(the Dependency Inversion Principle DIP) - 接口分离原则(the Interface Segregation Principle ISP)</p><h4 id="二者对比">3. 二者对比</h4><blockquote><p>简单的把二者总结，我觉得就是耍流氓，所以这部分还是去搜索吧 -—___---</p></blockquote><h3 id="第二部分-python-面向对象">第二部分 Python 面向对象</h3><h4 id="类-常见概念">1 类 常见概念</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类，Python可以多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    baseDate = <span class="string">"20190526"</span></span><br><span class="line">    <span class="comment"># self参数指向当前实例自身</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, day=<span class="number">0</span>, month=<span class="number">0</span>, year=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.day = day</span><br><span class="line">        self.month = month</span><br><span class="line">        self.year = year</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="comment"># cls 指向当前类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_string</span><span class="params">(cls, date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">        date1 = cls(day, month, year)</span><br><span class="line">        <span class="keyword">return</span> date1</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_date_valid</span><span class="params">(date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">        <span class="keyword">return</span> day &lt;= <span class="number">31</span> <span class="keyword">and</span> month &lt;= <span class="number">12</span> <span class="keyword">and</span> year &lt;= <span class="number">3999</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例（类Date）</span></span><br><span class="line">date1 = Date(<span class="number">26</span>, <span class="number">5</span>, <span class="number">2019</span>)</span><br><span class="line"><span class="comment"># 实例变量</span></span><br><span class="line">date1.nextDay = <span class="string">"20190527"</span>;</span><br><span class="line"><span class="comment"># 初始化，自动调用 __init___</span></span><br><span class="line">print(<span class="string">"初始化: year %s mounth %s day %s, nextDay"</span> % (date1.year, date1.month, date1.day, date1.nextDay))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类方法</span></span><br><span class="line">date2 = Date.from_string(<span class="string">'26-05-2019'</span>)</span><br><span class="line">print(date2)</span><br><span class="line">print(<span class="string">"类方法: year %s mounth %s day %s"</span> % (date2.year, date2.month, date2.day))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例方法</span></span><br><span class="line">is_date = Date.is_date_valid(<span class="string">'11-09-2012'</span>)</span><br><span class="line">print(<span class="string">"实例方法: %s"</span> % (is_date))</span><br><span class="line"><span class="comment"># 类属性</span></span><br><span class="line">print(<span class="string">"类属性： %s, id: %s"</span> % (Date.baseDate, id(Date.baseDate)))</span><br><span class="line"><span class="comment"># 重新复制类属性</span></span><br><span class="line">Date.baseDate = <span class="string">"20200101"</span></span><br><span class="line">print(<span class="string">"fake🆕类属性： %s, id: %s"</span> % (Date.baseDate, id(Date.baseDate)))</span><br></pre></td></tr></table></figure><p><strong>返回值</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化: year 2019 mounth 5 day 26, nextDay 20190527</span><br><span class="line">&lt;__main__.Date object at 0x101bab630&gt;</span><br><span class="line">类方法: year 2019 mounth 5 day 26</span><br><span class="line">实例方法: True</span><br><span class="line">类属性： 20190526, id: 4323995760</span><br><span class="line">fake🆕类属性： 20200101, id: 4323996336</span><br></pre></td></tr></table></figure></p><figure><img src="/2019/05/26_Python基础系列之面向对象/2.jpg" alt><figcaption>内存图</figcaption></figure><p><strong>概念定义</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">类(Class): 用来描述具有相同属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。其中的对象被称作类的实例。</span><br><span class="line">实例：也称对象。通过类定义的初始化方法，赋予具体的值，成为一个&quot;有血有肉的实体&quot;。</span><br><span class="line">实例化：创建类的实例的过程或操作。</span><br><span class="line">实例变量：定义在实例中的变量，只作用于当前实例。</span><br><span class="line">类变量：类变量是所有实例公有的变量。类变量定义在类中，但在方法体之外。</span><br><span class="line">数据成员：类变量、实例变量、方法、类方法、静态方法和属性等的统称。</span><br><span class="line">方法：类中定义的函数。</span><br><span class="line">静态方法：不需要实例化就可以由类执行的方法</span><br><span class="line">类方法：类方法是将类本身作为对象进行操作的方法。</span><br></pre></td></tr></table></figure><h4 id="类方法实例方法">2 类方法、实例方法</h4><p>当搜索Python类时，有很多人再问一个问题</p><blockquote><p>实例方法、类方法的使用场景是什么❓ &gt; 区别是什么❓</p></blockquote><p>关于这个问题，搜了不少资源，把我认为比较好的分享出来，希望对大家有用</p><h4 id="应用场景举例">应用场景举例</h4><p><a href="https://www.zhihu.com/question/20021164/answer/18224953" target="_blank" rel="noopener">摘录自知乎</a></p><p><strong>应用场景</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 构造前交互</span><br><span class="line">2. 特殊构造函数</span><br><span class="line">3. __new__等</span><br><span class="line">4. 为函数提供子类hook点</span><br></pre></td></tr></table></figure><p><strong>相比staticmethod</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 方法可以判断出自己是通过基类被调用，还是通过某个子类被调用</span><br><span class="line">2. 通过子类调用时，方法可以返回子类的实例而非基类的实例</span><br><span class="line">3. 通过子类调用时，方法可以调用子类的其他classmethod</span><br></pre></td></tr></table></figure><p><strong>建议：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 除非能说出合理的理由，否则能用classmethod的时候就使用classmethod</span><br><span class="line">2. 将类的定义改造成另外某种语义的时候使用metaclass，实现类的业务上的多态使用classmethod</span><br><span class="line">3. 对类的用户可见的功能使用classmethod，对类的用户不可见的功能可以考虑使用metaclass</span><br><span class="line">4. 没疯用classmethod，疯掉之后可以metaclass满天飞</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>Python中的<strong>classmethod（和staticmethod）并不止拥有美学上（或者命名空间上）的意义</strong>，而是可以实际<code>参与多态的、足够纯粹的OOP功能</code>.</p><p><strong>原理</strong>在于Python中类可以作为<strong>first class的对象使用</strong>，很大程度上替代其他OOP语言中的工厂模式。</p><p>classmethod既可以作为factory method提供额外的构造实例的手段，也可以作为工厂类的接口，用来读取或者修改工厂类本身。</p><p>classmethod还可以通过额外的<code>类引用</code>，提供继承时的多态特性，实现子类挂载点等。</p><h3 id="以下为实例佐证上侧结论">以下为实例，佐证上侧结论</h3><p>Python类方法的优势，先看代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBCursor</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create cursor to database</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **arguments)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self, sql)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">configure</span><span class="params">(cls, config)</span>:</span></span><br><span class="line">        cls.config = config</span><br></pre></td></tr></table></figure><p>一般数据库插件都支持很多的配置，我们希望这个配置可以以<code>集中式的方式保存在应用配置</code>中，这样我们为DBCursor类增加了一个configure接口，它会在任何DB Cursor被实例化之前，首先在类上被调用，这样在<code>初始化__init__</code>的时候，就<strong>可以使用</strong>这个配置了。</p><p>在Java等语言中，这类功能通常通过工厂类（Factory）实现，先初始化一个工厂类的实例，然后由这个工厂类的实例构造实际需要的实例。<strong>在Python中，普通类完全可以替代Factory，而对于支持配置的Factory，就对应到相应的classmethod。</strong></p><p>参考链接 <a href="https://blog.51cto.com/watchmen/1954632" target="_blank" rel="noopener"></a> <a href="https://www.cnblogs.com/geekmao/p/7576441.html" target="_blank" rel="noopener"></a> <a href="https://blog.csdn.net/ilovehua521/article/details/82387214" target="_blank" rel="noopener">类思维导图</a> <a href="https://blog.csdn.net/yanbober/article/details/8713250" target="_blank" rel="noopener">堆栈</a></p><p><a href="https://www.cnblogs.com/geaozhang/p/7111961.html" target="_blank" rel="noopener">内存管理</a> <a href="https://blog.csdn.net/onlyanyz/article/details/45605773" target="_blank" rel="noopener">内存</a> <a href="http://stor.51cto.com/art/201901/591039.htm" target="_blank" rel="noopener">深入内存</a> <a href="https://blog.csdn.net/secretx/article/details/81100920" target="_blank" rel="noopener">python内存管理--分层分配】</a> <a href="https://zhuanlan.zhihu.com/p/40809619" target="_blank" rel="noopener">内存</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之装饰器【12】</title>
      <link href="/2019/05/19_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2019/05/19_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/05/19_Python基础系列之装饰器/cheap.png"></p><h2 id="目标">目标</h2><ul><li>温故函数很多概念</li><li>掌握 Python 装饰器</li></ul><blockquote><p>如果能准确的表述下侧代码的结果</p><p>就不用往下看啦，想必你已经掌握了 Python 装饰器</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"1"</span>)</span><br><span class="line">        print(<span class="string">"foo---%s"</span> % func)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"2"</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"3"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"4"</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"===foo===="</span>)</span><br><span class="line">print(foo)</span><br><span class="line">print(<span class="string">"===foo()===="</span>)</span><br><span class="line">print(foo())</span><br><span class="line">print(<span class="string">"===outer(foo)===="</span>)</span><br><span class="line">print(outer(foo))</span><br><span class="line">print(<span class="string">"===outer(foo())===="</span>)</span><br><span class="line">print(outer(foo()))</span><br><span class="line">print(<span class="string">"===outer(foo())()===="</span>)</span><br><span class="line">print(outer(foo())())</span><br></pre></td></tr></table></figure><p>先认真回忆下之前函数的相关章节内容 <strong>不难但可能有点绕</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">===foo====</span><br><span class="line">&lt;<span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="title">at</span> 0<span class="title">x7fcae64dbea0</span>&gt;</span></span><br><span class="line"><span class="function">===<span class="title">foo</span>(<span class="params"></span>)====</span></span><br><span class="line"><span class="function">3</span></span><br><span class="line"><span class="function">4</span></span><br><span class="line"><span class="function">===<span class="title">outer</span>(<span class="params">foo</span>)====</span></span><br><span class="line"><span class="function">&lt;<span class="title">function</span> <span class="title">outer</span>.&lt;<span class="title">locals</span>&gt;.<span class="title">inner</span> <span class="title">at</span> 0<span class="title">x7fcae64dbe18</span>&gt;</span></span><br><span class="line"><span class="function">===<span class="title">outer</span>(<span class="params">foo(</span>))====</span></span><br><span class="line"><span class="function">3</span></span><br><span class="line"><span class="function">&lt;<span class="title">function</span> <span class="title">outer</span>.&lt;<span class="title">locals</span>&gt;.<span class="title">inner</span> <span class="title">at</span> 0<span class="title">x7fcae645d598</span>&gt;</span></span><br><span class="line"><span class="function">===<span class="title">outer</span>(<span class="params">foo(</span>))(<span class="params"></span>)====</span></span><br><span class="line"><span class="function">3</span></span><br><span class="line"><span class="function">1</span></span><br><span class="line"><span class="function"><span class="title">foo</span>---4</span></span><br><span class="line"><span class="function">2</span></span><br></pre></td></tr></table></figure><p>没答出来，或对装饰器有疑惑，那就即可开始吧</p><h3 id="第一部分-前奏">第一部分 前奏</h3><p>针对于开头的那块代码逐步分析下，究竟再内存中是<code>如何运行的❓</code> <code>执行顺序是什么❓</code></p><p><strong>强烈推荐网址：<a href="http://pythontutor.com/live.html#mode=edit" target="_blank" rel="noopener">代码可视化执行过程</a></strong></p><p>这几行代码主要为了加深理解代码的<code>执行过程</code>、<code>函数名</code>、<code>函数调用</code>等等</p><p><code>结合代码与下侧图示</code>，重温那些我们习以为常的东西。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"1"</span>)</span><br><span class="line">        print(<span class="string">"foo---%s"</span> % func)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"2"</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"3"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"4"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将函数 outer、foo 加载到内存中</span></span><br><span class="line"><span class="comment"># 以上代码到此行，未执行</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"===foo===="</span>)</span><br><span class="line"><span class="comment"># foo【函数名】；</span></span><br><span class="line"><span class="comment"># 执行：对应的【函数信息】；返回：🈚️</span></span><br><span class="line">print(foo)</span><br><span class="line">print(<span class="string">"===foo()===="</span>)</span><br><span class="line"><span class="comment"># 真正执行 foo函数</span></span><br><span class="line"><span class="comment"># 执行：打印 3； 返回 4</span></span><br><span class="line">print(foo())</span><br><span class="line">print(<span class="string">"===outer(foo)===="</span>)</span><br><span class="line"><span class="comment"># 将【foo函数名】传给【outer函数】，参数为 【函数名】</span></span><br><span class="line"><span class="comment"># 执行：将inner加载到内存，返回：🈚️</span></span><br><span class="line">print(outer(foo))</span><br><span class="line">print(<span class="string">"===outer(foo())===="</span>)</span><br><span class="line"><span class="comment"># 调用【foo函数】，将4作为参数传给传给【outer函数】</span></span><br><span class="line"><span class="comment"># 执行：打印3 返回4， 打印outer函数的返回值 inner内存信息</span></span><br><span class="line">print(outer(foo()))</span><br><span class="line">print(<span class="string">"===outer(foo())()===="</span>)</span><br><span class="line"><span class="comment"># 调用【foo函数】，将4作为参数传给传给【outer函数】，调用inner函数</span></span><br><span class="line"><span class="comment"># 执行：打印3 返回4，进而打印 1 、 4【func()]、2以及inner的返回值2</span></span><br><span class="line"><span class="comment"># over！！！</span></span><br><span class="line">print(outer(foo())())</span><br></pre></td></tr></table></figure><p>我觉得，先把这些看似简单的东西理清楚，对接下来，装饰器的理解更容易些</p><h3 id="第二部分-装饰器基础">第二部分 装饰器【基础】</h3><h4 id="装饰器是什么">1 装饰器是什么</h4><p>装饰器（Decorator）：可以在不修改原有代码的情况下，为被装饰的对象增加新的功能或者附加限制条件或者帮助输出。<strong>原则：开放封闭</strong></p><p><strong>分类</strong></p><ol type="1"><li>函数装饰器；</li><li>类的装饰器。</li></ol><p>最近公司也在用装饰器，不过是再 Nodejs 中用的； 举个别的例子。因为某种原因，需要对每个接口进行<strong>认证</strong>、<strong>记录日志</strong>，如何快速高效的实现这样的需求 ❓</p><p><code>可能有几种思路</code></p><ul><li>在基类中写相应的方法，如果有的话；</li><li>写两个函数【认证的、日志的】，在每个接口中添加；</li><li>等等思路</li></ul><h4 id="简单的装饰器">2 简单的装饰器</h4><p>但今天只能选<strong>装饰器</strong>，因为不能偏离主题啦，描述了需求就开始干吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"装饰器启动,自动执行"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"统一认证"</span>)</span><br><span class="line">        result = func()</span><br><span class="line">        print(<span class="string">"记录日志信息"</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"接口1"</span>)</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">装饰器启动,自动执行</span><br><span class="line">统一认证</span><br><span class="line">接口<span class="number">1</span></span><br><span class="line">记录日志信息</span><br></pre></td></tr></table></figure><p>大致和第一部分的例子有点类似，不同的是</p><ol type="1"><li>inner 函数返回了个函数</li><li>多个<code>@outer</code></li></ol><p><span class="citation" data-cites="outer">@outer</span> 中的<code>@</code>是注解语法糖；<strong>把 f1 作为参数传给 outer</strong>,今儿满足我们的<code>开放封闭的原则</code>;</p><p>其解释器会解释成下面这样的语句： <strong>*<span class="citation" data-cites="outer">@outer</span> &lt;=&gt; outer(f1)</strong></p><p>翻译成函数调用, 我们用新的例子来对比一下，其实就是下侧这样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"接口2"</span>)</span><br><span class="line">outer(f2)()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">装饰器启动,自动执行</span></span><br><span class="line"><span class="string">统一认证</span></span><br><span class="line"><span class="string">接口1</span></span><br><span class="line"><span class="string">记录日志信息</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>了解了上述的调用含义， <strong><span class="citation" data-cites="outer">@outer</span> &lt;=&gt; outer(f1)</strong></p><blockquote><p>注： 传的只是函数名</p></blockquote><figure><img src="/2019/05/19_Python基础系列之装饰器/doc1.jpg" alt><figcaption>自动执行</figcaption></figure><p>整体的流程</p><ol type="1"><li>自上而下执行，将函数<code>outer</code>在内存注册；</li><li>执行到@outer 时，将<code>函数名f1</code>作为参数传给<code>@outer</code>;</li><li>调用 outer 函数，执行打印【装饰器启动,自动执行】；</li><li>函数 inner 在内存注册，内存地址：<strong>[xxxx]</strong>，返回【inner 函数名】，</li><li>将函数<code>f1</code>在内存注册；其实是直接指向 <strong>[xxxx]</strong></li><li>调用 f1(), 直接调用第五步的 <strong>[xxxx]</strong>， 也就是第四步的；</li><li>打印【统一认证】；</li><li>result = func()<strong>执行回调</strong>【f1】函数, 打印：接口 1，没有返回值，result = None</li><li>回到<code>inner()</code>,打印<code>记录日志信息</code>;</li><li>返回 None，OVER!</li></ol><p><code>注</code>：完整的有 17 步，动图还不会制作，可以前往--&gt;<a href="http://pythontutor.com/live.html#mode=edit" target="_blank" rel="noopener">代码可视化网址</a>**，查看完整的步骤。</p><blockquote><p>实在是想不出来，如何用图来表示装饰器，有相应的图示，请介绍。</p></blockquote><p>比较喜欢这段代码, 挺有意思的。O(∩_∩)O 哈哈~ <a href="https://coolshell.cn/articles/11265.html" target="_blank" rel="noopener">来源</a></p><p>会自动打印结果，因为采用了装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuck</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"fuck %s!"</span> % fn.__name__[::<span class="number">-1</span>].upper()</span><br><span class="line"></span><br><span class="line"><span class="meta">@fuck</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wfg</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="第三部分-装饰器进阶">第三部分 装饰器【进阶】</h3><p>如果没有看明白第二部分，还是这回去，沉下心，专注的、认真的读下去，真的不难，好好分析下流程，一步一个脚印，踩实了！</p><blockquote><p>只介绍最基础的代码，就是耍流氓</p></blockquote><h4 id="多个装饰器">1 多个装饰器</h4><p><a href="https://blog.csdn.net/u013411246/article/details/80571462" target="_blank" rel="noopener">下侧代码来源</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当有多个装饰器装饰一个函数时，他们的执行顺序</span></span><br><span class="line"><span class="comment">#观察下方的代码就会发现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_a</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'Get in decorator_a'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_a</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Get in inner_a'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner_a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_b</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'Get in decorator_b'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_b</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Get in inner_b'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner_b</span><br><span class="line">  </span><br><span class="line"><span class="meta">@decorator_b</span></span><br><span class="line"><span class="meta">@decorator_a</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">'Get in f'</span>)</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Get in decorator_a</span></span><br><span class="line"><span class="string">Get in decorator_b</span></span><br><span class="line"><span class="string">Get in inner_b</span></span><br><span class="line"><span class="string">Get in inner_a</span></span><br><span class="line"><span class="string">Get in f</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>调用时，函数的顺序 1. 顺序等同于==&gt; <strong>decorator_b(decorator_a(f))</strong>,返回的是inner_b,所以执行的时候是先执行inner_b 2. 然后在执行【decorator_a(f)】返回的inner_a .最终在调用f(1)的时候，函数inner_b输出'Get in inner_b' 3. 执行inner_a输出Get in decorator_a，最后执行func(),即f</p><h4 id="多参多装饰器">2 多参多装饰器</h4><p>为了更加深入的了解，装饰器，摘录<a href="https://coolshell.cn/articles/11265.html" target="_blank" rel="noopener">酷 壳 博客</a>上的一段代码，好像<a href="https://wiki.python.org/moin/PythonDecoratorLibrary" target="_blank" rel="noopener">官网实例代码</a>也不少;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeHtmlTag</span><span class="params">(tag, *args, **kwds)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">real_decorator</span><span class="params">(fn)</span>:</span></span><br><span class="line">        css_class = <span class="string">" class='&#123;0&#125;'"</span>.format(kwds[<span class="string">"css_class"</span>]) \</span><br><span class="line">                                     <span class="keyword">if</span> <span class="string">"css_class"</span> <span class="keyword">in</span> kwds <span class="keyword">else</span> <span class="string">""</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwds)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;"</span>+tag+css_class+<span class="string">"&gt;"</span> + fn(*args, **kwds) + <span class="string">"&lt;/"</span>+tag+<span class="string">"&gt;"</span></span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line">    <span class="keyword">return</span> real_decorator</span><br><span class="line"> </span><br><span class="line"><span class="meta">@makeHtmlTag(tag="b", css_class="bold_css")</span></span><br><span class="line"><span class="meta">@makeHtmlTag(tag="i", css_class="italic_css")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span></span><br><span class="line"> </span><br><span class="line">print(hello())</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;b class='bold_css'&gt;&lt;i class='italic_css'&gt;hello world&lt;/i&gt;&lt;/b&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h4 id="再深入一些">3 再深入一些</h4><p>表示还没有研究这段代码，先分享出来 摘录<a href="https://coolshell.cn/articles/11265.html" target="_blank" rel="noopener">酷 壳 博客</a>上的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memo</span><span class="params">(fn)</span>:</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    miss = object()</span><br><span class="line"> </span><br><span class="line"><span class="meta">    @wraps(fn)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args)</span>:</span></span><br><span class="line">        result = cache.get(args, miss)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> miss:</span><br><span class="line">            result = fn(*args)</span><br><span class="line">            cache[args] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"> </span><br><span class="line"><span class="meta">@memo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>Python函数告一段落了</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 装饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之--匿名函数闭包【11】</title>
      <link href="/2019/05/18_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85/"/>
      <url>/2019/05/18_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>存在即合理 正如明白了<code>x += 1</code>，就会尽量避免<code>x = x + 1</code>;</p></blockquote><h4 id="反观一搜一大把关于闭包的文章无外乎只是告诉三点">反观一搜一大把关于闭包的文章，无外乎只是告诉三点</h4><ul><li>晦涩难懂的概念</li><li>给几个简单的实例</li><li>结束 或许还会给个建议 <strong>少用</strong></li></ul><blockquote><p>真的是这样么？ 我搜索了大量的资料来写这篇文章，只是想尽力把自己说服、说明了。</p></blockquote><p>下边有三到题目以及答案</p><ul><li>如果你的预期和答案不符</li><li>如果你看不懂</li><li>如果你好奇的想一探究竟</li></ul><blockquote><p>请继续 &gt; 否则就可以关闭这个文章了</p><blockquote><p>文章长且内容多</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一题，是用来做什么的？</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(start, stop)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> filter(<span class="keyword">lambda</span> x : <span class="keyword">not</span> [x % i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, x) <span class="keyword">if</span> x % i == <span class="number">0</span>], range(start, stop + <span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二题</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_counter</span><span class="params">()</span>:</span></span><br><span class="line">  i = <span class="number">10</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(x=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">nonlocal</span> i</span><br><span class="line">    i += x</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  <span class="keyword">return</span> count</span><br><span class="line">a_count = new_counter()</span><br><span class="line">print(a_count())</span><br><span class="line">print(a_count())</span><br><span class="line">print(a_count(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第三题</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeActions</span><span class="params">()</span>:</span></span><br><span class="line">    acts = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        acts.append(<span class="keyword">lambda</span> x: i ** x)</span><br><span class="line">    <span class="keyword">return</span> acts</span><br><span class="line">acts = makeActions()</span><br><span class="line">print(acts[<span class="number">0</span>](<span class="number">2</span>))</span><br><span class="line">print(acts[<span class="number">1</span>](<span class="number">2</span>))</span><br><span class="line">print(acts[<span class="number">2</span>](<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p><strong>答案</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二题</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="comment"># 第三题</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><blockquote><p>警示：认真的读下去，可能会花费你不少的时间</p></blockquote><h2 id="目标">目标</h2><ul><li>掌握匿名函数</li><li>掌握高阶函数与匿名函数的用法</li><li>尽量搞明白闭包</li></ul><figure><img src="/2019/05/18_Python基础系列之匿名函数闭包/closuer.png" alt><figcaption>目录结构</figcaption></figure><h3 id="第一部分-匿名函数">第一部分 匿名函数</h3><h4 id="定义">1 定义</h4><p><code>lambda 函数</code>也叫<code>匿名函数</code>，及即没有具体名称的函数，它允许快速定义单行函数，类似于 C 语言的宏，可以用在任何需要函数的地方。</p><p>lambda与def对比</p><table><thead><tr class="header"><th>区别</th><th>def</th><th>lambda</th></tr></thead><tbody><tr class="odd"><td>名称</td><td>有</td><td>无</td></tr><tr class="even"><td>返回值</td><td>函数对象但不给标识符</td><td>任意</td></tr><tr class="odd"><td>作用</td><td>简单的</td><td>简单/复杂</td></tr><tr class="even"><td>作用范围</td><td>不能共享</td><td>可共享</td></tr></tbody></table><h4 id="表达式">2 表达式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funName</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 表达式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"返回值"</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匿名函数</span></span><br><span class="line"><span class="keyword">lambda</span> argument1,argument2,...argumentN:expression using arguments</span><br><span class="line"></span><br><span class="line"><span class="keyword">lambda</span> 参数: 表达式</span><br></pre></td></tr></table></figure><p><code>实现同样代码不同方式的实例：</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x*y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mul(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="comment"># 匿名函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lam = <span class="keyword">lambda</span> x, y: x*y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lam</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x101b11268</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lam(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lam(<span class="number">2</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: &lt;<span class="keyword">lambda</span>&gt;() missing <span class="number">1</span> required positional argument: <span class="string">'y'</span></span><br></pre></td></tr></table></figure><h4 id="匿名函数与高阶函数">3 匿名函数与高阶函数</h4><p>Python内置对数据处理的函数，<strong>效率比for要高</strong>，恰好，我们可以结合lambda函数，<code>一块把二者学习了</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 罗列了常用的三种</span></span><br><span class="line">1. map(function, iterable[, iterable, ...]) -&gt; list</span><br><span class="line"></span><br><span class="line">2. filter(function or None, iterable) -&gt; list, tuple, or string</span><br><span class="line"></span><br><span class="line">3. reduce(function, sequence[, initial]) -&gt; value</span><br></pre></td></tr></table></figure><h4 id="简要介绍">简要介绍：</h4><ul><li><strong>map映射</strong>: 对iterable中的item依次执行function(item)，执行结果输出为list</li><li><strong>filter过滤</strong>: 对iterable中的item依次执行function(item)，将执行结果为True（！=0）的item组成一个List/String/Tuple（取决于iterable的类型）返回，False则退出（0），进行过滤。</li><li><strong>reduce</strong>: iterable中的item顺序迭代调用function，函数必须要有2个参数。要是有第3个参数，则<strong>表示初始值</strong>，可以继续调用初始值，返回一个值</li></ul><h4 id="图解">图解：</h4><p><img src="/2019/05/18_Python基础系列之匿名函数闭包/map.png" alt="map"> <img src="/2019/05/18_Python基础系列之匿名函数闭包/filter.png" alt="filter"> <img src="/2019/05/18_Python基础系列之匿名函数闭包/s5_reduce_function.svg" alt="reduce"></p><h4 id="实例列表">实例列表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ------- map ------- #</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(str, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(int, [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])   <span class="comment"># 使用 lambda</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------- reduce ------- #</span></span><br><span class="line"><span class="comment"># reduce 操作实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x * y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])  <span class="comment"># 相当于 ((1 * 2) * 3) * 4</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x * y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>) <span class="comment"># ((((5 * 1) * 2) * 3)) * 4</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> a, b: a <span class="keyword">if</span> (a &gt; b) <span class="keyword">else</span> b   <span class="comment"># 两两比较，取最大值 【三目运算也在阶段汇总与补充中说明】</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(f, [<span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>])</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------- filter ------- #</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(*list)</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h4 id="两个综合实例">两个综合实例</h4><p><strong>这个就是开头的那个实例： 找出指定返回内的质子</strong>，涉及的内容有点多，包含之前章节中的<code>推导式</code>、<code>range函数</code>、<code>函数</code>、<code>not</code>等相关内容，试着先看下，是否能看明白。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 质数的定义 只有1和它本身两个因数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(start, stop)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># 取出质数,x从range(start,stop+1) 取的数</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> filter(<span class="keyword">lambda</span> x : <span class="keyword">not</span> [x % i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, x) <span class="keyword">if</span> x % i == <span class="number">0</span>], range(start, stop + <span class="number">1</span>))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isPrime(<span class="number">11</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(result)</span><br><span class="line">&lt;filter object at <span class="number">0x101b12400</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(result))</span><br><span class="line">[<span class="number">11</span>]</span><br></pre></td></tr></table></figure><p><a href="http://pythontutor.com/live.html#code=def%20isPrime%28start,%20stop%29%3A%0A%20%20%20%20%20%23%20%E5%8F%96%E5%87%BA%E8%B4%A8%E6%95%B0,x%E4%BB%8Erange%28start,stop%2B1%29%20%E5%8F%96%E7%9A%84%E6%95%B0%0A%20%20%20%20%20return%20filter%28lambda%20x%20%3A%20not%20%5Bx%20%25%20i%20for%20i%20in%20range%282,%20x%29%20if%20x%20%25%20i%20%3D%3D%200%5D,%20range%28start,%20stop%20%2B%201%29%29%0Aprint%28list%28isPrime%2811,%2012%29%29%29&amp;cumulative=true&amp;curInstr=36&amp;heapPrimitives=true&amp;mode=display&amp;origin=opt-live.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false" target="_blank" rel="noopener">整个过程的步骤有三七步骤</a></p><p>试了下画个流程图，来作为补充，但是我怕画出来，更难理解了； 所以就用文字描述下，希望描述的清楚： - 1 range(start, stop + 1) 生成 <code>[)左闭右开</code>的<strong>list_1数组</strong> - 2 依次将list_1中的数【x】传给<code>匿名函数</code>；<strong>【循环该操作】</strong> - 3 生成[2, x)的<strong>list_2</strong> - 4 遍历list_2， 依次用 *<code>x%list_2[i]</code>取余；<strong>【循环该操作】</strong> - 5 如果数组长度等于0，回到<code>2</code> - 6 如果余数等于0，返回余数，存进<code>list_new</code>; - 7 等整个<strong>2</strong>走完，判断<code>list_new</code>是否存在数据，得出当前x是否是质数，是否从list_1中过滤掉 - 8 进入<strong>list_1</strong>下一个元素的判断</p><p>先熟悉下not的用法，【在阶段汇总与补充中说明】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> []</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> [<span class="number">1</span>]</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> [<span class="number">0</span>]</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>下边这个求阶乘的，没啥难度，只要还记得</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思考下这个，在思考下上边关于reduce的图例</span></span><br><span class="line">reduce(<span class="keyword">lambda</span> x, y: x * y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>) <span class="comment"># ((((5 * 1) * 2) * 3)) * 4</span></span><br></pre></td></tr></table></figure><figure><img src="/2019/05/18_Python基础系列之匿名函数闭包/reduce2.png" alt><figcaption>类比一下</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算 5!+4!+3!+2!+1!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">addFactorial</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    result = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> map(<span class="keyword">lambda</span> x:x + <span class="number">1</span>, range(n)):</span><br><span class="line"><span class="meta">... </span>        a = reduce(<span class="keyword">lambda</span> x, y:x * y, map(<span class="keyword">lambda</span> x:x + <span class="number">1</span>, range(i)))</span><br><span class="line"><span class="meta">... </span>        result.append(a)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y:x + y, result)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addFactorial(<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addFactorial(<span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="第二部分-闭包">第二部分 闭包</h3><p>接下来的内容涉及函数相关内容，之前的两篇文章 <a href="https://mp.weixin.qq.com/s/g8P8IT3_eK5KYlyWIXKgbQ" target="_blank" rel="noopener">Python 基础系列--函数【9】</a> <a href="https://mp.weixin.qq.com/s/93jGABTI5DEDxCT4iUT3pw" target="_blank" rel="noopener">Python 基础系列之作用域【10】</a></p><figure><img src="/2019/05/18_Python基础系列之匿名函数闭包/func.png" alt><figcaption>函数概述图</figcaption></figure><blockquote><p>函数是对象，函数可以作为返回值，</p></blockquote><p>在说闭包定义之前，我们先看下开头的那两段代码</p><h4 id="初始闭包">1. 初始闭包</h4><blockquote><p>函数是对象，函数可以作为返回值。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二题</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_counter</span><span class="params">()</span>:</span></span><br><span class="line">  i = <span class="number">10</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(x=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">nonlocal</span> i</span><br><span class="line">    i += x</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  <span class="keyword">return</span> count</span><br><span class="line">a_count = new_counter()</span><br><span class="line">print(a_count())</span><br><span class="line">print(a_count())</span><br><span class="line">print(a_count(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><figure><img src="/2019/05/18_Python基础系列之匿名函数闭包/bibao.jpg" alt><figcaption>闭包</figcaption></figure><p>上侧的例子主要实现的是一个<strong>计数器的功能</strong>：<code>每点击一次，在原基础上加1</code>;</p><p>结合上图，大致了解下流程： - 函数定于与返回： - 外层函数new_counter返回了内层函数count作为结果； - 内层函数count，中的参数：<strong>x</strong>有个默认值1； - 内层函数count中的 i 利用了nonlocal，获取到10； - a_count = new_counter() - 将变量a_count指向new_counter()返回的count() - count()的type为func,并且i持有10对应的内存地址 - 第一次调用a_count()时 - 没有参数，x默认为1; - i持有10，经过➕后返回11 - 第二次调用a_count()时 - 没有参数，x默认为1; - i持有11，经过➕后返回12 - 第二次调用a_count()时 - 没有参数，x=3; - i持有12，经过➕后返回15</p><p>此时我不确定看了上图和说明，是否<strong>能够看懂闭包的用法</strong></p><h4 id="闭包的定义">2 闭包的定义</h4><blockquote><p>比较晦涩的专业术语，但还是建议认真读读 &gt; 都是大神发明的东西</p><blockquote><p>真的很巧妙</p></blockquote></blockquote><p><strong>下边的文字值得读 N 遍</strong></p><p><code>维基百科上对闭包的解释就很经典：</code></p><p>在计算机科学中，<strong>闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</strong> 所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。 Peter J. Landin 在1964年将术语闭包定义为一种包含环境成分和控制成分的实体。</p><ul><li>闭包概念:<ul><li>闭包就是有权访问另一个函数作用域中变量的函数.</li></ul></li><li>分析这句话:<ol type="1"><li>闭包是定义在函数中的函数.</li><li>闭包能访问包含函数的变量.</li><li>闭包携带状态包<ul><li>即使包含函数执行完了, 被闭包引用的变量也得不到释放.</li></ul></li></ol></li></ul><p>接下来看第二个例子 #### 3. 闭包的作用域</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第三题</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeActions</span><span class="params">()</span>:</span></span><br><span class="line">    acts = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        acts.append(<span class="keyword">lambda</span> x: i ** x)</span><br><span class="line">    <span class="keyword">return</span> acts</span><br><span class="line">acts = makeActions()</span><br><span class="line">print(acts[<span class="number">0</span>](<span class="number">2</span>))</span><br><span class="line">print(acts[<span class="number">1</span>](<span class="number">2</span>))</span><br><span class="line">print(acts[<span class="number">2</span>](<span class="number">3</span>))</span><br></pre></td></tr></table></figure><figure><img src="/2019/05/18_Python基础系列之匿名函数闭包/bibao2.jpg" alt><figcaption>闭包2</figcaption></figure><p>当执行结束<code>acts = makeActions()</code>这一行代码。 1. makeActions()函数内部【i】持有了 2,并且不释放； 2. acts实际包含了三个函数类型的内容 3. 当调用<code>acts[x](2)</code>, 实际执行函数为<strong>lambda x: i </strong> x**，而<code>i持有2</code> 4. 故当 y 一致时，x 的位置变化不影响结果，（acts[x] (y)）</p><h4 id="加深一点">4 加深一点</h4><p>如果我们就是要<code>错误的结果</code>，【0，1，8】呢？ 如何去实现？</p><p>还记得在前面🈶个状态的概念吗？ - 携带状态的闭包的概念 - 即使包含函数执行完了, 被闭包引用的变量也得不到释放.</p><blockquote><p>思路：假如我们把列表中的位置对应i的状态保存起来，那就不就完事了么？</p></blockquote><blockquote><p>如果真的从头看到现在，并且一路思考，想必已经花费你不少时间了。 &gt; 此时的你应该完全理解文中阐述的内容了。</p><blockquote><p>相对真正掌握知识而言，付出的时间的价值是翻倍的</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeActions</span><span class="params">()</span>:</span></span><br><span class="line">    acts = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(param)</span>:</span></span><br><span class="line">            newParam = <span class="keyword">lambda</span> x: param ** x</span><br><span class="line">            <span class="keyword">return</span> newParam</span><br><span class="line">        acts.append(g(i))</span><br><span class="line">    <span class="keyword">return</span> acts</span><br><span class="line">acts = makeActions()</span><br><span class="line">print(acts[<span class="number">0</span>](<span class="number">2</span>))</span><br><span class="line">print(acts[<span class="number">1</span>](<span class="number">2</span>))</span><br><span class="line">print(acts[<span class="number">2</span>](<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p><img src="/2019/05/18_Python基础系列之匿名函数闭包/bibao3.jpg" alt="第一次保留的状态"> <img src="/2019/05/18_Python基础系列之匿名函数闭包/bibao4.jpg" alt="三种状态"></p><h4 id="再深入一些">5 再深入一些</h4><p>这段代码能让你想到什么❓ 最直观的就是：这个是个闭包</p><p>但是：这段代码万万不能让我联想到：<strong>直线方程</strong>、<strong>斜率</strong>、<strong>截距</strong>、<strong>坐标系</strong>等等的概念。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">line_conf</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">line</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a*x + b</span><br><span class="line">    <span class="keyword">return</span> line</span><br><span class="line"></span><br><span class="line">line1 = line_conf(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">line2 = line_conf(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(line1(<span class="number">5</span>), line2(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种写法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">line_conf</span><span class="params">(a, b, x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a*x + b</span><br><span class="line">line_conf(<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">line_conf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>当我们明白了：<code>函数是对象</code>、<code>函数可以作为返回值</code>、<code>闭包携带状态</code>等等的概念后，可能会思考</p><ol type="1"><li>为何会有这种东西存在❓</li><li>究竟其用途是什么❓</li></ol><p>关于这个疑问，在所搜大量数据的时候，发现了<a href="https://www.zhihu.com/question/34872127/answer/60297928" target="_blank" rel="noopener">知乎上有个有意思的问答</a></p><blockquote><p><a href="https://www.zhihu.com/question/34872127/answer/60297928" target="_blank" rel="noopener">以下摘录其中的一部分</a></p></blockquote><ol type="1"><li><p><strong>简短答案</strong>：前者更具有可读性和可移植性。</p></li><li><p><strong>较完整答案</strong>：闭包（closure）和类（class）有相通之处，带有面向对象的<code>封装思维</code>。而面向对象编程正是为了更佳的可读性和更关键的可移植性；不过这个例子没太体现出面向对象的额外优势。</p></li><li><p><strong>升级答案</strong>：题主问出这个问题，很可能是现在<code>流行的编程教材知其然不知其所然的风格带来的恶果</code>。如果未来带着这个想法进入IT行业，会非常不适应公司的代码规范等基础要求；即便不入行只是自己写写程序用，也会和很多优秀、可复用等的理念失之交臂。</p></li><li><p>我认为一本优秀的教材除了讲基础语法，应该尽量教你代码<code>为什么这么写好</code>、<code>那么写不好</code>、那么那么写现在能用但<code>多半以后会出事</code>。</p></li></ol><blockquote><p><a href="https://www.zhihu.com/question/34872127/answer/60297928" target="_blank" rel="noopener">以上为摘录其中的一部分</a></p></blockquote><h3 id="我们所讨厌的行为却是自己的所作所为"><strong>我们所讨厌的行为，却是自己的所作所为。</strong></h3><h3 id="多问问什么也许有一天那些望而生畏会变成理所当然"><strong>多问问什么，也许有一天，那些望而生畏会变成理所当然。</strong></h3><p>参考链接 <a href="http://www.bubuko.com/infodetail-2316064.html" target="_blank" rel="noopener">Python 函数之lambda、map、filter和reduce</a> <a href="https://my.oschina.net/cloudcoder/blog/226461" target="_blank" rel="noopener">内置函数的使用</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 函数 </tag>
            
            <tag> 匿名函数 </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之作用域【10】</title>
      <link href="/2019/05/16_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>/2019/05/16_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="目标">目标</h2><ol type="1"><li>尽量掌握 Python 命名空间、作用域</li><li>掌握 Python 匿名函数</li></ol><blockquote><p>本文本属于那种 &gt; 只可意会不可言传的范畴</p></blockquote><p>原因:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 大部分人都直接开撸，因为和想象差不多；</span><br><span class="line">2. 不容易说明白, 除非遇到bug了，断点调试。</span><br></pre></td></tr></table></figure><h3 id="第一部分-命名空间">第一部分 命名空间</h3><blockquote><p>听起来高大上的词汇，或许是简单的.</p></blockquote><p><strong>在理解这个词汇钱，先看一个示例</strong></p><p>A 公司有个员工 A1，工号 001； B 公司有个员工 B1，工号 001；</p><p>为何工资不会发错？</p><p><strong>这不废话么？</strong></p><p>原因在于：虽有同样的工号，但是相对而言的，在不同的公司（<code>空间</code>）内。</p><h4 id="定义">1.定义</h4><p><strong>命名空间（英语：Namespace）</strong>，也称名字空间、名称空间等，它表示着一个<code>标识符（identifier）的可见范围</code>。 一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是<code>互不相干的</code>。这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中。</p><p><strong>空间</strong>相当于一个<code>集合</code>，<code>包含</code>相对相对范围内所有的内容(<strong>对象名</strong>)</p><h4 id="分类">2. 分类</h4><ol type="1"><li>内置命名空间(Built-in Namespaces)：伴随 Python 的运行而存在，<code>内置函数的命名空间</code>都属于<code>内置命名空间</code>，比如前面的 id()，直接可以用。</li><li>全局命名空间(Module:Global Namespaces)：每个模块拥有自己的命名集合；</li><li>本地命名空间(Function&amp;Class: Local Namespaces)：局部命名空间，每个函数、类所拥有的命名空间，记录了函数、类中定义的所有变量。</li></ol><blockquote><p>一图胜前言</p></blockquote><figure><img src="/2019/05/16_Python基础系列之匿名函数命名空间/1.jpg" alt><figcaption>命名空间</figcaption></figure><h4 id="生命周期">3. 生命周期</h4><ol type="1"><li>内置命名空间在 Python<code>解释器启动时创建</code>，解释器<code>退出时销毁</code>；</li><li>全局命名空间在模块被解释器<code>读入时创建</code>，<code>解释器退出时销毁</code>；</li><li>局部命名空间，包含函数、类定义。<ul><li>函数的局部命名空间：在函数调用时创建，函数返回结果或抛出异常时被销毁（每一个递归函数都拥有自己的命名空间）；</li><li>类定义的命名空间：在解释器读到类定义（class 关键字）时创建，类定义结束后销毁。（*）</li></ul></li></ol><h4 id="存在的意义">4. 存在的意义</h4><p>为了解决命名冲突。</p><p>你去寄快递，说邮寄到<strong>南京路 118 号</strong>，他肯定会让你写上是哪个省的，否则不就乱了么。</p><h3 id="第二部分-作用域">第二部分 作用域</h3><h4 id="作用域是什么">1. 作用域是什么？</h4><blockquote><p>可能有点绕，多读几遍，多思考下</p><p>可能有点绕，多读几遍，多思考下</p></blockquote><p>命名空间是<code>对象名称</code>的<strong>集合</strong>,可被访问区域，比如 id(),可以全局<strong>被调用</strong> 作用域是针对命名空间而言的，是<strong>作用域定义了命名空间的可用范围</strong></p><p>以下注意事项会在第三部分的代码中证实： 1. 只有函数、类、模块会产生新的作用域，代码块（例如if、for代码块）不会产生新的作用域。 2. python中变量的作用域是由它在源代码中的位置决定的（*）</p><p>先看下分类，然后进一步阐述<strong>命名空间与作用域的关系</strong></p><h4 id="分类-1">2. 分类</h4><ol type="1"><li>Local（局部作用域）：首先搜索，包含局部名字的最内层（innermost）作用域，如函数/方法/类的内部局部作用域；</li><li>Enclosing（ 闭包函数外的函数中）：根据嵌套层次从内到外搜索，包含非局部（nonlocal）非全局（nonglobal）名字的任意封闭函数的作用域。如两个嵌套的函数，内层函数的作用域是局部作用域，外层函数作用域就是内层函数的 Enclosing 作用域；</li><li>Global（全局作用域 ）：倒数第二次被搜索，包含当前模块全局名字的作用域；</li><li>Built-in（内建作用域）：最后被搜索，包含内建名字的最外层作用域。</li></ol><p><strong>查找规则</strong></p><figure><img src="/2019/05/16_Python基础系列之匿名函数命名空间/2.jpg" alt><figcaption>如图所示</figcaption></figure><blockquote><p>内层可以访问外层，但外层不能访问内层</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">global_var = <span class="number">2</span>  <span class="comment"># 全局作用域</span></span><br><span class="line">x = id(global_var)  <span class="comment"># 内建作用域，调用id()函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    out_var = <span class="number">1</span>  <span class="comment"># 闭包函数外的函数中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        inner_var = <span class="number">2</span>  <span class="comment"># 局部作用域</span></span><br></pre></td></tr></table></figure><h4 id="关系">3. 关系</h4><p><del>尽量用自己的理解去阐述明白，如有不对，敬请指正。</del></p><p><del>第一阶段：在人类诞生初期，是没有族群、部落、国家之分的，此时相当于全人类都是属于一个<strong>人类的集合</strong>，此时的<strong>人类</strong>相当于<strong>一个人类</strong>，没有高低贵贱黑白美丑之分。</del></p><p><del>第二阶段：族群的出现，代表着某些人有用自己的势力范围，把人类一个整体分为N个族群</del></p><h3 id="第三部分-函数作用域">第三部分 函数作用域</h3><p>上一篇是关于<strong>函数的</strong>，那就以函数作用域为实例，类、模块都是类似的。</p><h4 id="整体的例子">1. 整体的例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">print(<span class="string">"第一步：x的内存地址： "</span>, id(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    <span class="comment"># 同层 x=2</span></span><br><span class="line">    print(<span class="string">"第二步：x的内存地址： "</span>, id(x))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        x = <span class="number">3</span></span><br><span class="line">        <span class="comment"># 打印同层 x=3</span></span><br><span class="line">        print(<span class="string">"第三步：x的内存地址： "</span>, id(x))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_up</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># 打印上层 x=2</span></span><br><span class="line">        print(<span class="string">"第三步(up)：x的内存地址： "</span>, id(x))</span><br><span class="line">    inner()</span><br><span class="line">    inner_up()</span><br><span class="line">    <span class="comment"># 打印的是同层x=2，即outer()下侧的同一作用域的x</span></span><br><span class="line">    print(<span class="string">"第四步：x的内存地址： "</span>, id(x))</span><br><span class="line">outer()</span><br><span class="line">print(<span class="string">"第五步：x的内存地址： "</span>, id(x))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python3 fun.py </span><br><span class="line">第一步：a的内存地址：  <span class="number">4336156688</span></span><br><span class="line">第二步：x的内存地址：  <span class="number">4336156720</span></span><br><span class="line">第三步：x的内存地址：  <span class="number">4336156752</span></span><br><span class="line">第三步(up)：x的内存地址：  <span class="number">4336156720</span></span><br><span class="line">第四步：x的内存地址：  <span class="number">4336156720</span></span><br><span class="line">第五步：x的内存地址：  <span class="number">4336156688</span></span><br></pre></td></tr></table></figure><h4 id="nonlocal和global区别">2. nonlocal和global区别</h4><ol type="1"><li>global关键字：用来在函数或其它局部作用域中<strong>使用全局变量</strong>。</li><li>nonlocal关键字：用来在函数或其它作用域中使用外层（非全局）变量</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">print(<span class="string">"第一步：x的内存地址： "</span>, id(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    print(<span class="string">"第二步：x的内存地址： "</span>, id(x))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># 注意这行</span></span><br><span class="line">        <span class="keyword">global</span> x</span><br><span class="line">        x = <span class="number">3</span></span><br><span class="line">        print(<span class="string">"第三步：x的内存地址： "</span>, id(x))</span><br><span class="line">    inner()</span><br><span class="line">    print(<span class="string">"第四步：x的内存地址： "</span>, id(x))</span><br><span class="line">outer()</span><br><span class="line">print(<span class="string">"第五步：x的内存地址： "</span>, id(x))</span><br></pre></td></tr></table></figure><p>针对outer中x的： 1. 采用global的结果 <img src="/2019/05/16_Python基础系列之匿名函数命名空间/20.png" alt="global"></p><ol start="2" type="1"><li>采用nonlocal的结果 <img src="/2019/05/16_Python基础系列之匿名函数命名空间/30.png" alt="nonlocal"></li></ol><h4 id="作用域的位置">3. 作用域的位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name =&apos;简单即是美&apos;</span><br><span class="line"></span><br><span class="line">def f1():</span><br><span class="line">    print(name)</span><br><span class="line"></span><br><span class="line">def f2():</span><br><span class="line">    name = &apos;Python&apos;</span><br><span class="line">    f1()</span><br><span class="line">f2()</span><br></pre></td></tr></table></figure><p><strong>Python函数的作用域取决于其函数代码块在整体代码中的位置，</strong>而不是调用时机的位置。调用f1的时候，会去f1函数的定义体查找，对于f1函数，它的外部是name='简单即是美'，而不是name = 'Python'。</p><p><strong>结果</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单即是美</span><br></pre></td></tr></table></figure></p><p>倒数第二步 <img src="/2019/05/16_Python基础系列之匿名函数命名空间/31.png" alt="倒数第二步"></p><p>参考链接</p><p><a href="https://www.linuxidc.com/Linux/2018-12/155918.htm" target="_blank" rel="noopener">Python 中命名空间与作用域使用总结</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 匿名函数 </tag>
            
            <tag> 命名空间 </tag>
            
            <tag> 作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之--函数【9】</title>
      <link href="/2019/05/15_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%87%BD%E6%95%B0/"/>
      <url>/2019/05/15_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="目标">目标</h2><ol type="1"><li>掌握 Python 函数--定义、参数类型</li><li>掌握 Python 函数--变量作用域</li></ol><blockquote><p>正确理解 Python 函数，能够更好地理解 <strong>Python 装饰器、匿名函数（lambda）、函数式编程</strong>等高阶技术。</p></blockquote><p>文章较长，整体内容包含如下思维导图</p><figure><img src="/2019/05/15_Python基础系列之函数/func.png" alt><figcaption>概述</figcaption></figure><h3 id="第一部分-重新认识函数">第一部分 重新认识函数</h3><h4 id="定义">1. 定义</h4><p>Python 中函数的定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数)</span>:</span></span><br><span class="line">    <span class="comment"># 内部代码</span></span><br><span class="line">    <span class="keyword">return</span> 表达式</span><br></pre></td></tr></table></figure><p>注意点：</p><ol type="1"><li>函数代码块以<code>def关键词</code>开头，一个空格之后接<code>函数标识符名称</code>和<code>圆括号()</code>，再接个<code>冒号</code>。</li><li>圆括号中间存放参数</li><li>使用 return 结束函数。默认返回 None。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a + b</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum</span><br><span class="line"><span class="comment"># 函数地址</span></span><br><span class="line">&lt;function sum at <span class="number">0x10af4f158</span>&gt;</span><br><span class="line"><span class="comment">## 函数方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(sum)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__qualname__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum.__name__</span><br><span class="line"><span class="string">'sum'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum.__module__</span><br><span class="line"><span class="string">'__main__'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="调用函数">2 调用函数</h4><p>使用函数名后跟圆括号的方式调用函数。 调用的同时要根据函数的定义体，提供<code>相应个数和类型的参数</code>，每个参数之间用逗号分隔。</p><h4 id="函数是对象">3. 函数是对象</h4><p><strong>在 Python 中万物皆为对象</strong>，函数也不例外，</p><ol type="1"><li>可以作为对象可以赋值给一个变量</li><li>可以作为元素添加到集合对象中</li><li>可作为参数值传递给其它函数</li><li>可以当做函数的返回值</li></ol><blockquote><p>函数身为一个对象，拥有对象模型的三个通用属性：<strong>id、类型、和值。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a + b</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(add)</span><br><span class="line"><span class="number">4472644200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(add)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">function</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">add</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">function</span> <span class="title">add</span> <span class="title">at</span> 0<span class="title">x10a972268</span>&gt;</span></span><br></pre></td></tr></table></figure><p>变量赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>newAdd = add</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newAdd(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add <span class="keyword">is</span> newAdd</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>其实上侧的，只是不同的名字指向同一个内存地址，同时这块地址被多次引用。</p><figure><img src="/2019/05/15_Python基础系列之函数/1.jpg" alt><figcaption>变量</figcaption></figure><blockquote><p>了解了函数是对象，以及上侧的几个性质，更得牢记一切都是对象。 既然是对象，性质都类似，其余的集合、参数、返回值，思考下就明白了</p></blockquote><h3 id="第二部分-参数类型">第二部分 参数类型</h3><p>其实就是下侧那个括号里的数据，但是需要注意的是，<code>传的是什么</code>，<code>怎么传</code></p><p><strong>定义</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数)</span>:</span></span><br><span class="line">    <span class="comment"># 内部代码</span></span><br><span class="line">    <span class="keyword">return</span> 表达式</span><br></pre></td></tr></table></figure><p><strong>完整的语法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(positional_args, keyword_args, *tuple_nonkw_args, **dict_kw_args)</span><br></pre></td></tr></table></figure><p><strong>函数的参数的分类</strong></p><ol type="1"><li>位置参数(必选参数)</li><li>默认参数</li><li>可变参数 *args</li><li>可变参数 **kwargs</li><li>必选参数</li></ol><h4 id="位置参数">1. 位置参数</h4><p>定义：<code>调用</code>时候的传的<code>参数</code>必须与<code>定义</code>时的<code>参数</code>一一对应。 注意事项： 不能多也不能少。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="comment"># 一一对应</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment"># 参数缺失</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sum(<span class="number">1</span>))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: sum() missing <span class="number">1</span> required positional argument: <span class="string">'b'</span></span><br><span class="line"><span class="comment"># 关键字参数,顺序不重要，存在即可</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sum(b=<span class="number">10</span>, a=<span class="number">4</span>))</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><h4 id="默认值">2. 默认值</h4><p>定义：在函数声明的时候，可以给某个参数指定默认值 注意事项： 位置：需要放在<code>位置参数</code>之后</p><p><strong>默认参数需要在位置参数的后边</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n = <span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x**n</span><br><span class="line">ret1 = power(<span class="number">10</span>)   <span class="comment"># 使用默认的参数值n=2</span></span><br><span class="line">ret2 = power(<span class="number">10</span>, <span class="number">4</span>)  <span class="comment"># 将4传给n，实际计算10**4的值</span></span><br><span class="line">ret3 = power(n=<span class="number">1</span>, x=<span class="number">100</span>) <span class="comment"># 指定参数名传值</span></span><br></pre></td></tr></table></figure><p><strong>来个例子</strong> 主要涉及：内存地址、参数默认值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a=[])</span>:</span></span><br><span class="line">    a.append(<span class="string">"A"</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">print(func())</span><br><span class="line">print(func())</span><br><span class="line">print(func())</span><br></pre></td></tr></table></figure><p><strong>三思</strong> <strong>三思</strong> <strong>三思</strong></p><p>答案如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'A'</span>]</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'A'</span>]</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'A'</span>, <span class="string">'A'</span>]</span><br></pre></td></tr></table></figure><p>如果真正理解了，Python 对象的<strong>变量名与内存地址</strong>,这个问题还是很简单的。</p><ol type="1"><li>默认参数 a 指向的空列表对象就会被创建，假如内存地址为<code>0x123</code>;</li><li>之后每次调用，都会在原地址后追加<code>A</code>;</li><li>可以试着在函数内部打印 a 的内存地址，应该是一致的。</li></ol><blockquote><p>如何避免这种操作？</p><blockquote><p>让 a 的默认值指向一个<strong>不可变对象即可</strong>，如：数字、None 等</p></blockquote></blockquote><h4 id="可变参数-args">3. 可变参数 *args</h4><p>在 python 里面，函数在声明的时候，参数中可以使用(*变量名)的方式来接受<code>不确定长度的参数</code>，但是在 python 里面大家约定俗成使用<code>*args</code>接受不定长参数，之后将这些参数放到一个<code>tuple</code>里面，可以通过访问 args 来获取这些不定长参数。</p><p><code>例子一</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">changeFunc</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(type(args))</span><br><span class="line"><span class="meta">... </span>    print(args)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>changeFunc(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="number">3</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="params">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="number">3</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>例子二</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>changeFunc([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="number">3</span>])</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="params">([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="number">3</span>],)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>为何打印出来是这样？ 因为是数组是作为一个整体传过来的。 如何将 list 的元素转换为 tuple 的元素？结果与例子一一致？</p></blockquote><p><strong>答案：</strong> 参数前加个星号,<a href="https://docs.python.org/2/tutorial/controlflow.html#unpacking-argument-lists" target="_blank" rel="noopener">解压参数列表</a>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tmpList = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(*tmpList)</span><br><span class="line">a b <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tmpList)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 调用函数时，数组➕星号，解压参数列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>changeFunc(*tmpList)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="params">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="number">3</span>)</span></span></span><br></pre></td></tr></table></figure><p>当参数已经在<code>列表或元组中</code>但需要为需要单独位置参数的函数, 需要解压参数, 然后再一一传进去</p><p>针对字典带上*号，解压的是 key</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict = &#123;<span class="string">"a"</span>: <span class="number">1</span>, <span class="string">"b"</span>: <span class="number">2</span>, <span class="string">"c"</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(*dict)</span><br><span class="line">a b c</span><br></pre></td></tr></table></figure><h4 id="可变参数-args-1">4. 可变参数 *args</h4><p>定义：<code>*args</code>参数表示未知的位置参数序列长度，而<code>\*\*kwargs</code>代表包含<strong>关键字和值映射关系的字典</strong>，它可以包含任意数量的关键字和值映射，并且在函数定义中“*args”必须位于“**kwargs”前面。</p><blockquote><p>*args 必须在**kwargs 之前。 默认值参数必须再必选参数之前。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">kwargs</span><span class="params">(first, second=<span class="number">2</span>, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(first, second)</span><br><span class="line"><span class="meta">... </span>    print(args)</span><br><span class="line"><span class="meta">... </span>    print(kwargs)</span><br><span class="line">...</span><br><span class="line"><span class="comment"># kwargs为空是因为被*args吃掉了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwargs(<span class="number">1</span>, <span class="number">3</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, &#123;<span class="string">"key1"</span>: <span class="string">"value"</span>&#125;)</span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, &#123;<span class="string">'key1'</span>: <span class="string">'value'</span>&#125;)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict = &#123;<span class="string">"key1"</span>: <span class="string">"value"</span>&#125;</span><br><span class="line"><span class="comment"># 解压参数，</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwargs(<span class="number">1</span>, <span class="number">3</span>, *list, **dict)</span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line">&#123;<span class="string">'key1'</span>: <span class="string">'value'</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后边不能追加参数了。。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(**kw, error)</span>:</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(**kw, error)</span>:</span></span><br><span class="line">                       ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><h4 id="关键字参数">5. 关键字参数</h4><blockquote><p>位置参数可以不带参数名，但是星号后边的就必选带上参数名</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 星号后必选加上参数名字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(loction, second, *, must)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(loction, second, must)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: func() takes <span class="number">2</span> positional arguments but <span class="number">3</span> were given</span><br><span class="line"><span class="comment"># 符合预期</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, must=<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>来一个汇总的骚操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">student</span><span class="params">(name, age=<span class="number">18</span>, *args, sex, classroom, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(name, age, args, sex, classroom, kwargs)</span><br><span class="line">...</span><br><span class="line"><span class="comment"># *args 之后的一般参数默认更改为关键字参数，sex/classroom未传递，报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>student(<span class="string">"howard"</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: student() missing <span class="number">2</span> required keyword-only arguments: <span class="string">'sex'</span> <span class="keyword">and</span> <span class="string">'classroom'</span></span><br><span class="line"><span class="comment"># 位置参数与关键字参数【必选】，可选参数【可选】</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>student(<span class="string">"howard"</span>, sex=<span class="string">"1"</span>, classroom=<span class="string">"python"</span>)</span><br><span class="line">howard <span class="number">10</span> () <span class="number">1</span> python &#123;&#125;</span><br><span class="line"><span class="comment"># dict</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict</span><br><span class="line">&#123;<span class="string">'key1'</span>: <span class="string">'value'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>student(<span class="string">"howard"</span>, sex=<span class="string">"1"</span>, classroom=<span class="string">"python"</span>, **dict)</span><br><span class="line">howard <span class="number">10</span> () <span class="number">1</span> python &#123;<span class="string">'key1'</span>: <span class="string">'value'</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="本文重点注意事项">本文重点注意事项：</h3><ol type="1"><li>牢记函数为第一类对象；</li><li>可选参数注意解压参数；</li></ol><p>参考 <a href="https://www.zhihu.com/question/25950466" target="_blank" rel="noopener">函数作为参数的问题</a> <a href="http://python.jobbole.com/81646/" target="_blank" rel="noopener">Python 中的函数详解</a> <a href="http://python.jobbole.com/81646/" target="_blank" rel="noopener"></a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 函数 </tag>
            
            <tag> 函数参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js基础系列之Http模块【5】</title>
      <link href="/2019/05/14_Node%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8BHttp%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/05/14_Node%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8BHttp%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="目标">目标</h2><ul><li>掌握Node.js核心模块之网络模块</li></ul><figure><img src="http://upload-images.jianshu.io/upload_images/326255-c6a6ee0a6a22f108.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><figcaption>文章目录</figcaption></figure><blockquote><p>Node.js标准库提供了 http 模块，是Node.js中非常重要的一个核心模块。</p></blockquote><p>通过http模块，你可以使用其http.createServer方法创建一个<code>http服务器</code>，也可以使用其http.request方法创建一个<code>http客户端。</code></p><h3 id="第一部分-http服务端">第一部分: http服务端</h3><h4 id="http是什么">1.1 HTTP是什么?</h4><p>HTTP是一个用来传送数据的应用层协议，在其底层使用TCP传输协议。HTTP是互联网数据通信的基础，要响应客户端请求（如：浏览器访问），首先要布署HTTP服务器。</p><h4 id="http之url">1.2 HTTP之URL</h4><p>URL: (Uniform / Universal Resource Locator，常缩写为URL)统一资源定位符,统一资源定位符的标准格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议类型://服务器地址（必要时需加上端口号）/路径/文件名</span><br></pre></td></tr></table></figure><figure><img src="http://upload-images.jianshu.io/upload_images/326255-0ada86699d61295d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><figcaption>http1-url-structure.png</figcaption></figure><h4 id="http之请求报文">1.3 http之请求报文</h4><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成;</p><figure><img src="http://upload-images.jianshu.io/upload_images/326255-f50e4e26dd6acfa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><figcaption>2012072810301161.png</figcaption></figure><p><strong>举例子:</strong></p><figure><img src="http://upload-images.jianshu.io/upload_images/326255-cf0c5d48bf504245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><figcaption>201411187986714.png</figcaption></figure><p>请求报文中关键的字段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">User-Agent：产生请求的浏览器类型;</span><br><span class="line">Accept：客户端可识别的响应内容类型列表;星号 “ * ” 用于按范围将类型分组，用 “ */* ” 指示可接受全部类型，用“ type/* ”指示可接受 type 类型的所有子类型;</span><br><span class="line">Accept-Language：客户端可接受的自然语言;</span><br><span class="line">Accept-Encoding：客户端可接受的编码压缩格式;</span><br><span class="line">Accept-Charset：可接受的应答的字符集;</span><br><span class="line">Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;</span><br><span class="line">connection：连接方式(close 或 keepalive);</span><br><span class="line">Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;</span><br></pre></td></tr></table></figure><h4 id="http响应报文">1.4 HTTP响应报文</h4><p>HTTP 响应报文由<code>状态行、响应头部、空行 和 响应包体</code> 4 个部分组成</p><figure><img src="http://upload-images.jianshu.io/upload_images/326255-7c6e79fa4c5d355a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><figcaption>201446213766964.jpg</figcaption></figure><p>状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx：指示信息--表示请求已接收，继续处理。</span><br><span class="line">2xx：成功--表示请求已被成功接收、理解、接受。</span><br><span class="line">3xx：重定向--要完成请求必须进行更进一步的操作。</span><br><span class="line">4xx：客户端错误--请求有语法错误或请求无法实现。</span><br><span class="line">5xx：服务器端错误--服务器未能实现合法的请求。</span><br></pre></td></tr></table></figure></p><p>常见的状态码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">200 OK：客户端请求成功。</span><br><span class="line">400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</span><br><span class="line">401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</span><br><span class="line">403 Forbidden：服务器收到请求，但是拒绝提供服务。</span><br><span class="line">404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</span><br><span class="line">500 Internal Server Error：服务器发生不可预期的错误。</span><br><span class="line">503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</span><br></pre></td></tr></table></figure><h3 id="第二部分-http服务器端">第二部分 http服务器端</h3><h4 id="http.server遵循了node.js的时间模块的规则-有触发和相应事件http.server对象是一个eventemitter">1.1 http.server遵循了node.js的时间模块的规则, 有触发和相应事件;http.Server对象是一个EventEmitter;</h4><p>创建: http.createServer方法会返回一个<code>http.Server对象实例</code>，requestListener可选参数传入时，将做为http.Server对象'request'事件的监听器。</p><p>http.Server对象提供的事件方法有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. request: function (request, response) &#123; &#125;每次请求都会触发该方法;</span><br><span class="line">2. connection：当TCP连接建立时，该事件被触发，提供一个参数socket，是net.Socket的实例;</span><br><span class="line">3. close: 当此服务器关闭时触发;</span><br><span class="line">等等..</span><br></pre></td></tr></table></figure><h4 id="http.server中的方法">1.2 http.Server中的方法</h4><h5 id="server.listenport-hostname-backlog-callback">2.2.1 server.listen(port[, hostname][, backlog][, callback])</h5><p>在指定的主机名（hostname）和端口（port）开始接收连接,</p><h5 id="server.listenpath-callback">1.2.2 server.listen(path, [callback])</h5><p>监听某个</p><h4 id="http.serverresponse服务器响应对象">1.3 http.ServerResponse服务器响应对象</h4><p>http.ServerResponse是一个由http.Server创建的对象, ，在触发'request'事件后，做事件回调函数的第二个参数传递给回调函数.</p><p><code>response.writeHead(statusCode[, statusMessage][, headers])</code></p><p>向客户端请求发送一个响应头。 statusCode状态码是 3 位数字，如：404。 statusMessage设置状态消息。 最后一个参数headers是响应头。</p><blockquote><p>这个方法只能在当前请求中使用一次，并且必须在response.end()之前调用。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var body = &apos;hello world&apos;;</span><br><span class="line">response.writeHead(200, &#123;</span><br><span class="line">  &apos;Content-Length&apos;: body.length,</span><br><span class="line">  &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;);</span><br></pre></td></tr></table></figure><p><code>response.setHeader(name, value)</code></p><p>为默认或者已存在的头设置一条单独的头内容。如果这个头已经存在于 将被送出的头中，将会覆盖原来的内容。如果我想设置更多的头， 就使用一个相同名字的字符串数组</p><p><code>response.write(chunk, [encoding])</code> 向响应流发送一个数据块。这个方法可能被调用多次，以提供响应体内容。</p><p><code>response.end([data], [encoding])</code></p><p>当所有的响应报头和报文被发送完成时这个方法将信号发送给服务器，服务器会认为这个消息完成了。 每次响应完成之后必须调用该方法。</p><h3 id="第三部分-http客户端">第三部分 http客户端</h3><p>http模块提供了两个创建HTTP客户端的方法<code>http.request</code>和<code>http.get</code>，以向HTTP服务器发起请求。<code>http.get是http.request快捷方法</code>，该方法仅支持GET方式的请求。</p><p>一个 IncomingMessage对象是由 http.Server或http.ClientRequest创建的，并作为第一参数分别传递给'request'和'response' 事件。它也可以被用来访问应答的状态，头文件和数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">  var content = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">  req.on(&apos;data&apos;, function (chunk) &#123;</span><br><span class="line">    content += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  req.on(&apos;end&apos;, function () &#123;</span><br><span class="line">    res.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">    res.write(&quot;You&apos;ve sent: &quot; + content);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;).listen(3000);</span><br></pre></td></tr></table></figure><p>data事件会在数据接收过程中，每收到一段数据就触发一次，接收到的数据被传入回调函数。end事件则是在所有数据接收完成后触发。</p><p><code>http.request(options[, callback])</code> request方法的options参数，可以是一个对象，也可以是一个字符串。如果是字符串，就表示这是一个URL，Node内部就会自动调用url.parse()，处理这个参数。</p><p>options对象可以设置如下属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">host：HTTP请求所发往的域名或者IP地址，默认是localhost。</span><br><span class="line">hostname：该属性会被url.parse()解析，优先级高于host。</span><br><span class="line">port：远程服务器的端口，默认是80。</span><br><span class="line">localAddress：本地网络接口。</span><br><span class="line">socketPath：Unix网络套接字，格式为host:port或者socketPath。</span><br><span class="line">method：指定HTTP请求的方法，格式为字符串，默认为GET。</span><br><span class="line">path：指定HTTP请求的路径，默认为根路径（/）。可以在这个属性里面，指定查询字符串，比如/index.html?page=12。如果这个属性里面包含非法字符（比如空格），就会抛出一个错误。</span><br><span class="line">headers：一个对象，包含了HTTP请求的头信息。</span><br><span class="line">auth：一个代表HTTP基本认证的字符串user:password。</span><br><span class="line">agent：控制缓存行为，如果HTTP请求使用了agent，则HTTP请求默认为Connection: keep-alive，它的可能值如下：</span><br><span class="line">undefined（默认）：对当前host和port，使用全局Agent。</span><br><span class="line">Agent：一个对象，会传入agent属性。</span><br><span class="line">false：不缓存连接，默认HTTP请求为Connection: close。</span><br><span class="line">keepAlive：一个布尔值，表示是否保留socket供未来其他请求使用，默认等于false。</span><br><span class="line">keepAliveMsecs：一个整数，当使用KeepAlive的时候，设置多久发送一个TCP KeepAlive包，使得连接不要被关闭。默认等于1000，只有keepAlive设为true的时候，该设置才有意义。</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">http.createServer(function(req, res)&#123;</span><br><span class="line">//仅对从http.Server获得到的请求(request)有效.</span><br><span class="line">console.log(req.url);</span><br><span class="line">//请求/响应 头对象.</span><br><span class="line">console.log(req.headers);</span><br><span class="line">//服务器的HTTP版本。</span><br><span class="line">console.log(req.httpVersion);</span><br><span class="line">//接收到的原始请求/响应头字段列表。</span><br><span class="line">console.log(req.rawHeaders);</span><br><span class="line">//仅对从http.Server获得到的请求(request)有效.比如‘GET’、‘DELETE’。</span><br><span class="line">console.log(req.method);</span><br><span class="line">&#125;).listen(3000, &apos;127.0.0.1&apos;);</span><br></pre></td></tr></table></figure><h3 id="第四部分-实例">第四部分 实例</h3><h4 id="创建服务器-实现get方法">1 创建服务器, 实现GET方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">//创建一个服务器, 回调函数的参数为响应, 和请求</span><br><span class="line">http.createServer(function(request, response)&#123;</span><br><span class="line">//response.writeHead方法用来写入HTTP回应的头信息；</span><br><span class="line">response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;);</span><br><span class="line">//指定HTTP回应的内容。</span><br><span class="line">//response.write(&apos;hello world&apos;);</span><br><span class="line">//response.end方法用来写入HTTP回应的具体内容，以及回应完成后关闭本次对话。</span><br><span class="line">response.end(&apos;hello world&apos;);</span><br><span class="line">//监听端口号和主机名</span><br><span class="line">&#125;).listen(3000, &apos;127.0.0.1&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;127.0.0.1:3000&apos;);</span><br></pre></td></tr></table></figure><h4 id="加载html文件">2. 加载HTML文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">http.createServer(function(req, res)&#123;</span><br><span class="line">//读取HTML文件</span><br><span class="line">fs.readFile(&apos;./2index.html&apos;, &apos;utf-8&apos;,function(err, data)&#123;</span><br><span class="line">if(err) throw err;</span><br><span class="line">//为默认或者已存在的头设置一条单独的头内容。</span><br><span class="line">res.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset=&apos;utf-8&apos;&quot;);</span><br><span class="line">//响应的数据</span><br><span class="line">res.end(data);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;).listen(3000, &apos;127.0.0.1&apos;);</span><br></pre></td></tr></table></figure><h4 id="创建服务器-实现post方法">3 创建服务器, 实现POST方法</h4><p>一个简单的post请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">http.createServer(function(req, res) &#123;</span><br><span class="line">//fs模块创建流文件, 名称为post.txt</span><br><span class="line">var file = fs.createWriteStream(&apos;post.txt&apos;);</span><br><span class="line">////管子 pipe自动调用了data,end等事件 writeStream/readStream</span><br><span class="line">req.pipe(file);</span><br><span class="line">// 当有数据流时，写入数据</span><br><span class="line">req.on(&apos;data&apos;, function(postData)&#123;</span><br><span class="line">console.log(postData);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.on(&apos;end&apos;, function()&#123;</span><br><span class="line">res.end(&apos;end&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;).listen(3000);</span><br></pre></td></tr></table></figure><figure><img src="http://upload-images.jianshu.io/upload_images/326255-3bdb0fd3627591a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><figcaption>post请求</figcaption></figure><p>参考链接 <a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">1.HTTP 协议入门</a> <a href="http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html" target="_blank" rel="noopener">2.HTTPS 升级指南</a> <a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/28/2612910.html" target="_blank" rel="noopener">3.HTTP请求报文和HTTP响应报文</a> <a href="http://yijiebuyi.com/blog/d37512fc6df0fc4d0adfc2ec5c3d46ff.html" target="_blank" rel="noopener">4.node.js querystring类介绍</a> <a href="https://segmentfault.com/a/1190000000519006" target="_blank" rel="noopener">5.nodejs中流(stream)的理解</a> <a href="http://www.cnblogs.com/dolphinX/p/3460545.html" target="_blank" rel="noopener">6.简单理解Socket</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块 </tag>
            
            <tag> Node </tag>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js基础系列之Event模块【4】</title>
      <link href="/2019/05/13_Node%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8BEvent%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/05/13_Node%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8BEvent%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="目标">目标</h2><ol type="1"><li>理解JS 单线程、 Node.js EventLoop</li><li>理解Node.js事件模块</li></ol><h3 id="第一部分-前提-nodejs-eventloop">第一部分 前提 Nodejs EventLoop</h3><h4 id="堆栈队列">1 【堆】【栈】【队列】</h4><figure><img src="http://upload-images.jianshu.io/upload_images/326255-bf1b1203a4c73069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><figcaption>堆栈队列</figcaption></figure><p>任何一种语言的运行环境都少不了<strong>堆（heap）栈（Stack）队列 (queue) </strong> JS也不例外。</p><ol type="1"><li>JS的<code>临时变量以及调用时的形参</code>等等数据都是存储在<code>栈</code>中；</li><li><code>堆</code>则是存储实际的<code>对象</code>;</li><li>对象的<code>引用变量名(指针)</code>也是在<code>栈</code>；</li></ol><p>而队列则是JS在实时运行环境中创建的消息队列或者事件队列。</p><p><strong>JS是单线程，所以队列的实现让JS的异步处理有了可能性。</strong></p><h4 id="单线程任务队列">2 单线程、任务队列</h4><blockquote><p>尽信书不如无书，就喜欢这种有理有据的</p></blockquote><p>摘录自<a href="http://blog.csdn.net/lin_credible/article/details/40143961" target="_blank" rel="noopener">【朴灵评注】JavaScript 运行机制详解：再谈Event Loop</a></p><p>为了避免复杂性，JS从一诞生，<strong>同一个时间只能做一件事</strong>。 <code>JavaScript就是单线程</code>，这已经成了这门语言的核心特征，将来也不会改变。</p><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，<code>允许JavaScript脚本创建多个线程</code>，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并<strong>没有改变JavaScript单线程的本质。</strong></p><p>异步执行的运行机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）所有任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。系统把异步任务放到&quot;任务队列&quot;之中，然后继续执行后续的任务。</span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有任务执行完毕，系统就会读取&quot;任务队列&quot;。如果这个时候，异步任务已经结束了等待状态，就会从&quot;任务队列&quot;进入执行栈，恢复执行。</span><br><span class="line">（4）主线程不断重复上面的第三步。</span><br></pre></td></tr></table></figure><p>上面这段初步地在说event loop。但是异步跟event loop其实没有关系。准确的讲，<strong>【event loop是实现异步的一种机制】</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【上面提到的一系列的手段其实就是实现异步的方法，其中就包括event loop。以及轮询、事件等。】</span><br><span class="line">【所谓轮询：就是你在收银台付钱之后，坐到位置上不停的问服务员你的菜做好了没。】</span><br><span class="line">【所谓（事件）：就是你在收银台付钱之后，你不用不停的问，饭菜做好了服务员会自己告诉你。】</span><br></pre></td></tr></table></figure><p>【JavaScript运行环境的运行机制，不是JavaScript的运行机制。】</p><h4 id="事件循环">3 事件循环</h4><p>首先我们看一下nodejs本质结构图</p><figure><img src="http://upload-images.jianshu.io/upload_images/326255-f87e70367e376a31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><figcaption>image.png</figcaption></figure><p>Node.js 通过 libuv 来处理与操作系统的交互，并且因此具备了【异步、非阻塞、事件驱动】的能力。Node.js 实际上是 Javascript 执行线程的<strong>单线程</strong>，真正的<strong>I/O 操作</strong>，底层 API 调用都是通过<code>多线程执行</code>的。</p><blockquote><p>本质也就是：任务接收是单线程，任务执行是多线程。</p></blockquote><p>那么也就是主要依靠<code>libuv</code>，那么本文主要介绍Nodejs事件模块，当然离不开原理</p><p>为何是这样？</p><p>为何这么吊？</p><p>为何又出现那么多回调函数？</p><p>带着一些列问题搞明白了理论，至于代码，那也调用哪些大神写的API吧！</p><p><strong>膜拜大神三秒钟</strong></p><p>技术(艺术)源自生活、高于生活。对吧。</p><figure><img src="http://upload-images.jianshu.io/upload_images/326255-d471d0bb2ec57f84.gif?imageMogr2/auto-orient/strip" alt><figcaption>歪瓜仁真会玩</figcaption></figure><p>只要开始启动，那么这个姑娘就开始嗨起来了，其实我们事件循环也是这样的！从启动开始，就一直不停止的监听。</p><p>【论英文的重要性】</p><figure><img src="http://upload-images.jianshu.io/upload_images/326255-0508d9f9917ca62d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><figcaption>image.png</figcaption></figure><p>一图胜千言，但我还是就下图做个简单的梳理吧。我可不想被同为学渣的老铁们骂哈。</p><figure><img src="http://upload-images.jianshu.io/upload_images/326255-e991be1421256e2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><figcaption>image.png</figcaption></figure><p>我们程序猿其实工作还是仅限于代码调用编写阶段，主要的核心在于理解内部原理，然后根据需求去编写(复制)代码。</p><p>讲个故事吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JS单身狗(单线程)无异议，但它也是个贪心的黑心老板，在外边一直接活一直接活，根本无视</span><br><span class="line">员工的死活，程序猿们为了改变世界(为了生存)不得不听产品经理的安排（程序猿心中的恶魔），</span><br><span class="line">产品经理承上启下，一直分发任务(闲就不是代码狗了)，而为了理想而奋战(别给我嘚瑟四点的晨曦，</span><br><span class="line">老子刚下班)。</span><br><span class="line">世界越来越美好(为奋战的人祈祷安康)！</span><br></pre></td></tr></table></figure><p>Nodejs中是怎么个情况，请看下图</p><figure><img src="http://upload-images.jianshu.io/upload_images/326255-7399386c22e242bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><figcaption>event5.png</figcaption></figure><p>好了，结束了，接下来就是代码啦。</p><h3 id="第二部分-events模块概述">第二部分 Events模块概述</h3><h4 id="events模块">1 Events模块</h4><p><strong>Events模块</strong>是Node对“发布/订阅”模式（publish/subscribe）的实现。一个对象通过这个模块，向另一个对象传递消息。</p><p><strong>Node</strong>中的<em>Event模块仅仅</em>提供了一个对象: <strong>EventEmitter</strong>, EventEmitter 的<strong>核心</strong>就是<em>事件触发与事件监听器功能的封装。</em></p><p>获取<strong>EventEmitter</strong>对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//引用模块events, 点语法获取到EventEmitter</span><br><span class="line">var EventEmitter = require(&apos;events&apos;).EventEmitter;</span><br><span class="line">//初始化一个对象, 这个实例就是消息中心。</span><br><span class="line">var emitter = new EventEmitter;</span><br></pre></td></tr></table></figure><h4 id="eventemitter-实例对象的方法">2 EventEmitter 实例对象的方法</h4><p><em>2.1 emitter.on(eventName, listener), 监听事件,如果触发就调用回调函数</em> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. eventName &lt;String&gt; | &lt;Symbol&gt;: 事件名称, 后边可以跟上函数;</span><br><span class="line">2. listener &lt;Function&gt; : 回调函数;</span><br></pre></td></tr></table></figure></p><p><em>2.2 emitter.emit(eventName[, ...args]), 根据eventName发送通知, 触发事件, 第一个参数为事件名称, 其余的参数会依次传入回调函数</em></p><p>以上两个方法的示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var EventEmitter = require(&apos;events&apos;).EventEmitter;</span><br><span class="line">var emitter = new EventEmitter();</span><br><span class="line"></span><br><span class="line">//监听函数1, 事件名为--fun1</span><br><span class="line">emitter.on(&apos;fun1&apos;, function()&#123;</span><br><span class="line">console.log(&apos;触发函数1&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//定义有参数函数fun2, </span><br><span class="line">var fun2 = function(para)&#123;</span><br><span class="line">console.log(&apos;触发函数2, 参数为&apos; + para);</span><br><span class="line">&#125;;</span><br><span class="line">//监听fun2</span><br><span class="line">emitter.on(&apos;fun2&apos;, fun2);</span><br><span class="line"></span><br><span class="line">//触发事件名</span><br><span class="line">emitter.emit(&apos;fun1&apos;);</span><br><span class="line">//触发事件名并且传参数</span><br><span class="line">emitter.emit(&apos;fun2&apos;, &apos;event&apos;);</span><br></pre></td></tr></table></figure><p>打印结果为: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node 2on.js </span><br><span class="line">触发函数1</span><br><span class="line">触发函数2, 参数为event</span><br></pre></td></tr></table></figure></p><p><em>2.3 emitter.once(eventName, listener), 类似on方法, 但回调函数只是执行一次</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var EventEmitter = require(&apos;events&apos;).EventEmitter;</span><br><span class="line">var emitter = new EventEmitter();</span><br><span class="line"></span><br><span class="line">emitter.once(&apos;oncefun&apos;, function()&#123;</span><br><span class="line">console.log(&apos;函数只执行一次&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">emitter.emit(&apos;oncefun&apos;);</span><br><span class="line">emitter.emit(&apos;oncefun&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;--------&apos;)</span><br><span class="line"></span><br><span class="line">emitter.on(&apos;fun&apos;, function()&#123;</span><br><span class="line">console.log(&apos;函数&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">emitter.emit(&apos;fun&apos;);</span><br><span class="line">emitter.emit(&apos;fun&apos;);</span><br></pre></td></tr></table></figure><p>执行的结果为: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node 3once.js </span><br><span class="line">函数只执行一次</span><br><span class="line">函数</span><br><span class="line">函数</span><br></pre></td></tr></table></figure></p><p>虽然触发多次oncefun, 但依然打印一次;与下边形成对比;,</p><p><em>2.4 emitter.addListener(eventName, listener)类似于emitter.on(eventName, listener)</em></p><p><em>2.5 emitter.removeListener(eventName, listener), 移除监听</em></p><p>详细见实例代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var EventEmitter = require(&apos;events&apos;).EventEmitter;</span><br><span class="line">var emitter = new EventEmitter();</span><br><span class="line"></span><br><span class="line">//定义一个函数</span><br><span class="line">var removeFun = function()&#123;</span><br><span class="line">console.log(&apos;输出结果&apos;);</span><br><span class="line">&#125;</span><br><span class="line">//以fun名称监听removeFun</span><br><span class="line">emitter.on(&apos;fun&apos;, removeFun);</span><br><span class="line">//每个30毫秒触发一次回调函数</span><br><span class="line">setInterval(function()&#123;</span><br><span class="line">emitter.emit(&apos;fun&apos;);</span><br><span class="line">&#125;, 30);</span><br><span class="line">//200毫秒以后触发回调函数</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">emitter.removeListener(&apos;fun&apos;, removeFun);</span><br><span class="line">&#125;, 200);</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ node 5removeListener.js </span><br><span class="line">输出结果</span><br><span class="line">输出结果</span><br><span class="line">输出结果</span><br><span class="line">输出结果</span><br><span class="line">输出结果</span><br><span class="line"></span><br><span class="line">#光标停止</span><br></pre></td></tr></table></figure><p>######第三部分 更多API详见</p><p>语法名称觉得挺好的, 见名知意. 更多的语法就看<a href="https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener" target="_blank" rel="noopener">Node官网</a>吧 -__-</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Event: &apos;newListener&apos;</span><br><span class="line">Event: &apos;removeListener&apos;</span><br><span class="line">EventEmitter.listenerCount(emitter, eventName)</span><br><span class="line">EventEmitter.defaultMaxListeners</span><br><span class="line">emitter.addListener(eventName, listener)</span><br><span class="line">emitter.emit(eventName[, ...args])</span><br><span class="line">emitter.eventNames()</span><br><span class="line">emitter.getMaxListeners()</span><br><span class="line">emitter.listenerCount(eventName)</span><br><span class="line">emitter.listeners(eventName)</span><br><span class="line">emitter.on(eventName, listener)</span><br><span class="line">emitter.once(eventName, listener)</span><br><span class="line">emitter.prependListener(eventName, listener)</span><br><span class="line">emitter.prependOnceListener(eventName, listener)</span><br><span class="line">emitter.removeAllListeners([eventName])</span><br><span class="line">emitter.removeListener(eventName, listener)</span><br><span class="line">emitter.setMaxListeners(n)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Event </tag>
            
            <tag> 模块 </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之--阶段总结【8】</title>
      <link href="/2019/05/12_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/"/>
      <url>/2019/05/12_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="目标">目标</h2><ol type="1"><li>补充基础阶段相关内容</li><li>回顾基础系列之<strong>数据类型</strong></li></ol><h3 id="第一部分">第一部分</h3><p>有了前一部分的铺垫，相信大家已经明白<strong>变量名只是对内存空间的映射</strong>，那么</p><ol type="1"><li>共享变量是怎么回事？</li><li>深浅拷贝又是是什么？</li></ol><h4 id="赋值与深浅拷贝">1. 赋值与深浅拷贝</h4><p>🤔 思考如下代码，<code>a、b、c、x</code>四者在<code>x = x + [3, 4]</code>前后的地址是如何变化的？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">1</span></span><br><span class="line"><span class="comment"># print(" a: %s \n b: %s \n c: %s" % (id(a), id(b), id(c)))</span></span><br><span class="line"><span class="comment"># print(" -----")</span></span><br><span class="line">x = [a, b, c]</span><br><span class="line"><span class="comment"># print(" x: %s \n ------ \n x[0]: %s \n x[1]: %s \n x[2]: %s" % (id(x), id(x[0]), id(x[1]), id(x[2])))</span></span><br><span class="line">x = x + [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># print(" -----")</span></span><br><span class="line"><span class="comment"># print(" x: %s \n ------ \n x[0]: %s \n x[1]: %s \n x[2]: %s" % (id(x), id(x[0]), id(x[1]), id(x[2])))</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="comment"># print(" a: %s" % (id(a)))</span></span><br></pre></td></tr></table></figure><p>打印结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a: <span class="number">4323184656</span></span><br><span class="line">b: <span class="number">4323184688</span></span><br><span class="line">c: <span class="number">4323184656</span></span><br><span class="line">-----</span><br><span class="line">x: <span class="number">4324441928</span></span><br><span class="line">------</span><br><span class="line">x[<span class="number">0</span>]: <span class="number">4323184656</span></span><br><span class="line">x[<span class="number">1</span>]: <span class="number">4323184688</span></span><br><span class="line">x[<span class="number">2</span>]: <span class="number">4323184656</span></span><br><span class="line">-----</span><br><span class="line">x: <span class="number">4324441928</span>, y: <span class="number">4324441928</span></span><br><span class="line">-----</span><br><span class="line">x: <span class="number">4326634696</span></span><br><span class="line">------</span><br><span class="line">x[<span class="number">0</span>]: <span class="number">4323184656</span></span><br><span class="line">x[<span class="number">1</span>]: <span class="number">4323184688</span></span><br><span class="line">x[<span class="number">2</span>]: <span class="number">4323184656</span></span><br><span class="line">a: <span class="number">4323184720</span></span><br></pre></td></tr></table></figure><figure><img src="/2019/05/12_Python基础系列之阶段总结/01.jpg" alt><figcaption>四种情况</figcaption></figure><ol type="1"><li>尽量用<code>+=</code>,<code>-=</code>之类复合符号的，因为无需开辟新的，+=会自动调用 extend 方法进行合并运算, 共享引用；</li><li><strong>【不可变对象】</strong>：如打印结果中的<code>开始和结束</code>的<code>a</code>,地址是不同的，重新申请地址；</li><li><strong>【可变对象】</strong>：无需重新申请地址，但区域可长可短；</li></ol><h4 id="浅拷贝">2. 浅拷贝</h4><p>不管多么复杂的数据结构，浅拷贝都只会 copy 一层；如需<strong>完整拷贝，请参考深拷贝</strong>，还记得这个图么？</p><figure><img src="/2019/05/12_Python基础系列之阶段总结/7.jpg" alt><figcaption>浅复制</figcaption></figure><h4 id="深拷贝">3. 深拷贝</h4><p>深拷贝——即 python 的 copy 模块提供的另一个 deepcopy 方法。深拷贝会完全复制原变量相关的所有数据，在内存中生成一套完全一样的内容，在这个过程中我们对这两个变量中的一个进行<strong>任意修改都不会影响其他变量</strong>。</p><figure><img src="/2019/05/12_Python基础系列之阶段总结/9.jpg" alt><figcaption>深复制</figcaption></figure><h3 id="第二部分">第二部分</h3><h4 id="打印-print">1. 打印 Print</h4><p>日常调试，还是离不开打印的，大概了解下如何打印，有两种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. %</span><br><span class="line">2. format</span><br></pre></td></tr></table></figure><p>举几个简单的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">" x: %s, y: %s"</span> % (id(x), id(y)))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"&#123;&#125; &#123;&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>))</span><br><span class="line">print(<span class="string">"&#123;1&#125; &#123;0&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>))</span><br></pre></td></tr></table></figure><p><strong>表格</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%s    字符串 (采用str()的显示)</span><br><span class="line">%r    字符串 (采用repr()的显示)</span><br><span class="line">%c    单个字符</span><br><span class="line">%b    二进制整数</span><br><span class="line">%d    十进制整数</span><br><span class="line">%i    十进制整数</span><br><span class="line">%o    八进制整数</span><br><span class="line">%x    十六进制整数</span><br><span class="line">%e    指数 (基底写为e)</span><br><span class="line">%E    指数 (基底写为E)</span><br><span class="line">%f    浮点数</span><br><span class="line">%F    浮点数，与上相同</span><br><span class="line">%g    指数(e)或浮点数 (根据显示长度)</span><br><span class="line">%G    指数(E)或浮点数 (根据显示长度)</span><br></pre></td></tr></table></figure><h3 id="第三部分-前期知识汇总">第三部分 前期知识汇总</h3><figure><img src="/2019/05/12_Python基础系列之阶段总结/Python数据类型.png" alt><figcaption>Python基础数据类型</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
            <tag> Python </tag>
            
            <tag> 阶段总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之--变量、赋值、引用【7】</title>
      <link href="/2019/05/10_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B5%8B%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>/2019/05/10_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B5%8B%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="目标">目标</h2><ol type="1"><li>了解变量名与变量的关系</li><li>理解引用、拷贝、赋值等概念与含义</li></ol><h4 id="前提概况">1 前提概况</h4><p>我们接触最多的就是<strong>变量</strong>，究竟<code>变量名</code> 与 <code>变量值</code> 关系是啥？如何存储？</p><p>首先看一个最简单的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br></pre></td></tr></table></figure><p>上侧是一个<strong>赋值操作</strong>，其中<code>a是变量名</code>，<code>100是变量的值</code>。编程语言的编译器（或者解释器）处理到这一句代码的时候，一般语言会这样做</p><ol type="1"><li>在内存中<strong>开辟</strong>一个内存空间, <strong>地址</strong>0x4377878280;</li><li><strong>存放</strong>100进第一步的空间中；</li><li><strong>取值</strong>100时，找到地址为<strong>0x4377878280</strong>即可。</li></ol><p><strong>但是</strong> <strong>但是</strong> <strong>但是</strong></p><p>这么长除了计算机能记住，我是记不住。正如ip地址与域名的关系，我们只需要记住taobao.com即可，所以，<strong>编译器给我们做了个表，在这个表中，它将内存地址和变量名做了个映射</strong></p><table><thead><tr class="header"><th>变量名</th><th>内存地址</th></tr></thead><tbody><tr class="odd"><td>a</td><td>0x4377878280</td></tr><tr class="even"><td>b</td><td>0x4377878281</td></tr><tr class="odd"><td>c</td><td>0x4377878282</td></tr><tr class="even"><td>...</td><td>....</td></tr></tbody></table><p><strong>变量名完全可以看成一个内存地址的别名（只是方便我们记忆），真正的数据是存在这个内存地址的存储空间上的。变量名在运行的时候，没有任何用处。</strong></p><figure><img src="/2019/05/10_Python基础系列之赋值引用/a.jpg" alt><figcaption>赋值</figcaption></figure><h4 id="深入一些">2. 深入一些</h4><p>奔着：以问题来解决疑问题，先看这个代码，思考一下结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values[<span class="number">1</span>] = values</span><br></pre></td></tr></table></figure><p><strong>请认真思考此时 values 是多少？</strong> <strong>请认真思考此时 values 是多少？</strong> <strong>请认真思考此时 values 是多少？</strong></p><p>也许你认为是<code>[0, [0, 1, 2], 2]</code>,原因可能是： 1. list 可变； 2. 把list[1]的位置直接添加一个list；</p><p>代码如下，<code>完全符合预期</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p>但是结果却是 <strong>无限循环</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>values</span><br><span class="line">[<span class="number">0</span>, [...], <span class="number">2</span>]</span><br></pre></td></tr></table></figure><blockquote><p>❌就❎在第二步中 其中涉及两个概念：引用、拷贝</p></blockquote><p>第一部分已经说过，<strong>变量名是内存的别称</strong>，</p><p><code>a=10</code>的含义：内存中有个地址0x1234567的空间存了10，然后a指向这块内存。</p><figure><img src="/2019/05/10_Python基础系列之赋值引用/1.jpg" alt><figcaption>变量多次'赋值‘</figcaption></figure><p><strong>上图中很好的证明了，变量‘赋不同值’，只是引用不同而已</strong></p><p><code>values[1] = values</code>只是把自身指向自身。如图：</p><figure><img src="/2019/05/10_Python基础系列之赋值引用/3.jpg" alt><figcaption>自身引用自身</figcaption></figure><p>如需达到预期效果，只需要类似于你的逻辑，<strong>指向一份值相同但内存不同的值</strong></p><figure><img src="/2019/05/10_Python基础系列之赋值引用/5.jpg" alt><figcaption>值相同但内存不同</figcaption></figure><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝生成一份新的数据，</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values[<span class="number">1</span>] = values[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values</span><br><span class="line">[<span class="number">0</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>往更深处说，values[:] 复制操作是所谓的「浅复制」(shallow copy)，当列表对象有嵌套的时候也会产生出乎意料的错误，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>]</span><br><span class="line">b = a[:]</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span></span><br><span class="line"><span class="comment"># 正确答案</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[<span class="number">8</span>, [<span class="number">1</span>, <span class="number">9</span>], <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b)</span><br><span class="line">[<span class="number">0</span>, [<span class="number">1</span>, <span class="number">9</span>], <span class="number">3</span>]</span><br><span class="line"><span class="comment"># a 与 b 的地址确实不同</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(a))</span><br><span class="line"><span class="number">4355761096</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(b))</span><br><span class="line"><span class="number">4355761416</span></span><br><span class="line"><span class="comment"># 但是内部list的地址确实相同的，也就是共同指向了同一块内存地址</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(a[<span class="number">1</span>]))</span><br><span class="line"><span class="number">4354260680</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(b[<span class="number">1</span>]))</span><br><span class="line"><span class="number">4354260680</span></span><br></pre></td></tr></table></figure><p>看完上图的打印结果，请看下图；</p><figure><img src="/2019/05/10_Python基础系列之赋值引用/7.jpg" alt><figcaption>浅复制</figcaption></figure><p><strong>重点： values[:] 只是浅层复制</strong> <strong>重点： values[:] 只是浅层复制</strong> <strong>重点： values[:] 只是浅层复制</strong></p><p>正确的复制嵌套元素的方法是进行「深复制」(deep copy)，方法是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>]</span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">9</span></span><br></pre></td></tr></table></figure><figure><img src="/2019/05/10_Python基础系列之赋值引用/9.jpg" alt><figcaption>深复制</figcaption></figure><h4 id="引用-vs-拷贝">3 引用 VS 拷贝：</h4><ol type="1"><li>没有限制条件的分片表达式（L[:]）能够复制序列，但此法<strong>只能浅层复制</strong>。</li><li>字典 copy 方法，D.copy() 能够复制字典，但此法<strong>只能浅层复制</strong></li><li>有些内置函数，例如 list，能够生成拷贝 list(L)</li><li>copy 标准库模块能够生成完整拷贝：<strong>deepcopy 本质上是递归 copy</strong></li><li></li></ol><h3 id="参考链接">参考链接</h3><p><a href="https://my.oschina.net/leejun2005/blog/145911" target="_blank" rel="noopener">python基础（5）：深入理解 python 中的赋值、引用、拷贝、作用域 原</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
            <tag> Python </tag>
            
            <tag> 赋值 </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之--迭代器/解析式【6】</title>
      <link href="/2019/05/09_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%AD%E4%BB%A3/"/>
      <url>/2019/05/09_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%AD%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="目标">目标</h2><ol type="1"><li>掌握解析式的使用</li></ol><ul><li>liet 解析式</li><li>dict 解析式</li></ul><ol start="2" type="1"><li>深入理解迭代器</li><li>深入理解生成器</li></ol><h3 id="第一部分-迭代器生成器">第一部分 迭代器、生成器</h3><p>参考<a href="https://foofish.net/iterators-vs-generators.html" target="_blank" rel="noopener">完全理解Python迭代对象、迭代器、生成器</a>, 完整实例请看原文。</p><blockquote><p>在了解Python的数据结构时，<strong>容器(container)</strong>、<strong>可迭代对象(iterable)</strong>、<strong>迭代器(iterator)</strong>、<strong>生成器(generator)</strong>、<strong>列表/集合/字典推导式(list,set,dict comprehension)</strong>众多概念参杂在一起，难免让初学者一头雾水，我将用一篇文章试图将这些概念以及它们之间的关系捋清楚。</p></blockquote><figure><img src="/2019/05/09_Python基础系列之迭代/relationships.png" alt><figcaption>关系图</figcaption></figure><blockquote><p>请仔细看上图 请仔细看上图 请仔细看上图</p></blockquote><h4 id="容器container">1 容器（container）</h4><p>像列表（list）、集合（set）、序列（tuple）、字典（dict）都是容器。简单的说，容器是一种把多个元素组织在一起的数据结构， <code>【可以逐个迭代获取其中的元素。】</code><strong>但是，但是，但这并不是容器本身提供的能力</strong>，而是<code>可迭代对象赋予了容器这种能力</code>，当然并不是所有的容器都是可迭代的，比如：<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8" target="_blank" rel="noopener">Bloom filter</a>，虽然Bloom filter可以用来检测某个元素是否包含在容器中，但是并不能从容器中获取其中的每一个值，因为Bloom filter压根就没把元素存储在容器中，而是通过一个散列函数映射成一个值保存在数组中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125; <span class="comment"># 输出 True</span></span><br><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125; <span class="comment"># 输出 True</span></span><br><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> set([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]) <span class="comment"># 输出 True</span></span><br></pre></td></tr></table></figure><h4 id="可迭代对象iterable">2 可迭代对象(iterable)</h4><blockquote><p>凡是可以返回一个迭代器的对象都可称之为可迭代对象</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = iter(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = iter(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(y)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(y)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(z)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(x)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(y)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">list_iterator</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>这里x是一个可迭代对象，<strong>可迭代对象和容器一样是一种通俗的叫法</strong>，并不是指某种具体的数据类型，<code>list是可迭代对象，dict是可迭代对象，set也是可迭代对象</code>。 y和z是两个独立的迭代器，迭代器内部持有一个状态，该状态用于记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素。 迭代器有一种具体的迭代器类型，比如list_iterator，set_iterator。 **可迭代对象实现了__iter__方法，该方法返回一个迭代器对象。**</p><p><img src="/2019/05/09_Python基础系列之迭代/iterable-vs-iterator.png"></p><h4 id="迭代器iterator">3 迭代器(iterator)</h4><p>那么什么迭代器呢？它是一个带状态的对象，他能在你调用next()方法的时候返回容器中的下一个值，**任何实现了__iter__和__next__()（python2中实现next()）方法的对象都是迭代器**， __iter__返回迭代器自身， __next__返回容器中的下一个值， 如果容器中没有更多元素了，则抛出StopIteration异常，至于它们到底是如何实现的这并不重要。</p><p>所以，迭代器就是实现了工厂模式的对象，它在你每次你询问要下一个值的时候给你返回。有很多关于迭代器的例子，比如itertools函数返回的都是迭代器对象。</p><blockquote><p>迭代器就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = cycle([<span class="string">'red'</span>, <span class="string">'white'</span>, <span class="string">'blue'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(colors)</span><br><span class="line"><span class="string">'red'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(colors)</span><br><span class="line"><span class="string">'white'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(colors)</span><br><span class="line"><span class="string">'blue'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(colors)</span><br><span class="line"><span class="string">'red'</span></span><br></pre></td></tr></table></figure><h4 id="生成器generator">4 生成器(generator)</h4><p><strong>生成器算得上是Python语言中最吸引人的特性之一</strong>生成器其实是一种特殊的迭代器，不过这种迭代器更加优雅。 它不需要再像上面的类一样写__iter__()和__next__()方法了，<strong>只需要一个yiled关键字</strong>。 <strong>生成器一定是迭代器（反之不成立）</strong>，因此任何生成器也是以一种懒加载的模式生成值。用生成器来实现斐波那契数列的例子是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">    prev, curr = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> curr</span><br><span class="line">        prev, curr = curr, curr + prev</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = fib()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(islice(f, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>]</span><br></pre></td></tr></table></figure><p><strong>说实在的没看懂，后续章节补充这个。。。</strong></p><p><strong>总结：</strong></p><ol type="1"><li>容器是一系列元素的集合，str、list、set、dict、file、sockets对象都可以看作是容器 容器都可以被迭代（用在for，while等语句中），因此他们被称为可迭代对象。</li><li>可迭代对象实现了__iter__方法，该方法返回一个迭代器对象。</li><li>迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了__next__和__iter__方法，迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果。</li><li>生成器是一种特殊的迭代器，它的返回值不是通过return而是用yield。</li></ol><h3 id="第二部分-解析式">第二部分 解析式</h3><h4 id="什么是列表解析式">1 什么是列表解析式？</h4><p><strong>列表解析式是将一个列表（实际上适用于任何可迭代对象（iterable））转换成另一个列表的工具。</strong>在转换过程中，可以指定元素必须符合一定的条件，才能添加至新的列表中，这样每个元素都可以按需要进行转换。<a href="http://codingpy.com/article/python-list-comprehensions-explained-visually/" target="_blank" rel="noopener">参考</a></p><p><img src="/2019/05/09_Python基础系列之迭代/ex.png"></p><blockquote><p>如果看过图就明白了，就结束啦</p></blockquote><h4 id="show-code">2 Show Code</h4><p><strong>需求： 遍历数组，将满足条件的数据放入新的数组中</strong></p><p><em>单层嵌套</em> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般的写法</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">doubled_odds = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        doubled_odds.append(n)</span><br></pre></td></tr></table></figure></p><p>*<strong>解析式表达如下，分三部分</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doubled_odds = [</span><br><span class="line">    n,</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers</span><br><span class="line">    f n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>基本语法： <code>[ expr  for item in iterable  judge ]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. expr 待操作元素</span><br><span class="line">2. for item in iterable  循环语句【可嵌套，从后往前】</span><br><span class="line">3. judge 判断条件 【可选】</span><br></pre></td></tr></table></figure><p><em>双层嵌套</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tmpList = [ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]  ]</span><br><span class="line">newList =[</span><br><span class="line">    n</span><br><span class="line">    <span class="comment"># 先后再前</span></span><br><span class="line">    <span class="keyword">for</span> inNum <span class="keyword">in</span> inList  <span class="keyword">for</span> inList <span class="keyword">in</span> tmpList</span><br><span class="line">    <span class="comment"># 判断语句可选</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>参照list解析式，记住语法，其实也不难</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flipped = &#123;</span><br><span class="line">    value: key</span><br><span class="line">    for key, value in original.items()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
            <tag> Python </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 生成器 </tag>
            
            <tag> 解析式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之--字典/集合类型【5】</title>
      <link href="/2019/05/08_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/05/08_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="目标">目标</h2><ol type="1"><li>掌握字典的常用操作</li><li>掌握集合的常用操作</li></ol><figure><img src="/2019/05/08_Python基础系列之字典集合类型/type.png" alt><figcaption>整体</figcaption></figure><h3 id="第一部分-字典">第一部分 字典</h3><p>字典就是一个个的键值对 {key: value}，实现原理：根据key 计算 hash， 速度快。 <strong>注意事项</strong> 1. key: 任意不可变对象，但不能是list； 2. value: 可以是任意对象。</p><blockquote><p><strong>字典是有序的</strong></p></blockquote><blockquote><p><strong>思考：为何字典的key不可以是list类型？</strong></p></blockquote><h4 id="三种创建方式">1. 三种创建方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dic1 = &#123;<span class="string">"sex"</span>: <span class="number">1</span>&#125;</span><br><span class="line">dic2 = dict([(<span class="string">'name'</span>, <span class="string">'simuty'</span>), (<span class="string">"age"</span>, <span class="number">1</span>)])</span><br><span class="line">dic3 = dict(age=<span class="number">2</span>, name=<span class="string">'python'</span>, sex=<span class="number">1</span>)</span><br><span class="line">print(dic1)</span><br><span class="line">print(dic2)</span><br><span class="line">print(dic3)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'sex': 1&#125;</span></span><br><span class="line"><span class="string">&#123;'name': 'simuty'&#125;</span></span><br><span class="line"><span class="string">&#123;'age': 2&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h4 id="删除指定元素">2. 删除指定元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> dic3[<span class="string">'age'</span>]</span><br><span class="line">dic3.pop(<span class="string">'name'</span>)</span><br><span class="line">print(dic3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空字典</span></span><br><span class="line">dic3.clear()</span><br><span class="line">print(dic3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> dic3</span><br><span class="line">print(dic3)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'age': 2, 'name': 'python', 'sex': 1&#125;</span></span><br><span class="line"><span class="string">&#123;'sex': 1&#125;</span></span><br><span class="line"><span class="string">&#123;&#125;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "dic.py", line 28, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    print(dic3)</span></span><br><span class="line"><span class="string">NameError: name 'dic3' is not defined</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h4 id="合并">3. 合并</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 合并</span></span><br><span class="line">a_dic = &#123;<span class="string">"k"</span>: <span class="number">1</span>&#125;</span><br><span class="line">b_dic = &#123;<span class="string">'k'</span>: <span class="number">2</span>, <span class="string">"x"</span>: <span class="number">3</span>&#125;</span><br><span class="line">a_dic.update(b_dic)</span><br><span class="line">print(a_dic)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除最后一个并返回</span></span><br><span class="line">print(b_dic.popitem())</span><br><span class="line">print(b_dic)</span><br><span class="line"></span><br><span class="line">dic = &#123;<span class="string">'k'</span>: <span class="number">2</span>, <span class="string">"x"</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 接遍历字典获取键，根据键取值</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dic:</span><br><span class="line">    print(key, dic[key])</span><br></pre></td></tr></table></figure><figure><img src="/2019/05/08_Python基础系列之字典集合类型/Dictionary.png" alt><figcaption>字典</figcaption></figure><h3 id="第二部分-集合">第二部分 集合</h3><p><strong>set集合是一个无序不重复元素的集，基本功能包括关系测试和消除重复元素。</strong> &gt; 集合使用大括号({})框定元素，并以逗号进行分隔。 创建一个空集合，必须用 set() 而不是 {} ，因为后者创建的是一个空字典。</p><h4 id="集合操作">1. 集合操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">print(set1 ^ set2)</span><br><span class="line">print(set1 - set2)</span><br><span class="line">print(set2 - set1)</span><br><span class="line">print(set1 &amp; set2)</span><br><span class="line">print(set1 | set2)</span><br><span class="line"></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">print(a)</span><br><span class="line">b = a.add(<span class="number">5</span>)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><figure><img src="/2019/05/08_Python基础系列之字典集合类型/handleSet.png" alt><figcaption>实例</figcaption></figure><figure><img src="/2019/05/08_Python基础系列之字典集合类型/Set.png" alt><figcaption>set</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
            <tag> Python </tag>
            
            <tag> Dictionary </tag>
            
            <tag> Set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之--序列类型【4】</title>
      <link href="/2019/05/06_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8BList%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/05/06_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8BList%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="目标">目标</h2><ol type="1"><li>对<strong>序列对象</strong>有整体的认识；</li><li>掌握list的常用操作</li><li>掌握tuple的常用操作</li><li>理解深浅拷贝问题</li></ol><h3 id="第一部分-序列对象">第一部分 序列对象</h3><h4 id="了解序列对象">1. 了解序列对象</h4><p>Python一切皆对象。 1. 序列对象包含<strong>str、list、tuple</strong>； 2. 序列成员属性：<strong>有序，可通过下标访问</strong></p><blockquote><p>先大致预览下列表(list)、元组(tuple)的异同点,后续详细梳理</p></blockquote><table><thead><tr class="header"><th>差异点</th><th>列表</th><th>元组</th></tr></thead><tbody><tr class="odd"><td>表示方法</td><td>空列表：[] <br>单元素列表：[1]<br>多元素列表[1, 'a']</td><td>空元组：()<br>单元素元组：(1,)<br>多元素元组：(1, 'a')</td></tr><tr class="even"><td>可变性</td><td>可变</td><td>不可变</td></tr><tr class="odd"><td>可操作性</td><td>支持丰富的操作</td><td>仅支持序列操作</td></tr><tr class="even"><td>可哈希性</td><td>不可哈希，不能作为字典的关键字</td><td>可哈希，可以作为字典的关键字</td></tr></tbody></table><figure><img src="/2019/05/06_Python基础系列之List类型/Python数据类型.png" alt><figcaption>整体图</figcaption></figure><h3 id="第二部分-list">第二部分 List</h3><blockquote><p>Python的列表是一个<strong>有序可重复</strong>的元素集合，可嵌套、迭代、修改、分片、追加、删除，成员判断。 从数据结构角度看，Python的列表是一个可变长度的顺序存储结构，每一个位置存放的都是<strong>对象的指针</strong>。</p></blockquote><p>比如，对于这个列表 alist = [1, “a”, [11,22], {“k1”:”v1”}]，其在内存内的存储方式是这样的：</p><figure><img src="/2019/05/06_Python基础系列之List类型/mem.png" alt><figcaption>内存地址</figcaption></figure><h4 id="什么是list">1. 什么是list?</h4><p>概念： 逗号分隔的不同的数据项使用方括号括起来即是list; 性质： list元素可变,改变的是原对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tmpList = []  # 创建一个空列表</span><br><span class="line">&gt;&gt;&gt; numList = [1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; allList = [1, &apos;a&apos;, [11,22], &#123;&apos;k1&apos;:&apos;v1&apos;&#125;]</span><br></pre></td></tr></table></figure><h3 id="增删改">2. 增删改</h3><p><strong>以xmind的方式呈现</strong></p><p><img src="/2019/05/06_Python基础系列之List类型/List.png"></p><h3 id="第三部分-tuple">第三部分 Tuple</h3><blockquote><p>类似于list的对象， &gt; 类似于list, 相对不可更改</p></blockquote><p><strong>重要的实例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">alist = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"># stop_index 逻辑上要大于 start_index</span><br><span class="line"># 正整数stop_index&gt;start_index</span><br><span class="line"># 负数：stop_index&lt;start_index &amp; step&lt;0</span><br><span class="line"></span><br><span class="line">print(alist[1:8:3])</span><br><span class="line"># 全部，正向取值</span><br><span class="line">print(alist[:])</span><br><span class="line"># 全部，反向取值</span><br><span class="line">print(alist[-1:-11:-1])</span><br><span class="line"># stop_index &gt; len(list), 不报错</span><br><span class="line">print(alist[-1:-12:-1])</span><br></pre></td></tr></table></figure><blockquote><p><strong>类似于list, 相对不可更改</strong></p></blockquote><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017092876846880" target="_blank" rel="noopener">参考：廖雪峰老师博客--使用list和tuple</a>的最后来看一个“可变的”tuple：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;])</span><br><span class="line">&gt;&gt;&gt; t[2][0] = &apos;X&apos;</span><br><span class="line">&gt;&gt;&gt; t[2][1] = &apos;Y&apos;</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;])</span><br></pre></td></tr></table></figure><p>这个tuple定义的时候有3个元素，分别是'a'，'b'和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？</p><p>别急，我们先看看定义的时候tuple包含的3个元素：</p><figure><img src="/2019/05/06_Python基础系列之List类型/0.png" alt><figcaption>初始化</figcaption></figure><p>当我们把list的元素'A'和'B'修改为'X'和'Y'后，tuple变为：</p><figure><img src="/2019/05/06_Python基础系列之List类型/1.png" alt><figcaption>改变</figcaption></figure><p>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，<strong>而是list的元素</strong>。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p><blockquote><p>绝对不变的元组：必须保证tuple的每一个元素本身也不能变。</p></blockquote><p><img src="/2019/05/06_Python基础系列之List类型/tuple.png"></p><h3 id="第三部分-深浅拷贝">第三部分 深浅拷贝</h3><p>对列表和元组进行拷贝时，默认进行的是 <strong>浅拷贝</strong>：<em>只拷贝成员对象的引用</em>，而不会拷贝引用指向的成员对象本身。借助于 <a href="http://docs.python.org/2/library/copy.html" target="_blank" rel="noopener">copy模块</a> 的deepcopy方法，可以实现深拷贝</p><blockquote><p>深拷贝：既拷贝成员对象的引用，又会拷贝引用指向的成员对象本身。 浅拷贝：只拷贝成员对象的引用，而不会拷贝引用指向的成员对象本身</p></blockquote><p>值得注意的是，上述说法并<strong>不完全正确</strong>：<strong>如果成员对象本身是原子类型的（数值、字符串，或者只包含数值或字符串的元组），那么对该成员不会发生真正的深拷贝，即便执行深拷贝动作，内部也只会进行浅拷贝。</strong></p><blockquote><p>浅拷贝和深拷贝的示意图如下：</p></blockquote><p><img src="/2019/05/06_Python基础系列之List类型/copy.png"></p><p>关于浅拷贝和深拷贝的实际案例，可以参考 <a href="http://book.douban.com/subject/3112503/" target="_blank" rel="noopener">《Python核心编程（第二版）》</a> 中的 『6.20』 一节：『*拷贝Python对象、浅拷贝和深拷贝』。</p><p>参考链接</p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017092876846880" target="_blank" rel="noopener">使用list和tuple</a></p><p><a href="http://www.liujiangblog.com/course/python/19" target="_blank" rel="noopener">列表</a></p><p><a href="https://www.cnblogs.com/russellluo/p/3297041.html" target="_blank" rel="noopener">Python基础：序列（列表、元组）</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
            <tag> Python </tag>
            
            <tag> List </tag>
            
            <tag> Tuple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之--字符串类型【3】</title>
      <link href="/2019/05/05_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/05/05_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>字符串是编程必然面临的类型，常用指数之高，不得不先了解下Python中字符串的概念与常用方法</p></blockquote><p><img src="/2019/05/05_Python基础系列之字符串类型/string.png"></p><h3 id="第一部分-基础">第一部分 基础</h3><h4 id="不可变类型">1. 不可变类型</h4><p>作为不可变类型，主要涉及两个概念<strong>赋值、引用</strong>，先看三种定义字符串的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 第一种</span><br><span class="line">var1 = &apos;Hello world&apos;</span><br><span class="line">// 第二种</span><br><span class="line">var1 = &quot;Pyhoth&quot;</span><br><span class="line">// 第三种</span><br><span class="line">var2 = &quot;&quot;&quot;  </span><br><span class="line">&gt;&gt;&gt; a = &quot;asd&quot;</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4431000496</span><br><span class="line">&gt;&gt;&gt; a = &quot;122&quot;</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4431000552</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>上边的代码涉及个问题: &gt; 1.1 为何说是不可变类型，怎么var1还可以<strong>等于</strong>Python？</p><p><img src="/2019/05/05_Python基础系列之字符串类型/1.jpg"></p><p>Python 没有赋值，只有引用。可以从代码中第三种可以看出，同样的字符串<code>a</code>, 内存地址是不一样的。原因在于，第二次的<code>所谓赋值</code>，其实<strong>是重新创建一块内存，然后将a指向新内存地址</strong></p><h3 id="第二部分-内建函数">第二部分 内建函数</h3><h4 id="填充">1 填充</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var3 = &quot;1234&quot;</span><br><span class="line"># 填充字符串</span><br><span class="line">print(var3.center(10, &quot;*&quot;))</span><br><span class="line">print(var3.ljust(10, &apos;^&apos;))</span><br><span class="line">print(var3.rjust(10, &quot;^&quot;))</span><br><span class="line">print(var3.zfill(10))</span><br><span class="line"></span><br><span class="line"># 返回值</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">***1234***</span><br><span class="line">1234^^^^^^</span><br><span class="line">^^^^^^1234</span><br><span class="line">0000001234</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure><h4 id="删减">2 删减</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var4 = &quot;55785&quot;</span><br><span class="line">print(var4.strip(&quot;5&quot;))</span><br><span class="line">print(var4.lstrip(&quot;5&quot;))</span><br><span class="line">print(var4.rstrip(&quot;5&quot;))</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><p>''' 78 785 5578 '''</p><h4 id="变形">3 变形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var5 = &quot;thank yoU&quot;</span><br><span class="line">print(var5.lower())</span><br><span class="line">print(var5.upper())</span><br><span class="line">print(var5.capitalize())</span><br><span class="line">print(var5.swapcase())</span><br><span class="line">print(var5.title())</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">thank you</span><br><span class="line">THANK YOU</span><br><span class="line">Thank you</span><br><span class="line">THANK YOu</span><br><span class="line">Thank You</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure><h4 id="切分">4 切分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var6 = &quot;7890&quot;</span><br><span class="line"># 有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string.</span><br><span class="line">print(var6.partition(&apos;9&apos;))</span><br><span class="line">print(var6.partition(&apos;2&apos;))</span><br><span class="line">print(var6.rpartition(&quot;0&quot;))</span><br><span class="line">var7 = &quot;abz\nzxy&quot;</span><br><span class="line">print(var7.splitlines())</span><br><span class="line">print(var7.split(&quot;z&quot;))</span><br><span class="line">print(var7.rsplit(&quot;z&quot;))</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(&apos;78&apos;, &apos;9&apos;, &apos;0&apos;)</span><br><span class="line">(&apos;7890&apos;, &apos;&apos;, &apos;&apos;)</span><br><span class="line">(&apos;789&apos;, &apos;0&apos;, &apos;&apos;)</span><br><span class="line">[&apos;abz&apos;, &apos;zxy&apos;]</span><br><span class="line">[&apos;ab&apos;, &apos;\n&apos;, &apos;xy&apos;]</span><br><span class="line">[&apos;ab&apos;, &apos;\n&apos;, &apos;xy&apos;]</span><br></pre></td></tr></table></figure><h4 id="连接">5 连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var8 = &quot;ikaf&quot;</span><br><span class="line">print(var8.join(&quot;0000&quot;))</span><br><span class="line"></span><br><span class="line"># 判定</span><br><span class="line">var9 = &quot;kj45&quot;</span><br><span class="line"># 长度&gt;0 &amp;&amp; 都是字母或都是数字 true 否则false</span><br><span class="line">print(var9.isalnum())</span><br><span class="line"># 长度&gt;0 &amp;&amp;  都是字母 true 否则false</span><br><span class="line">print(var9.isalpha())</span><br><span class="line">print(var9.isdigit())</span><br><span class="line">print(var9.islower())</span><br><span class="line">print(var9.isupper())</span><br><span class="line">print(var9.isspace())</span><br><span class="line">print(var9.istitle())</span><br><span class="line">print(var9.startswith(&apos;k&apos;))</span><br><span class="line">print(var9.endswith(&apos;5&apos;))</span><br></pre></td></tr></table></figure><h4 id="查找">6 查找</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var10 = &quot;1234567890zxc123vbndfgh&quot;</span><br><span class="line">print(var10.count(&apos;123&apos;, 0, len(var10)))</span><br><span class="line"># 返回第一个满足条件的位置</span><br><span class="line">print(var10.find(&apos;3&apos;, 0, len(var10)))</span><br><span class="line">#</span><br><span class="line">print(var10.index(&apos;3&apos;, 0, len(var10)))</span><br><span class="line"># 找不到返回-1</span><br><span class="line">print(var10.rfind(&apos;mm&apos;, 0, len(var10)))</span><br><span class="line"># 找不到报错</span><br><span class="line"># print(var10.rindex(&apos;mm&apos;, 0, len(var10)))</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h4 id="替换">7 替换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var11 = &quot;aaaa111222hhhjjjkkk&quot;</span><br><span class="line">print(var11.replace(&quot;a&quot;, &quot;b&quot;, 2))</span><br><span class="line"># print(var11.translate())</span><br><span class="line">#  translate(table[,deletechars])</span><br></pre></td></tr></table></figure><h4 id="编码解码">8 编码解码</h4><blockquote><p>编码就是将字符串转换成字节码，涉及到字符串的内部表示。 解码就是将字节码转换为字符串，将比特位显示成字符。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var12 = &quot;什么鬼&quot;</span><br><span class="line">print(var12.encode())</span><br><span class="line">print(var12.encode().decode())</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">b&apos;\xe4\xbb\x80\xe4\xb9\x88\xe9\xac\xbc&apos;</span><br><span class="line">什么鬼</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
            <tag> Python </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之--数字类型【2】</title>
      <link href="/2019/05/04_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/05/04_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>总览 Python 数据类型</p></blockquote><p>目标</p><ul><li><ol type="1"><li>了解Python有几种数据类型</li></ol></li><li><ol start="2" type="1"><li>认识Python的数字类型</li></ol></li><li><ol start="3" type="1"><li>重点掌握对数字类型的操作</li></ol></li></ul><figure><img src="/2019/05/04_Python基础系列之数字类型/type.png" alt><figcaption>Python数据类型</figcaption></figure><h2 id="第一部分-数字类型">第一部分 数字类型</h2><p><strong>数字类型用于存储数学意义上的数值。</strong></p><p>Python 支持三种不同的数字类型，<strong>整数、浮点数和复数</strong>：</p><h3 id="整数">1. 整数</h3><p>定义：正或负整数，不带小数点的数</p><p><strong>Python 的整数长度为 32 位，并且通常是连续分配内存空间的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; id(0)</span><br><span class="line">4361838576</span><br><span class="line">&gt;&gt;&gt; id(1)</span><br><span class="line">4361838608</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="小整数对象池">小整数对象池</h4><p>Python 初始化的时候会自动建立一个<strong>小整数对象池</strong>，方便我们调用，避免后期重复生成！这是一个包含<strong>262 个指向整数对象的指针数组，范围是-5 到 256</strong>。</p><blockquote><p>也就是说比如整数 10，即使我们在程序里没有创建它，其实在 Python 后台已经悄悄为我们创建了。</p></blockquote><p>看下边的 id(-6)与 id(257)的地址，<strong>4364640112</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; id(-6)</span><br><span class="line">4364640112</span><br><span class="line">&gt;&gt;&gt; id(-5)</span><br><span class="line">4361838416</span><br><span class="line">&gt;&gt;&gt; id(255)</span><br><span class="line">4361846736</span><br><span class="line">&gt;&gt;&gt; id(256)</span><br><span class="line">4361846768</span><br><span class="line">&gt;&gt;&gt; id(257)</span><br><span class="line">4364640112</span><br></pre></td></tr></table></figure><h5 id="为什么存在小整数对象池">为什么存在小整数对象池？</h5><blockquote><p>像懒加载一样，创建一个一直存在，永不销毁，随用随拿的小整数对象池，减小开支。</p></blockquote><h4 id="整数缓冲区">整数缓冲区</h4><p>刚被删除的整数，不会被真正立刻删除回收，而是在后台缓冲一段时间，等待下一次的可能调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 100</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4401859696</span><br><span class="line">&gt;&gt;&gt; del a</span><br><span class="line">&gt;&gt;&gt; b = 100</span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">4401859696</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>把 a 删了，然后创建一个 b,地址是一样的。</p><h3 id="浮点数">2. 浮点数</h3><p>浮点数也就是小数 对于很大或很小的浮点数，一般用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p><h3 id="复数">3. 复数</h3><p><strong>复数由实数部分和虚数部分构成</strong>，可以用a + bj,或者complex(a,b)表示，复数的实部a和虚部b都是浮点型。关于复数，不做科学计算或其它特殊需要，通常很难遇到。</p><h2 id="第二部分-操作数字类型">第二部分 操作数字类型</h2><figure><img src="/2019/05/04_Python基础系列之数字类型/number.png" alt><figcaption>数字类型操作</figcaption></figure><h3 id="简单常用的计算">1. 简单常用的计算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line"># print(dir(math))</span><br><span class="line"># print(abs(-10))</span><br><span class="line"># print(cmp(1, 3))</span><br><span class="line"># print(math.exp(2))</span><br><span class="line"># print(math.ceil(1.2), math.ceil(-1.2))</span><br><span class="line"># print(math.floor(1.2))</span><br><span class="line"># print(max([12, 1]))</span><br></pre></td></tr></table></figure><h3 id="随机操作">2. 随机操作</h3><p>主要还没涉及更复杂的计算，只是罗列一些可能常用的方法； 真值分部相关的操作，如正态分部啥的，因为暂无需求，</p><blockquote><p>我希望: 有朝一日能用的上那些高大上的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">print(&quot;---基本---&quot;)</span><br><span class="line"># 基本</span><br><span class="line"># 返回当前生成器的内部状态</span><br><span class="line">print(random.getstate())</span><br><span class="line"># 不大于K位的Python整数,结果是0~2^10之间的整数</span><br><span class="line">print(random.getrandbits(10))</span><br><span class="line"></span><br><span class="line">print(&quot;---整数---&quot;)</span><br><span class="line"># 整数</span><br><span class="line"># 0-9的整数：</span><br><span class="line">print(random.randrange(10))</span><br><span class="line"># 0-100的偶数</span><br><span class="line">print(random.randrange(0, 101, 2))</span><br><span class="line"># 返回 a &lt;= N &lt;= b， 等同于randrange(a, b+1)。</span><br><span class="line">print(random.randint(1, 9))</span><br><span class="line"></span><br><span class="line">print(&quot;---list---&quot;)</span><br><span class="line"># list</span><br><span class="line"># 从序列随机选择一个元素</span><br><span class="line">print(random.choice([&apos;python&apos;, &apos;node&apos;, &apos;种地&apos;]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;---真值分布---&quot;)</span><br><span class="line"># 随机浮点数:  0.0 &lt;= x &lt; 1.0</span><br><span class="line">print(random.random())</span><br><span class="line"># 随机浮点数:  1.1 &lt;= x &lt; 11.1</span><br><span class="line">print(random.uniform(1.1, 11.1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 对序列进行洗牌，改变原序列</span><br><span class="line">deck = &apos;one two three four&apos;.split()</span><br><span class="line">random.shuffle(deck)</span><br><span class="line">print(deck)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
            <tag> Number </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs 基础系列之--基本概念</title>
      <link href="/2019/05/03_NodeJs%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B--%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/05/03_NodeJs%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B--%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>还记得之前说，NodeJs 拥有丰富的第三方模块吗？</p><blockquote><p>如何利用现有的模块，快速、高效的实现需求呢？</p></blockquote></blockquote><h2 id="第一部分-模块管理工具">第一部分 模块管理工具</h2><p><strong>几个关键字</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. nvm：主要管理nodejs版本；</span><br><span class="line">2. npm：nodejs自带模块管理工具；</span><br></pre></td></tr></table></figure><h3 id="npm-是什么">1. NPM 是什么?</h3><blockquote><p>npm 之于 Node.js ，就像 pip 之于 Python， gem 之于 Ruby， pear 之于 PHP 。</p></blockquote><p><a href="https://www.npmjs.com.cn/getting-started/what-is-npm/" target="_blank" rel="noopener">NPM 官网</a>给出解释如下:</p><ol type="1"><li>npm 为你和你的团队打开了连接整个 JavaScript 天才世界的一扇大门。</li><li>它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。</li></ol><p><strong>npm 由三个独立的部分组成：</strong></p><ol type="1"><li>网站：开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径；</li><li>注册表（registry）：巨大的数据库，保存了每个包（package）的信息；</li><li>命令行工具 (CLI)： 开发者通过 CLI 与 npm 打交道。</li></ol><p>总之一句话，<strong>想简单高效的完成任务么？NPM 你值得拥有</strong></p><blockquote><p>接下来主要介绍使用</p><blockquote><p>至于自我创建模块，暂不讨论</p></blockquote></blockquote><h3 id="安装配置">2. 安装配置</h3><p>NodeJs 自带 npm, 故无需安装。 罗列几个常用的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 查看 npm 命令列表</span><br><span class="line">$ npm help</span><br><span class="line"></span><br><span class="line"># 查看各个命令的简单用法</span><br><span class="line">$ npm -l</span><br><span class="line"></span><br><span class="line"># 查看 npm 的版本</span><br><span class="line">$ npm -v</span><br><span class="line"></span><br><span class="line"># 查看 npm 的配置</span><br><span class="line">$ npm config list -l</span><br><span class="line"></span><br><span class="line">$ npm list</span><br><span class="line"></span><br><span class="line"># 加上 global 参数，会列出全局安装的模块</span><br><span class="line">$ npm list -global</span><br><span class="line"></span><br><span class="line"># 搜索模块</span><br><span class="line">$ npm search &lt;关键字&gt;</span><br><span class="line"></span><br><span class="line"># 本地安装</span><br><span class="line">$ npm install &lt;package name&gt;</span><br><span class="line"></span><br><span class="line"># 全局安装</span><br><span class="line">$ sudo npm install -global &lt;package name&gt;</span><br><span class="line">$ sudo npm install -g &lt;package name&gt;</span><br></pre></td></tr></table></figure><h5 id="实例一-眼见为实">实例一 眼见为实</h5><p>下载一个常用的框架---ExpressJs，借此展示一下效果，并熟悉一个 ExpressJs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir first</span><br><span class="line">$ cd first</span><br><span class="line">$ npm install express</span><br><span class="line">$ node app.js</span><br><span class="line">Example app listening on port 3000!</span><br></pre></td></tr></table></figure><figure><img src="/2019/05/03_NodeJs基础系列之--基本概念/2.jpg" alt><figcaption>效果如图</figcaption></figure><h5 id="实例二-初识-package.json-文件">实例二 初识 package.json 文件</h5><p>简单说就是，记录文件，记录项目依赖的模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 初始化一个package.json文件</span><br><span class="line">$ npm init</span><br></pre></td></tr></table></figure><p>实例说明 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 名称</span><br><span class="line">  &quot;name&quot;: &quot;npm&quot;,</span><br><span class="line">  // 版本</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  // 描述</span><br><span class="line">  &quot;description&quot;: &quot;study npm&quot;,</span><br><span class="line">  // 入口文件</span><br><span class="line">  &quot;main&quot;: &quot;app.js&quot;,</span><br><span class="line">  // 模块依赖</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;express&quot;: &quot;^4.16.4&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;&#125;,</span><br><span class="line">  // 执行脚本</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 关键词</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;npm&quot;</span><br><span class="line">  ],</span><br><span class="line">  // 作者</span><br><span class="line">  &quot;author&quot;: &quot;howard&quot;,</span><br><span class="line">  // 协议</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如我们需要下载ExpressJs,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 一下命令即可将Express依赖加入到上边的文件中，偷个懒，不在重负写了</span><br><span class="line">$ npm install express --save</span><br></pre></td></tr></table></figure><p>实例三 更改npm源</p><p>可能你发现下载东西简直如龟速，这个你得感谢<a href="https://baike.baidu.com/item/%E6%96%B9%E6%BB%A8%E5%85%B4/9525950?fr=aladdin" target="_blank" rel="noopener">防火墙之父</a></p><p>为了更快更好的完成工作，我们可以用国内的<a href="https://npm.taobao.org/" target="_blank" rel="noopener">淘宝</a>、清华等源；</p><p><strong>淘宝镜像说明：这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><blockquote><p>使用方法类似，用cnpm即可</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install [name]</span><br></pre></td></tr></table></figure><h3 id="第二部分">第二部分</h3><blockquote><p>Node.js 最大的特点就是异步式 I/O(或者非阻塞I/O)与事件紧密结合的编程模式。</p></blockquote><h4 id="阻塞io与非阻塞io概念">1.阻塞I/O与非阻塞I/O概念</h4><h5 id="阻塞io同步io">1.1 阻塞I/O(同步I/O)</h5><p>线程在执行中如果遇到磁盘读写或网络通信(<strong>统称为I/O 操作</strong>)， 通常要耗费较长的时间，这时操作系统会剥夺这个线程的 CPU 控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为<strong>阻塞</strong>,当<strong>I/O 操作</strong>完成时，操作系统将这个线程的阻塞解除，恢复其对CPU的控制 ，令其继续运行。这种 I/O 模式就是通常的<strong>同步式 I/O(Synchronous I/O)或阻塞式 I/O (Blocking I/O)。</strong></p><h5 id="非阻塞io异步io">1.2 非阻塞I/O(异步I/O)</h5><p>非阻塞I/O是针对所有的I/O<strong>不采用阻塞的策略</strong>, 当线程遇到I/O 操作时, <strong>不会阻塞等待完成</strong>, 而是将I/O 操作发送给操作系统, <strong>继续执行下一个语句</strong>, 等操作系统完成I/O 操作以后, 会以<strong>事件的形式</strong>发送通知执行I/O 操作的线程, 线程会在特定的时候处理这个事件; 也就是线程中会不停的监听时间循环, 看是否有未处理的事件, 并以此处理.</p><blockquote><p>举个通俗的例子： <a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="noopener">例子来自知乎网友</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你打电话问书店老板有没有《分布式系统》这本书，如果是`同步通信机制`，书店老板会说，你稍等，”我查一下&quot;，</span><br><span class="line">然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。</span><br><span class="line"></span><br><span class="line">而`异步通信机制`，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。</span><br><span class="line">然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</span><br></pre></td></tr></table></figure><h5 id="阻塞io与非阻塞io特点">2.阻塞I/O与非阻塞I/O特点</h5><table><thead><tr class="header"><th>同步I/O(阻塞式)</th><th>异步I/O(非阻塞式)</th></tr></thead><tbody><tr class="odd"><td>利用多线程提供吞吐量</td><td>单线程可实现高吞吐量</td></tr><tr class="even"><td>通过事件分割和线程调度利用多核CPU</td><td>通过功能划分利用多核CPU</td></tr><tr class="odd"><td>需要由操作系统调度多线程使用多核CPU</td><td>可以将单进程绑定到单核 CPU</td></tr><tr class="even"><td>难以充分利用 CPU 资源</td><td>可以充分利用 CPU 资源</td></tr><tr class="odd"><td>符合线性的编程思维</td><td>不符合传统编程思维</td></tr></tbody></table><figure><img src="/2019/05/03_NodeJs基础系列之--基本概念/3.jpg" alt><figcaption>对比</figcaption></figure><h4 id="第二部分-异步式编程函数式编程">第二部分 异步式编程(函数式编程)</h4><p>有异步I/O，就必然有异步编程。<br>首先以同步式编程的语法读取一个文件:</p><p><em>创建readfilesync.js, 并执行</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var data = fs.readFileSync(&apos;/Users/51testing/Desktop/file.txt&apos;, &apos;utf-8&apos;); </span><br><span class="line">console.log(data);</span><br><span class="line">console.log(&apos;end.&apos;);</span><br></pre></td></tr></table></figure><p>打印的结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//执行</span><br><span class="line">$ node /Users/51testing/Desktop/readfilesync.js </span><br><span class="line">你好呀</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><p>以上代码很容易理解, 自上而下的执行, 那么异步编程的做法呢?</p><p><em>创建readfileasync.js, 并执行</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">fs.readFile(&apos;/Users/51testing/Desktop/file.txt&apos;, &apos;utf-8&apos;, function(err, data) &#123;</span><br><span class="line">if (err)&#123; </span><br><span class="line">    console.error(err);</span><br><span class="line">&#125; else &#123; </span><br><span class="line">    console.log(data);</span><br><span class="line">&#125; </span><br><span class="line">&#125;);</span><br><span class="line">    console.log(&apos;end.&apos;);</span><br></pre></td></tr></table></figure><p>打印的结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//执行</span><br><span class="line">$ node /Users/51testing/Desktop/readfileasync.js </span><br><span class="line">end.</span><br><span class="line">你好呀</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>fs.readFile 调用时所做的工作只是<code>将异步式 I/O 请求发给了操作系统</code>， 然后<code>立即返回</code>并执行后面的语句，执行完以后进入事件循环监听事件。 fs 接到I/O 请求完成的事件时，<code>事件循环会主动调用</code>回调函数以完成后续工作。<code>因此我们会先看到 end.然后看到 file.txt 文件的内容。</code></p><h4 id="nodejs循环机制">2 NodeJs循环机制</h4><figure><img src="/2019/05/03_NodeJs基础系列之--基本概念/4.jpg" alt><figcaption>循环</figcaption></figure><blockquote><p>Node.js 在什么时候会进入事件循环呢?</p></blockquote><p><strong>生命周期为:</strong><code>Node.js 程序由事件循环环开始，到事件循环结束</code>.</p><p>所有的逻辑都是事件的回调函数，所以 Node.js 始终在事件循环中，程序入口就是 事件循环第一个事件的回调函数。事件的回调函数在执行的过程中，可能会发出 I/O 请求或直接发射 (emit)事件，执行完成后再返回事件 循环，事件循环会会检查循环中有没有 处理的事件,直到到程序结束。</p><h4 id="小技巧">小技巧</h4><p>Node 版本区别:</p><p>从对 ES6 的支持来简单的区分是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.x 完全不支持ES6</span><br><span class="line">4.x 部分支持ES6特性，并处在LTS阶段</span><br><span class="line">5.x 部分支持ES6特性（比4.x多些），属于过渡产品，现在来说应该没有什么理由去用这个了</span><br><span class="line">6.x 支持98%的ES6特性</span><br></pre></td></tr></table></figure><p><strong>参考链接</strong></p><p><a href="https://www.byvoid.com/zhs/project/node" target="_blank" rel="noopener">Node.js开发指南</a> <a href="http://www.infoq.com/cn/master-nodejs" target="_blank" rel="noopener">深入浅出Node.js</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础系列之--初识【1】</title>
      <link href="/2019/05/02_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B--%E5%88%9D%E8%AF%86/"/>
      <url>/2019/05/02_Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B--%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="认识-python">认识 Python</h1><blockquote><p>人生苦短，我用 Python —— Life is short, you need Python</p></blockquote><figure><img src="/2019/05/02_Python基础系列之--初识/1.jpg" alt><figcaption>img</figcaption></figure><h2 id="目标">目标</h2><ul><li>Python 的起源</li><li>为什么要用 Python？</li><li>Python 的特点</li><li>Python 的优缺点</li><li><code>Python 2.x</code> 与 <code>3​​.x</code> 版本简介</li><li>执行 <code>Python</code> 程序的三种方式<ul><li>解释器 —— <code>python</code> / <code>python3</code></li><li>交互式 —— <code>ipython</code></li><li>我选择免费易扩展的VSCode,因为还得写别的语言，仅此而已</li></ul></li></ul><h2 id="python-的起源">01. Python 的起源</h2><blockquote><p>Python 的创始人为吉多·范罗苏姆（Guido van Rossum） &gt; Python之父是荷兰人Guido van Rossum，被誉为历史上<a href="https://www.douban.com/group/topic/74259468/" target="_blank" rel="noopener">最伟大的12名程序员</a>之一。</p></blockquote><figure><img src="/2019/05/02_Python基础系列之--初识/2.jpg" alt><figcaption>e747899073c9b4416c91c2bb326f1549.jpeg</figcaption></figure><ol type="1"><li>1989 年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的<strong>解释程序</strong>，作为 ABC 语言的一种继承（<strong>感觉下什么叫牛人</strong>）</li><li>ABC 是由吉多参加设计的一种教学语言，就吉多本人看来，ABC 这种语言非常优美和强大，是<strong>专门为非专业程序员设计的</strong>。但是 ABC 语言并没有成功，究其原因，吉多认为是<strong>非开放</strong>造成的。吉多决心在 Python 中避免这一错误，并获取了非常好的效果</li><li>之所以选中 Python（蟒蛇） 作为程序的名字，是因为他是 BBC 电视剧——蒙提·派森的飞行马戏团（Monty Python's Flying Circus）的爱好者</li><li>1991 年，第一个 Python <strong>解释器</strong> 诞生，它是用 C 语言实现的，并能够调用 C 语言的库文件</li></ol><h3 id="解释器科普">1.1 解释器（科普）</h3><p><strong>计算机不能直接理解任何除机器语言以外的语言</strong>，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。<strong>将其他语言翻译成机器语言的工具，被称为编译器</strong></p><p>编译器翻译的方式有两种：一个是<strong>编译</strong>，另外一个是<strong>解释</strong>。两种方式之间的区别在于<strong>翻译时间点的不同</strong>。当编译器<strong>以解释方式运行的时候</strong>，也称之为<strong>解释器</strong></p><figure><img src="/2019/05/02_Python基础系列之--初识/3.png" alt><figcaption>12ae91928d3e790ef0b8cdf9ec299685.png</figcaption></figure><ul><li><strong>编译型语言</strong>：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++</li><li><strong>解释型语言</strong>：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行</li></ul><figure><img src="/2019/05/02_Python基础系列之--初识/4.jpg" alt><figcaption>e56f0d1450ca0c514ba954ef640b4b4c.png</figcaption></figure><h4 id="编译型语言和解释型语言对比">编译型语言和解释型语言对比</h4><ul><li><strong>速度</strong> —— 编译型语言比解释型语言执行速度快</li><li><strong>跨平台性</strong> —— 解释型语言比编译型语言跨平台性好</li></ul><h3 id="python-的设计目标">1.2 Python 的设计目标</h3><p>1999 年，吉多·范罗苏姆向 DARPA 提交了一条名为 “Computer Programming for Everybody” 的资金申请，并在后来说明了他对 Python 的目标：</p><ul><li>一门<strong>简单直观的语言</strong>并与主要竞争者一样强大</li><li><strong>开源</strong>，以便任何人都可以为它做贡献</li><li>代码<strong>像纯英语那样容易理解</strong></li><li>适用于<strong>短期</strong>开发的日常任务</li></ul><p>这些想法中的基本都已经成为现实，Python 已经成为一门流行的编程语言</p><h3 id="python-的设计哲学">1.3 Python 的设计哲学</h3><figure><img src="/2019/05/02_Python基础系列之--初识/5.jpg" alt><figcaption>7ff693d9b86899489ddfc38bfe444bdc.png</figcaption></figure><ol type="1"><li>优雅</li><li>明确</li><li>简单</li></ol><!-- > 在 Python 解释器内运行 `import this` 可以获得完整的列表 --><ul><li>Python 开发者的哲学是：<strong>用一种方法，最好是只有一种方法来做一件事</strong></li><li>如果面临多种选择，Python 开发者一般会拒绝花俏的语法，而选择<strong>明确没有或者很少有歧义的语法</strong></li></ul><blockquote><p>在 Python 社区，吉多被称为“仁慈的独裁者”</p></blockquote><h2 id="为什么选择-python">02. 为什么选择 Python？</h2><ul><li>代码量少</li><li>……</li></ul><blockquote><p>同一样问题，用不同的语言解决，代码量差距还是很多的，一般情况下 <code>Python</code> 是 <code>Java</code> 的 <strong>1/5</strong>，所以说 <strong>人生苦短，我用 Python</strong></p></blockquote><h2 id="python-特点">03. Python 特点</h2><ul><li>Python 是<strong>完全面向对象的语言</strong><ul><li><strong>函数</strong>、<strong>模块</strong>、<strong>数字</strong>、<strong>字符串</strong>都是对象，<strong>在 Python 中一切皆对象</strong></li><li>完全支持继承、重载、多重继承</li><li>支持重载运算符，也支持泛型设计</li></ul></li><li>Python <strong>拥有一个强大的标准库</strong>，Python 语言的核心只包含 <strong>数字</strong>、<strong>字符串</strong>、<strong>列表</strong>、<strong>字典</strong>、<strong>文件</strong> 等常见类型和函数，而由 Python 标准库提供了 <strong>系统管理</strong>、<strong>网络通信</strong>、<strong>文本处理</strong>、<strong>数据库接口</strong>、<strong>图形系统</strong>、<strong>XML 处理</strong> 等额外的功能</li><li>Python 社区提供了<strong>大量的第三方模块</strong>，使用方式与标准库类似。它们的功能覆盖 <strong>科学计算</strong>、<strong>人工智能</strong>、<strong>机器学习</strong>、<strong>Web 开发</strong>、<strong>数据库接口</strong>、<strong>图形系统</strong> 多个领域</li></ul><h3 id="面向对象的思维方式">面向对象的思维方式</h3><ul><li><strong>面向对象</strong> 是一种 <strong>思维方式</strong>，也是一门 <strong>程序设计技术</strong></li><li>要解决一个问题前，首先考虑 <strong>由谁</strong> 来做，怎么做事情是 <strong>谁</strong> 的职责，最后把事情做好就行！<ul><li><strong>对象</strong> 就是 <strong>谁</strong></li></ul></li><li>要解决复杂的问题，就可以找<strong>多个不同的对象</strong>，<strong>各司其职</strong>，共同实现，最终完成需求</li></ul><h2 id="python-的优缺点">04. Python 的优缺点</h2><h3 id="优点">4.1 优点</h3><ul><li>简单、易学</li><li>免费、开源</li><li><strong>面向对象</strong></li><li>丰富的库</li><li>可扩展性<ul><li>如果需要一段关键代码运行得更快或者希望某些算法不公开，可以把这部分程序用 <code>C</code> 或 <code>C++</code> 编写，然后在 <code>Python</code> 程序中使用它们</li></ul></li><li>……</li></ul><h3 id="缺点">4.2 缺点</h3><ul><li>运行速度</li><li>国内市场较小</li><li>中文资料匮乏</li></ul><h2 id="python-2.x-与-3.x-版本简介">01. <code>Python 2.x</code> 与 <code>3​​.x</code> 版本简介</h2><p>目前市场上有两个 Python 的版本并存着，分别是 <code>Python 2.x</code> 和 <code>Python 3.x</code></p><p><img src="/2019/05/02_Python基础系列之--初识/6.jpg"></p><blockquote><p>新的 Python 程序建议使用 <code>Python 3.0</code> 版本的语法</p></blockquote><ul><li>Python 2.x 是 <strong>过去的版本</strong><ul><li>解释器名称是 <strong>python</strong></li></ul></li><li>Python 3.x 是 <strong>现在和未来 主流的版本</strong><ul><li>解释器名称是 <strong>python3</strong></li><li>相对于 <code>Python</code> 的早期版本，这是一个 <strong>较大的升级</strong></li><li>为了不带入过多的累赘，<code>Python 3.0</code> 在设计的时候 <strong>没有考虑向下兼容</strong><ul><li>许多早期 <code>Python</code> 版本设计的程序都无法在 <code>Python 3.0</code> 上正常执行</li></ul></li><li>Python 3.0 发布于 <strong>2008 年</strong></li><li>到目前为止，Python 3.0 的稳定版本已经有很多年了<ul><li>Python 3.3 发布于 2012</li><li>Python 3.4 发布于 2014</li><li>Python 3.5 发布于 2015</li><li>Python 3.6 发布于 2016</li></ul></li></ul></li><li>为了照顾现有的程序，官方提供了一个过渡版本 —— <strong>Python 2.6</strong><ul><li>基本使用了 <code>Python 2.x</code> 的语法和库</li><li>同时考虑了向 <code>Python 3.0</code> 的迁移，<strong>允许使用部分</strong> <code>Python 3.0</code> 的语法与函数</li><li>2010 年中推出的 <code>Python 2.7</code> 被确定为 <strong>最后一个Python 2.x 版本</strong></li></ul></li></ul><blockquote><p>提示：如果开发时，无法立即使用 Python 3.0（还有极少的第三方库不支持 3.0 的语法），建议</p><ul><li>先使用 <code>Python 3.0</code> 版本进行开发</li><li>然后使用 <code>Python 2.6</code>、<code>Python 2.7</code> 来执行，并且做一些兼容性的处理</li></ul></blockquote><h2 id="执行-python-程序的三种方式">03. 执行 Python 程序的三种方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解释器 —— python / python3</span><br><span class="line">交互式 —— ipython</span><br><span class="line">集成开发环境 —— PyCharm / VsCode</span><br></pre></td></tr></table></figure><h3 id="解释器-python-python3">3.1. 解释器 <code>python</code> / <code>python3</code></h3><h4 id="python-的解释器">Python 的解释器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 python 2.x 解释器</span></span><br><span class="line">$ python xxx.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 python 3.x 解释器</span></span><br><span class="line">$ python3 xxx.py</span><br></pre></td></tr></table></figure><h5 id="其他解释器">其他解释器</h5><p><strong>Python 的解释器</strong> 如今有多个语言的实现，包括：</p><ul><li><code>CPython</code> —— 官方版本的 C 语言实现</li><li><code>Jython</code> —— 可以运行在 Java 平台</li><li><code>IronPython</code> —— 可以运行在 .NET 和 Mono 平台</li><li><code>PyPy</code> —— Python 实现的，支持 JIT 即时编译</li></ul><h3 id="交互式运行-python-程序">3.2. 交互式运行 Python 程序</h3><ul><li>直接在终端中运行解释器，而不输入要执行的文件名</li><li>在 Python 的 <code>Shell</code> 中直接输入 <strong>Python 的代码</strong>，会立即看到程序执行结果</li></ul><h4 id="交互式运行-python-的优缺点">1) 交互式运行 Python 的优缺点</h4><h5 id="优点-1">优点</h5><ul><li>适合于学习/验证 Python 语法或者局部代码</li></ul><h5 id="缺点-1">缺点</h5><ul><li>代码不能保存</li><li>不适合运行太大的程序</li></ul><h4 id="退出-官方的解释器">2) 退出 官方的解释器</h4><h5 id="直接输入-exit">1&gt; 直接输入 <code>exit()</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>exit()</span><br></pre></td></tr></table></figure><h5 id="使用热键退出">2&gt; 使用热键退出</h5><p>在 python 解释器中，按热键 <code>ctrl + d</code> 可以退出解释器</p><h4 id="ipython">3&gt; IPython</h4><ul><li>IPython 中 的 “I” 代表 <strong>交互 interactive</strong></li></ul><h5 id="特点">特点</h5><ul><li>IPython 是一个 python 的 <strong>交互式 shell</strong>，比默认的 <code>python shell</code> 好用得多<ul><li>支持自动补全</li><li>自动缩进</li><li>支持 <code>bash shell</code> 命令</li><li>内置了许多很有用的功能和函数</li></ul></li><li>IPython 是基于 BSD 开源的</li></ul><h5 id="版本">版本</h5><ul><li><p>Python 2.x 使用的解释器是 <strong>ipython</strong></p></li><li><p>Python 3.x 使用的解释器是 <strong>ipython3</strong></p></li><li><p>要退出解释器可以有以下两种方式：</p></li></ul><h5 id="直接输入-exit-1">1&gt; 直接输入 <code>exit</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: exit</span><br></pre></td></tr></table></figure><h5 id="使用热键退出-1">2&gt; 使用热键退出</h5><p>在 IPython 解释器中，按热键 <code>ctrl + d</code>，<code>IPython</code> 会询问是否退出解释器</p><h3 id="不过我选择vscode-一个编辑器走天下">### 3.3 不过我选择vscode, 一个编辑器走天下！</h3><p>工具顺手就行，只是为了提升开发效率，对Python的基本认识应该就到此位置了</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs系列之--相见恨晚</title>
      <link href="/2019/05/01_NodeJs%E7%B3%BB%E5%88%97%E4%B9%8B--%E7%9B%B8%E8%A7%81%E6%81%A8%E6%99%9A/"/>
      <url>/2019/05/01_NodeJs%E7%B3%BB%E5%88%97%E4%B9%8B--%E7%9B%B8%E8%A7%81%E6%81%A8%E6%99%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="第一部分-nodejs-初识">第一部分 NodeJs 初识</h3><p><strong>不知了了几行代码是否可以引起你的兴趣</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// service.js</span><br><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line">http.createServer(function(req,res)&#123;</span><br><span class="line">   res.write(&quot;Hello NodeJs&quot;);</span><br><span class="line">   res.end();</span><br><span class="line">&#125;).listen(8888);</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01_NodeJs系列之--相见恨晚/media/15563604190618/15567161245047.jpg"></p><h4 id="nodejs是什么">1 Nodejs是什么?</h4><ul><li><p>Node.js是一个让 <strong>JavaScript 运行在服务端的开发平台</strong>;</p></li><li><p>Node.js可以作为服务器向用户提供服务,它<strong>跳过了 Apache、Nginx 等 HTTP 服务器</strong>,直接面向前端开发。</p></li><li><p>优秀的第三方包管理器(node package manager,<strong>npm</strong>)</p></li></ul><h4 id="nodejs不是什么">2 Nodejs不是什么?</h4><ol type="1"><li><strong>Node.js 不是一种独立的语言</strong>，</li><li><strong>Node.js 不是一个 JavaScript 框架 ;</strong></li></ol><h4 id="nodejs能做什么">3 Nodejs能做什么?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 具有复杂逻辑的网站;</span><br><span class="line"> 基于社交网络的大规模 Web 应用;</span><br><span class="line"> Web Socket 服务器;</span><br><span class="line"> TCP/UDP 套接字应用程序; 8  命令行工具;</span><br><span class="line"> 交互式终端程序;</span><br><span class="line"> 带有图形用户界面的本地应用程序;</span><br><span class="line"> 单元测试工具;</span><br><span class="line"> 客户端 JavaScript 编译器。</span><br></pre></td></tr></table></figure><h4 id="nodejs-原理">4 Nodejs 原理</h4><p>Node.js 是基于<strong>Chrome V8引擎</strong>构建的，由事件循环（Event Loop）分发 I/O 任务，最终工作线程（Work Thread）将任务丢到<strong>线程池（Thread Pool）里去执行</strong>，而事件循环只要等待执行结果就可以了。</p><p><img src="/2019/05/01_NodeJs系列之--相见恨晚/media/15563604190618/15567164616816.jpg"></p><p>核心概念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* Chrome V8 是 Google 发布的开源 JavaScript 引擎，</span><br><span class="line">  采用 C/C++ 编写，在 Google 的 Chrome 浏览器中被使用。</span><br><span class="line">  Chrome V8 引擎可以独立运行，也可以用来嵌入到 C/C++ 应用程序中执行。</span><br><span class="line">* Event Loop 事件循环（由 libuv 提供）</span><br><span class="line">* Thread Pool 线程池（由 libuv 提供）</span><br></pre></td></tr></table></figure><p><strong>重点: 整体思路梳理</strong></p><p><strong>重点: 整体思路梳理</strong></p><p><strong>重点: 整体思路梳理</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. Chrome V8 是 JavaScript 引擎</span><br><span class="line">2. Node.js 内置 Chrome V8 引擎，所以它使用的 JavaScript 语法</span><br><span class="line">3. JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事</span><br><span class="line">4. 单线程就意味着，所有任务需要排队，前一个任务结束，</span><br><span class="line">   才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</span><br><span class="line">5. 如果排队是因为计算量大，CPU 忙不过来，倒也算了，</span><br><span class="line">   但是很多时候 CPU 是闲着的，因为 I/O 很慢，不得不等着结果出来，再往下执行。</span><br><span class="line">6. CPU 完全可以不管 I/O 设备，挂起处于等待中的任务，先运行排在后面的任务，</span><br><span class="line">   将等待中的 I/O 任务放到 Event Loop 里，由 Event Loop 将 I/O 任务放到线程池里，</span><br><span class="line">   只要有资源，就尽力执行。</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01_NodeJs系列之--相见恨晚/media/15563604190618/15567168580070.jpg"></p><p><strong>重点理解如下这句话</strong> &gt; Nodejs接受任务是单线程，执行任务是多线程。</p><p>思路如下：</p><ol type="1"><li>Nodejs内置V8，采用Js语言，是单线程的，故接受任务是单线程，无需进程/线程切换，<strong>非常高效</strong></li><li>EventLoop派发任务给线程池里的I/O去执行，故是多线程执行任务。</li></ol><h3 id="第二部分-配置开发环境">第二部分 配置开发环境</h3><h4 id="安装">1. 安装<a href="https://github.com/creationix/nvm" target="_blank" rel="noopener"><官方文档></官方文档></a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.0/install.sh | bash</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</span><br></pre></td></tr></table></figure><p>Mac安装后如果提示<code>nvm: command not found</code>, 是因为没有<code>[.bash_profile file]</code>文件，</p><p>第一种方法： 创建<code>touch ~/.bash_profile</code>, 然后重新执行curl操作； 第二种方法： 打开<code>.bash_profile</code>, 添加<code>source ~/.bashrc</code></p><h4 id="下载不同版本">2 下载不同版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                        now</span><br><span class="line">       (io.js)    v2.0   :          v2.x</span><br><span class="line">          |         |    :            |</span><br><span class="line"> v0.10.x  /--------------:-----------------\   Node.js 2.0</span><br><span class="line">____|____/               :                  \______|_____</span><br><span class="line">         \               :                  /</span><br><span class="line">          \--------------:-----------------/</span><br><span class="line">          |         |    :     |       |</span><br><span class="line">       (node.js) v0.12.x :  v0.13.x  v0.14.x</span><br></pre></td></tr></table></figure><p>对于nodejs与io.js的版本区别以及渊源，建议大家参考<a href="http://www.infoq.com/cn/articles/node-js-and-io-js/" target="_blank" rel="noopener">Node.js与io.js那些事儿</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#罗列可以安装的版本</span><br><span class="line">$ nvm ls-remote</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">   v6.4.0</span><br><span class="line">   v6.5.0</span><br><span class="line">   v6.6.0</span><br></pre></td></tr></table></figure><h4 id="下载版本">3 下载版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#为了演示,选择了6.6.0</span><br><span class="line">$ nvm install v6.6.0</span><br><span class="line"></span><br><span class="line">$ nvm install v5.12.0</span><br><span class="line">######################################################################## 100.0%</span><br><span class="line">WARNING: checksums are currently disabled for node.js v4.0 and later</span><br><span class="line">Now using node v5.12.0 (npm v3.8.6)</span><br></pre></td></tr></table></figure><h4 id="切换版本">4 切换版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ nvm use v5</span><br><span class="line">Now using node v5.12.0 (npm v3.8.6)</span><br><span class="line"></span><br><span class="line">$ nvm use v6</span><br><span class="line">Now using node v6.6.0 (npm v3.10.3)</span><br></pre></td></tr></table></figure><h4 id="常用命令">5 常用命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 下载</span><br><span class="line">$ nvm install ***</span><br><span class="line">#切换版本</span><br><span class="line">$ nvm use 版本号</span><br><span class="line">#罗列下载的版本</span><br><span class="line">$nvm ls</span><br><span class="line"># 罗列远程版本</span><br><span class="line">$nvm ls-remote</span><br><span class="line">#设置默认的版本</span><br><span class="line">$nvm alias default 版本</span><br></pre></td></tr></table></figure><h3 id="第三部分-注意事项">第三部分 注意事项</h3><ol type="1"><li><p>当关闭终端在此打开时, 输入 <strong>nvm</strong>会提示找不到, 解决办法: 在<code>.bash_profile</code>文件中添加<code>source ~/.bashrc</code>;即可;</p></li><li><p><strong>nvm安装</strong>的路径是: <code>~/.nvm</code>;</p></li><li><p>使用nvm安装<strong>node, 会安装在该路径</strong>下: <code>~/.nvm/versions/node</code>;</p></li></ol><p><strong>附加</strong></p><p>Mac 环境变量配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1./etc/profile: (不建议修改这个文件）全局（公有）配置，不管是哪个用户，登录时都会读取该文件。</span><br><span class="line">2./etc/bashrc: 系统级环境变量. 全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。</span><br><span class="line">3.~/.bash_profile: 用户级环境变量.每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NexT使用</title>
      <link href="/2019/04/27_NexT%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/04/27_NexT%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>第一部分</p><p>语言</p><p>rss</p><p>标签、类别、</p><p>账户</p><p>公益</p><p>首页显示</p><h4 id="背景显示">背景显示</h4><p><a href="https://github.com/theme-next/theme-next-canvas-nest" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd themes/next</span><br><span class="line">$ git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest</span><br></pre></td></tr></table></figure><p>更改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>https://github.com/theme-next/theme-next-canvas-nest</p><h4 id="侧边栏推荐阅读">侧边栏推荐阅读</h4><p><code>theme/next/_config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Blogrolls</span><br><span class="line">links_title: 推荐阅读</span><br><span class="line">#links_layout: block</span><br><span class="line">links_layout: inline</span><br><span class="line">links:</span><br><span class="line">  简单即是美: https://simuty.github.io/</span><br></pre></td></tr></table></figure><p>第二部分</p><p>文章头</p><h4 id="自定义样式">自定义样式</h4><p>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入：(颜色可以自己定义)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">code &#123;</span><br><span class="line">    color: #ff7600;</span><br><span class="line">    background: #fbf7f8;</span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">// 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid #d6d6d6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统计字数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>然后在<code>/themes/next/layout/_partials/footer.swig</code>文件尾部加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;theme-info&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>阅读时长</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>在<code>hexo/_config.yml</code>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">symbols: true</span><br><span class="line">time: true</span><br><span class="line">total_symbols: true</span><br><span class="line">total_time: true</span><br></pre></td></tr></table></figure><p>在<code>hexo/theme/next/_config.yml</code>中找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure><p>代码</p><p>音视频</p><p>post阴影</p><p>打开_custom.styl,向里面加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 主页文章添加阴影效果</span><br><span class="line"> .post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>http://devinol.com/Hexo/Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96-%E4%BA%8C/</p><h4 id="section"></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>打开 站点配置文件 ,添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line">打开 主题配置文件 ,搜索关键字local_search,设置为true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/flashlab/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure><p>打赏</p><p>文章加密 https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md hexo-blog-encrypt</p><p>参考链接</p><p><a href="https://co5.me/2018/180613-wordcount.html" target="_blank" rel="noopener">†少女癌†</a></p><p><a href="http://devinol.com/Hexo/Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96-%E5%9B%9B/" target="_blank" rel="noopener"></a></p><p><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener"></a></p><p><a href="https://www.vincentqin.tech/" target="_blank" rel="noopener"></a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NexT使用</title>
      <link href="/2019/04/27_NexT%E4%BD%BF%E7%94%A8%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2019/04/27_NexT%E4%BD%BF%E7%94%A8%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>第一部分</p><p>语言</p><p>rss</p><p>标签、类别、</p><p>账户</p><p>公益</p><p>首页显示</p><h4 id="背景显示">背景显示</h4><p><a href="https://github.com/theme-next/theme-next-canvas-nest" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd themes/next</span><br><span class="line">$ git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest</span><br></pre></td></tr></table></figure><p>更改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>https://github.com/theme-next/theme-next-canvas-nest</p><h4 id="侧边栏推荐阅读">侧边栏推荐阅读</h4><p><code>theme/next/_config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Blogrolls</span><br><span class="line">links_title: 推荐阅读</span><br><span class="line">#links_layout: block</span><br><span class="line">links_layout: inline</span><br><span class="line">links:</span><br><span class="line">  简单即是美: https://simuty.github.io/</span><br></pre></td></tr></table></figure><p>第二部分</p><p>文章头</p><h4 id="自定义样式">自定义样式</h4><p>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入：(颜色可以自己定义)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">code &#123;</span><br><span class="line">    color: #ff7600;</span><br><span class="line">    background: #fbf7f8;</span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">// 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid #d6d6d6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统计字数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>然后在<code>/themes/next/layout/_partials/footer.swig</code>文件尾部加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;theme-info&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>阅读时长</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>在<code>hexo/_config.yml</code>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">symbols: true</span><br><span class="line">time: true</span><br><span class="line">total_symbols: true</span><br><span class="line">total_time: true</span><br></pre></td></tr></table></figure><p>在<code>hexo/theme/next/_config.yml</code>中找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure><p>代码</p><p>音视频</p><p>post阴影</p><p>打开_custom.styl,向里面加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 主页文章添加阴影效果</span><br><span class="line"> .post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>http://devinol.com/Hexo/Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96-%E4%BA%8C/</p><h4 id="section"></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>打开 站点配置文件 ,添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line">打开 主题配置文件 ,搜索关键字local_search,设置为true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/flashlab/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure><p>打赏</p><p>文章加密 https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md hexo-blog-encrypt</p><p>参考链接</p><p><a href="https://co5.me/2018/180613-wordcount.html" target="_blank" rel="noopener">†少女癌†</a></p><p><a href="http://devinol.com/Hexo/Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96-%E5%9B%9B/" target="_blank" rel="noopener"></a></p><p><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener"></a></p><p><a href="https://www.vincentqin.tech/" target="_blank" rel="noopener"></a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迁移博客</title>
      <link href="/2019/04/27_%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/04/27_%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="为何要写博客">&gt;0001 为何要写博客？</h2><h1 id="记录点滴分享所得">...记录点滴、分享所得。</h1><h2 id="为何要自建博客">&gt;0010 为何要自建博客？</h2><h1 id="一分为乐趣一分为自由">...一分为乐趣，一分为自由。</h1><h2 id="类似的资源那么多为何要重复">&gt;0011 类似的资源那么多，为何要重复？</h2><h1 id="存在不代表拥有所得才可拥有">...存在不代表拥有，所得才可拥有</h1><p><code>Hello World</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello World"</span>);</span><br><span class="line">System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure><figure><img src="/2019/04/27_迁移博客/27-01_kiding.png" alt><figcaption>asd</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些美的东西</title>
      <link href="/1/"/>
      <url>/1/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="暗号：天王盖地虎." />    <label for="pass">暗号：天王盖地虎.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19ddEjWxYXzR9v4AEqn627UySsudAXFr8Gg4dWRb7CJOd6CMG07MxcIb5FJWjVAPO5CDnqNqlsrEDc54iBU5l192k0iVLJmpD1fVzwttrswLjKQ3Qw9mP5xNbqWMtEItpN8t+TVmKDckmTunqgj9FPII+IGknZ2SK3/20M1QGO1v4lwh12A45qjaLxHPJsWfODy8xqjIDkljLlbIgU9gXLRLEi1yvT5fuYxaBNU8J8LcI9Yoa0vFfj75WLp/x1gx7KUhPVAVe5rMSKUOBXqezjwxYQpH8jCbulGmr/iwUf+Qeg+dT+fBql7A2da907tGVFCWthvVmJSQ8POgJimlVgPOnLEB2PlWUHypXXZFPlx4ts1AQvJ/6NyWtQoKDnOU/t52eNtULdz22MpCkBbpkKOcM5ZCrFm0ZL2VVhIgvGzx0K37hAdtf1Mp4bCdCLYI75razRRL1z5gpUnimpDJpLRANBI374urXvuNZf1v9Y3AwCU0eoUUG5XSoph0ktYpKEJpSM6038/mdQ2dso0s6hltPbSoJlNOn71XzA+LQfbtrW1RmhEFSS5f3dfc40MkRBb+qJKf8Kp7P6MNDpyXFa+hKa2OH5xawaCVdrho8ymH8Xgo+G3NY0IyCdvX0O6uG+3vRuicc4PiFzUMHkB6s7SZ1e7CwrAsjkdEScEeNryyH0RdNQbwpZI4Ml4yTcUXye+ELgHq0gmkQX/QifYL0XDt/pT2ZKiLRF0frwQzuFCL3IZBBRMK3dbfKtrJTuGgYlMXgBEK0Na75sx1R+UuRAK41NJ3aspj6nmJnTx7LBK5agyHoGyU3kBljSzUmaQBTV2bGoqr57USIhoFEDxPU2OnNip2yn4NcIOcL+8LKk+FxUYukVDRqBZWN5D0I3x11QjSarvi/xnH2b9RTJQEMTPgy2seMhQERnnXLQ5WrlSyoesqIKv+FADrzib2+7kmZQaVQKy1ynzlm9U39PSTTgJ6NXSxJmsE84FqYmN42mXDWg5BWLdTuBBwssfz/TZrgBCajiFz3ZMDHBtWjAJWRiTSft23kqve/tkHe8Pp5gJpXK1YbrXtgse5sagJaqiYyLeuN+oZeBUBhXRgGM++TSfxX+UV8kBkW8LaW7ErkNvkHmznjBAslKiqDnr4wjA6ZWoTskqLSuVdJ0k4fGauOjxPBblEZsVq8utj6yMwCyLcrI0632zebQWZlBmemvR/5/hmKBjtoRW9JH4zcPulKicJnaRIJhsWt9xp77VUaukNBGAmVhCwFkJYLT61B8t+kpS2vNcH4rH7h7fewLk/gWwaxO18nhEDrIHLqAiOmjsFKOXf18pTFWEJZ8n5prxKzQJuYeSn1JAoRJ1F+8TjUBTzYcq5OczNlvPHlV5Ve31Dx81ODRPJm8fqTT9NC3ArprUbPdYvwnUY9vXjaAqllsYg0mNtixoFpxaJ6dj2Q49lbCmrv5SDv4jCvloV9r4YyWfveiTjobvRbo6RueTk9rEa8jD9L1SteqlMUBPp/0D6YAKFZZSsnZBu1EAysQpI2TKN1xIlgME0RDD8YBirvg52lmXbA9T+SZ7jOmXZgrPAwEjl+5DrXBpRwHNykUznTW3aqTrL7tBiqCoo9aabqJ67tg+jg8j1r+zZB17y5/QnD9eiQcXfs9bsk+SdCgeDFZwsEHIdw9UGe7zDaM4SaFTGTAm67G6DNRUC9bBfm1337Ef30xqowCExGlyeezjvXm/EqpgycIKLQlsJ6hXFfTz4vM07gsCV+upqD7TY5XLSyJdhyzIk9fxAA3IOgQpzbUiZed53LkGxkbVReIaLNer1SzzryzQFXlUhsPVQ8KFe/9cnEctupMDv8lWZ3JJAnHSVvoCGeVFji8pt5qW3zHctLT79RgMjB3k64fFtyVmfKyTIPL4TgruBCljZZue/q5/pzzHZN2Xggy0+noS0WF+5TzMUh8GNi4aIv00C5WFP3wEEzxuATTDoka5Cf5kI27+PI84oS91oi1cus05K2pTwga9AfX92tRKWF4m1eqK/Zr6Y+Gl1lN3hiso1Nf4Wuk1fptjZLMU9p3NV+fl1WeKnHZGWb96EP8NMUjWZnpGrIdTun/l5R8iIpaR6VDrWoj9p/gUV2wlPqocJGpfK79yFaHNGH80YvvBOHHRC5Z68tV6fPRd4D916DyJeQl4vyzD2E9f4fL3FNh2iOD3RVCNf/cwWIaOY/yUu7K4Vq4EgLo8NONa9m9Vjjx7KsQOVTvGlJyHqJ6wKX8fyFPhkAw1/VCQFw1s/A7k4lFzIogjFjKsZ8ow+Jb6jQIAlX+m6lc07NrzAFlWvzb59MQ0yhZyNBg6K9S8B894IcMnKmNhkdg2kOJAfG9t8JIgO1u4wQULC1fisZaSj9PTbkw34uAV8yRhZqZpAG7VsVzD7RJ73icNmv9xbie86uuHY41seH7GTH3qsDPXEbta2QTc9S9enIwd2se6xPQ5gbtNVRrCGFoYeZgNjI/Wwphl1u15TTjMQfGviQPNUf+2xcKtnyn+7AtrL7YMbYSZox5safvAiW+KcSOhZWNIZwJPXWW2lxnlU2tR98+qZc1Dugo2m1vERHZilE8Oy9N9+Y+4yvsEvdEHg3eHwMJ7jvGxpcsqHGU6M4WQ56Q6jnP5AXyA2XygC1g+aOsbEBz9h2NiRtPdQgZYlLBYeyVoxZUODF8jElyQZ55+AG/63vp+86u+iLO2k6Ud9iw8v2El8dO+T9pZWhQL3tZXbpgTVeHgJsS5xYWmxNsGFKDswYIFagxbID/plc5GD7Gy68vfv0HJ54KsXGYseggf0wWGXc/8fBX3fv1s7HXel/54xO+drdefRW8NfUPf3/9C6Fi0uG0JqNYqLD/5di0e9X9BFfhRPsaiOqPiYc32ibCBkg==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 句子 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
